<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>特别好用的二分查找法模板（第 2 版）</title>
      <link href="/leetcode-algo/2020/04/29/leetcode-solution-new/search-insert-position/"/>
      <url>/leetcode-algo/2020/04/29/leetcode-solution-new/search-insert-position/</url>
      
        <content type="html"><![CDATA[<h2 id="特别好用的二分查找法模板（第-2-版）"><a href="#特别好用的二分查找法模板（第-2-版）" class="headerlink" title="特别好用的二分查找法模板（第 2 版）"></a>特别好用的二分查找法模板（第 2 版）</h2><blockquote><p>特点：</p><p>1、讲思想，讲原理；</p><p>2、把细节的地方理解清楚，就不难了，二分法可以轻松掌握。</p></blockquote><h3 id="一、点击视频快速理解"><a href="#一、点击视频快速理解" class="headerlink" title="一、点击视频快速理解"></a>一、点击视频快速理解</h3><ul><li><p>「力扣」第 1095 题：山脉数组中查找目标值 <a href="https://leetcode-cn.com/problems/find-in-mountain-array/solution/shan-mai-shu-zu-zhong-cha-zhao-mu-biao-zhi-by-leet/" target="_blank" rel="noopener">题解</a>；</p></li><li><p>「力扣」第 35 题：搜索插入位置 <a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">题解</a>。</p></li></ul><p>说明：本文是第 1 稿，第 2 稿现在发布在「力扣」第 35 题的题解上，上面有链接地址。</p><h3 id="二、学习关键点"><a href="#二、学习关键点" class="headerlink" title="二、学习关键点"></a>二、学习关键点</h3><ul><li><p>二分查找算法是典型的「减治思想」的应用，我们使用二分查找将待搜索的区间逐渐缩小，以达到「缩减问题规模」的目的；</p></li><li><p>掌握二分查找的两种思路：</p><ul><li>思路 1：在循环体内部查找元素：<code>while (left &lt;= right)</code>；</li><li>思路 2：在循环体内部排除元素：<code>while (left &lt; right)</code>。</li></ul></li><li><p>全部使用<strong>左闭右闭</strong>区间，不建议使用左闭右开区间，反而使得问题变得复杂；</p></li><li><p><strong>不建议背模板</strong>，每一步都要清楚为什么这样写，不要跳步，更不能想当然。</p></li></ul><h3 id="三、思路-1：在循环体内部查找元素（解决简单问题时有用）"><a href="#三、思路-1：在循环体内部查找元素（解决简单问题时有用）" class="headerlink" title="三、思路 1：在循环体内部查找元素（解决简单问题时有用）"></a>三、思路 1：在循环体内部查找元素（解决简单问题时有用）</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特殊用例判断</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 在 [left, right] 区间里查找 target</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 为了防止 left + right 整形溢出，写成如下形式</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间：[left, mid - 1]</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 此时：nums[mid] &lt; target，下一轮搜索区间：[mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><p>最简单的二分查找思路：在一个有序数组里查找目标元素。特别像以前电视「猜价格」上的猜价格游戏：运气好，一下子猜中，如果主持人说猜高了，下一步就应该往低了猜，如果主持人说猜低了，下一步就应该就往高了猜。这个思路把待搜索区间 <code>[left, right]</code> 分为 3 个部分：</p><ul><li><code>mid</code> 位置（只有 1 个元素）；</li><li><code>[left, mid - 1]</code> 里的所有元素；</li><li><code>[mid + 1, right]</code> 里的所有元素；</li></ul></li><li><p>于是，二分查找就是不断地在区间 <code>[left, right]</code> 里根据 <code>left</code> 和 <code>right</code> 的中间位置 <code>mid = (left + right) / 2</code> 的元素大小，也就是看 <code>nums[mid]</code> 与 <code>target</code> 的大小关系：</p><ul><li>如果 <code>nums[mid] == target</code> ，返回 <code>mid</code>；</li><li>如果 <code>nums[mid] &lt; target</code> ，由于数组有序，<code>mid</code> 以及 <code>mid</code> 左边的所有元素都小于 <code>target</code>，目标元素可能在区间 <code>[mid + 1, right]</code> 里，因此设置 <code>left = mid + 1</code>；</li><li>如果 <code>nums[mid] &gt; target</code> ，由于数组有序，<code>mid</code> 以及 <code>mid</code> 右边的所有元素都大于 <code>target</code>，目标元素可能在区间 <code>[left, mid - 1]</code> 里，因此设置 <code>right = mid - 1</code>。</li></ul></li><li><p><strong>循环体内一定有 3 个分支，并且第 1 个分支一定用于退出循环，或者直接返回目标元素</strong>；</p></li><li><p>退出循环以后，<code>left</code> 和 <code>right</code> 的位置关系为 <code>[right, left]</code> ，返回 <code>left</code> 或者 <code>right</code> 需考虑清楚。</p></li></ul><p><strong>注意事项</strong>：</p><ul><li>许多刚刚写的朋友，经常在写 <code>left = mid + 1;</code> 还是写 <code>right = mid - 1;</code> 上感到困惑，一个行之有效的思考策略是：<strong>永远去想下一轮目标元素应该在哪个区间里</strong>；<ul><li>如果目标元素在区间 <code>[left, mid - 1]</code> 里，就需要设置设置 <code>right = mid - 1</code>；</li><li>如果目标元素在区间 <code>[mid + 1, right]</code> 里，就需要设置设置 <code>left = mid + 1</code>；</li></ul></li><li>考虑不仔细是初学二分法容易出错的地方，这里切忌跳步，需要仔细想清楚每一行代码的含义；</li><li>循环可以继续的条件是 <code>while (left &lt;= right)</code>，特别地，当 <code>left == right</code> 即当待搜索区间里只有一个元素的时候，查找也必须进行下去；</li><li><code>int mid = (left + right) / 2;</code> 在 <code>left + right</code> 整形溢出的时候，<code>mid</code> 会变成负数，回避这个问题的办法是写成 <code>int mid = left + (right - left) / 2;</code>。</li></ul><h3 id="四、思路-2：在循环体内部排除元素（在解决复杂问题时非常有用）"><a href="#四、思路-2：在循环体内部排除元素（在解决复杂问题时非常有用）" class="headerlink" title="四、思路 2：在循环体内部排除元素（在解决复杂问题时非常有用）"></a>四、思路 2：在循环体内部排除元素（在解决复杂问题时非常有用）</h3><blockquote><p>这个版本的模板推荐使用的原因是：<strong>需要考虑的细节最少，编码时不容易出错</strong>。</p></blockquote><p>根据中间数被分到左边还是右边，一共就以下两种写法。不能死记硬背，应该通过多练习，理解当看到 <code>left = mid</code> 的时候，将取中间数的取法改成上取整的原因。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在区间 [left, right] 里查找目标元素</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 选择中间数时下取整</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [mid + 1, right]</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [left, mid]</span>            right <span class="token operator">=</span> mid        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 退出循环的时候，程序只剩下一个元素没有看到，视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在区间 [left, right] 里查找目标元素</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 选择中间数时上取整</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [left, mid - 1]</span>            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [mid, right]</span>            left <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 退出循环的时候，程序只剩下一个元素没有看到，视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理解模板代码的要点：</p><ul><li>核心思想：虽然模板有两个，但是核心思想只有一个，那就是：把待搜索的目标元素放在最后判断，每一次循环排除掉不存在目标元素的区间，目的依然是确定下一轮搜索的区间；</li><li>特征：<code>while (left &lt; right)</code>，这里使用严格小于 <code>&lt;</code> 表示的临界条件是：当区间里的元素只有 2 个时，依然可以执行循环体。换句话说，退出循环的时候一定有 <code>left == right</code> 成立，<strong>这一点在定位元素下标的时候极其有用</strong>；</li><li>在循环体中，先考虑 <code>nums[mid]</code> 在满足什么条件下不是目标元素，进而考虑两个区间 <code>[left, mid - 1]</code> 以及 <code>[mid + 1, right]</code> 里元素的性质，目的依然是确定下一轮搜索的区间； <ul><li><strong>注意 1</strong>：先考虑什么时候不是解，是一个经验，在绝大多数情况下不易出错，重点还是确定下一轮搜索的区间，由于这一步不容易出错，它的反面（也就是 <code>else</code> 语句的部分），就不用去考虑对应的区间是什么，直接从上一个分支的反面区间得到，进而确定边界如何设置；</li></ul></li><li>根据边界情况，看取中间数的时候是否需要上取整；<ul><li><strong>注意 2</strong>： 这一步也依然是根据经验，建议先不要记住结论，在使用这个思想解决问题的过程中，去思考可能产生死循环的原因，进而理解什么时候需要在括号里加 1 ，什么时候不需要；</li></ul></li><li>在退出循环以后，根据情况看是否需要对下标为 <code>left</code> 或者 <code>right</code> 的元素进行单独判断，这一步叫「后处理」。在有些问题中，排除掉所有不符合要求的元素以后，剩下的那 1 个元素就一定是目标元素。如果根据问题的场景，目标元素一定在搜索区间里，那么退出循环以后，可以直接返回 <code>left</code>（或者 <code>right</code>）。</li></ul><p>以上是这两个模板写法的所有要点，并且是高度概括的。请读者一定先抓住这个模板的核心思想，在具体使用的过程中，不断地去体会这个模板使用的细节和好处。只要把中间最难理解的部分吃透，几乎所有的二分问题就都可以使用这个模板来解决，因为「减治思想」是通用的。好处在这一小节的开篇介绍过了，需要考虑的细节最少。</p><p><strong>学习建议</strong>：</p><ul><li>一定需要多做练习，体会这（两）个模板的使用；</li></ul><ul><li>先写分支逻辑，再决定中间数是否上取整；</li><li>在使用多了以后，就很容易记住，只要看到 <code>left = mid</code> ，它对应的取中位数的取法一定是 <code>int mid = left + (right - left + 1) / 2;</code>。</li></ul><h3 id="五、使用建议"><a href="#五、使用建议" class="headerlink" title="五、使用建议"></a>五、使用建议</h3><ul><li>简单问题使用思路 1：即要找的那个数的性质特别简单：<code>==</code> 的情况好写，<code>&lt;</code> 的情况好写，<code>&gt;</code> 的情况也好写的时候；</li><li>复杂问题使用思路 2：即要找的那个数的性质有点复杂，可能需要借助单调性。用思路 2 就可以把两个边界逐渐向中间收缩，直至找到目标元素。</li><li>区别：<ul><li>思路 1 循环体内部有 3 个分支，一定有一个分支用于退出循环或者直接返回，因此无需「后处理」；</li><li>思路 2 循环体内部有 2 个分支，两个分支都在缩小待搜索区间，退出循环以后，可能需要「后处理」。</li></ul></li></ul><h3 id="六、练习"><a href="#六、练习" class="headerlink" title="六、练习"></a>六、练习</h3><p>「力扣」上的二分查找问题主要有以下这三类。这些练习题都可以使用两种二分查找法的思路比较轻松地写出来，并且得到一个不错的分数，大家加油！</p><h4 id="1、在数组中查找符合条件的元素的下标"><a href="#1、在数组中查找符合条件的元素的下标" class="headerlink" title="1、在数组中查找符合条件的元素的下标"></a>1、在数组中查找符合条件的元素的下标</h4><p>一般而言这个数组是有序的，也可能是半有序的，但不大可能是无序的。</p><table><thead><tr><th>题目</th><th>提示与题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></td><td>二分查找的模板问题，使用本题解介绍的方法就要注意，需要「后处理」。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></td><td>查找边界问题，<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/" target="_blank" rel="noopener">题解（有视频讲解）</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></td><td><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-java-dai-ma-by-/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></td><td>二分查找的思路需要理解，代码很像第 35 题，<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">275. H指数 II</a></td><td><a href="https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></td><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/" target="_blank" rel="noopener">题解</a>，<a href="https://leetcode-cn.com/problems/find-in-mountain-array/solution/shan-mai-shu-zu-zhong-cha-zhao-mu-biao-zhi-by-leet/" target="_blank" rel="noopener">题解（有视频讲解）</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个有序数组的中位数</a></td><td>二分搜索中最难的问题之一，建议先弄清楚解题思路，<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/" target="_blank" rel="noopener">题解</a>。</td></tr></tbody></table><h4 id="2、在一个有上下界的区间里搜索一个整数"><a href="#2、在一个有上下界的区间里搜索一个整数" class="headerlink" title="2、在一个有上下界的区间里搜索一个整数"></a>2、在一个有上下界的区间里搜索一个整数</h4><table><thead><tr><th>题目</th><th>提示与题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. 平方根</a></td><td>在一个整数范围里查找一个整数，也是二分查找法的应用场景，<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></td><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/" target="_blank" rel="noopener">题解</a>，在一个整数范围里查找一个整数。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a></td><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/" target="_blank" rel="noopener">题解</a></td></tr></tbody></table><h4 id="3、判别条件是一个函数"><a href="#3、判别条件是一个函数" class="headerlink" title="3、判别条件是一个函数"></a>3、判别条件是一个函数</h4><table><thead><tr><th>题目</th><th>提示与题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></td><td>二分搜索中最难的问题之一，判别函数的写法很有技巧。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素</a></td><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></td><td><a href="https://leetcode-cn.com/problems/koko-eating-bananas/solution/er-fen-cha-zhao-ding-wei-su-du-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr></tbody></table><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 1095 题：山脉数组中查找目标值（困难）</title>
      <link href="/leetcode-algo/2020/04/29/leetcode-algo/1095-find-in-mountain-array/"/>
      <url>/leetcode-algo/2020/04/29/leetcode-algo/1095-find-in-mountain-array/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-1095-题：山脉数组中查找目标值（困难）"><a href="#「力扣」第-1095-题：山脉数组中查找目标值（困难）" class="headerlink" title="「力扣」第 1095 题：山脉数组中查找目标值（困难）"></a>「力扣」第 1095 题：山脉数组中查找目标值（困难）</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/" target="_blank" rel="noopener">十分好用的二分查找法模板（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a>。</p><blockquote><p>（这是一个 交互式问题 ）</p><p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p><p>如果不存在这样的下标 index，就请返回 -1。</p><p>所谓山脉数组，即数组 A 假如是一个山脉数组的话，需要满足如下条件：</p><p>首先，A.length &gt;= 3</p><p>其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：</p><p>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]<br>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</p><p>你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：</p><p>MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）<br>MountainArray.length() - 会返回该数组的长度</p><p>注意：</p><p>对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p><p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “答案”：<a href="https://leetcode-cn.com/playground/RKhe3ave，请注意这" target="_blank" rel="noopener">https://leetcode-cn.com/playground/RKhe3ave，请注意这</a> 不是一个正确答案。</p><p>示例 1：</p><p>输入：array = [1,2,3,4,5,3,1], target = 3<br>输出：2<br>解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。<br>示例 2：</p><p>输入：array = [0,1,2,4,2,1], target = 3<br>输出：-1<br>解释：3 在数组中没有出现，返回 -1。</p><p>提示：</p><p>3 &lt;= mountain_arr.length() &lt;= 10000<br>0 &lt;= target &lt;= 10^9<br>0 &lt;= mountain_arr.get(index) &lt;= 10^9</p></blockquote><h2 id="十分好用的二分查找法模板（Python-代码、Java-代码）"><a href="#十分好用的二分查找法模板（Python-代码、Java-代码）" class="headerlink" title="十分好用的二分查找法模板（Python 代码、Java 代码）"></a>十分好用的二分查找法模板（Python 代码、Java 代码）</h2><p>根据题意，分析如下：</p><p>1、理解“山脉数组”，“山脉数组”可以分为两部分，一部分是“前有序数组”，另一部分是“后有序数组”，“前有序数组”是升序数组，“后有序数组”是降序数组。</p><p>2、题目还告诉我们“对 <code>MountainArray.get</code> 发起超过 <code>100</code> 次调用的提交将被视为错误答案”，就在疯狂暗示你使用时间复杂度低的算法，对于有序数组当然使用“二分查找法”。</p><h3 id="方法：二分查找法"><a href="#方法：二分查找法" class="headerlink" title="方法：二分查找法"></a>方法：二分查找法</h3><p>自然地，求解这道题可以分为 3 步：</p><p>第 1 步：先找到山顶元素 mountaintop 所在的索引。</p><blockquote><p>说到 mountaintop，你是不是跟我一样，很想唱起来：“mountaintop，就我一起来”，嘻嘻嘻 ^_^ ，调皮一下。</p></blockquote><p>第 2 步：在前有序且升序数组中找 target 所在的索引，如果找到了，就返回，如果没有找到，就执行第 3 步；</p><p>第 3 步：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引。</p><blockquote><p><strong>注意：</strong> 具体编码实现的时候，每一步写一个辅助方法就可以了。这 3 个辅助方法都是二分查找法。</p></blockquote><p>在这里我要向你强烈推荐我使用了很久的二分查找法模板。我专门把这个二分法模板好用的地方、使用它的技巧和注意事项整理在了「力扣 」第 35 题：搜索插入位置的题解<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">《特别好用的二分查找法模板（Python 代码、Java 代码）》</a>，希望能对大家有所帮助。</p><p>如果你会了这个模板，你就会发现使用这个模板，写出来的 3 个辅助方法的分支逻辑出奇地一样，在取中位数的时候，都取左中位数，才不会发生死循环。</p><p>下面给出的参考代码包括了抽象类（接口）和我的简单实现类，还有一些调试的代码。</p><p><strong>参考代码</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * // This is MountainArray's API interface. * // You should not implement it, or speculate about its implementation */</span><span class="token keyword">interface</span> <span class="token class-name">MountainArray</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MountainArrayImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MountainArray</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MountainArrayImpl</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> arr<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 特别注意：3 个辅助方法的分支出奇地一样，因此选中位数均选左中位数，才不会发生死循环</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findInMountainArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> MountainArray mountainArr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> mountainArr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤 1：先找到山顶元素所在的索引</span>        <span class="token keyword">int</span> mountaintop <span class="token operator">=</span> <span class="token function">findMountaintop</span><span class="token punctuation">(</span>mountainArr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤 2：在前有序且升序数组中找 target 所在的索引</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">findFromSortedArr</span><span class="token punctuation">(</span>mountainArr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mountaintop<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 步骤 3：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引</span>        <span class="token keyword">return</span> <span class="token function">findFromInversedArr</span><span class="token punctuation">(</span>mountainArr<span class="token punctuation">,</span> mountaintop <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findMountaintop</span><span class="token punctuation">(</span>MountainArray mountainArr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 返回山顶元素</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 取左中位数，因为进入循环，数组一定至少有 2 个元素</span>            <span class="token comment" spellcheck="true">// 因此，左中位数一定有右边元素，数组下标不会发生越界</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果当前的数比右边的数小，它一定不是山顶</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 根据题意，山顶元素一定存在，因此退出 while 循环的时候，不用再单独作判断</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findFromSortedArr</span><span class="token punctuation">(</span>MountainArray mountainArr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 在前有序且升序数组中找 target 所在的索引</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 因为不确定区间收缩成 1个数以后，这个数是不是要找的数，因此单独做一次判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findFromInversedArr</span><span class="token punctuation">(</span>MountainArray mountainArr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 在后有序且降序数组中找 target 所在的索引</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 与 findFromSortedArr 方法不同的地方仅仅在于由原来的小于号改成大于好</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 因为不确定区间收缩成 1个数以后，这个数是不是要找的数，因此单独做一次判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mountainArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> target <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        MountainArray mountainArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MountainArrayImpl</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">findInMountainArray</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> mountainArray<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># </span><span class="token triple-quoted-string string">"""# This is MountainArray's API interface.# You should not implement it, or speculate about its implementation# """</span><span class="token keyword">class</span> <span class="token class-name">MountainArray</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>arr <span class="token operator">=</span> arr        self<span class="token punctuation">.</span>size <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">length</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>size<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 特别注意：3 个辅助方法的分支出奇地一样，因此选中位数均选左中位数，才不会发生死循环</span>    <span class="token keyword">def</span> <span class="token function">findInMountainArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">,</span> mountain_arr<span class="token punctuation">:</span> <span class="token string">'MountainArray'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        size <span class="token operator">=</span> mountain_arr<span class="token punctuation">.</span>length<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 步骤 1：先找到山顶元素所在的索引</span>        mountaintop <span class="token operator">=</span> self<span class="token punctuation">.</span>__find_mountaintop<span class="token punctuation">(</span>mountain_arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 步骤 2：在前有序且升序数组中找 target 所在的索引</span>        res <span class="token operator">=</span> self<span class="token punctuation">.</span>__find_from_sorted_arr<span class="token punctuation">(</span>mountain_arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mountaintop<span class="token punctuation">,</span> target<span class="token punctuation">)</span>        <span class="token keyword">if</span> res <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res        <span class="token comment" spellcheck="true"># 步骤 3：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__find_from_inversed_arr<span class="token punctuation">(</span>mountain_arr<span class="token punctuation">,</span> mountaintop <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__find_mountaintop</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> mountain_arr<span class="token punctuation">:</span> <span class="token string">'MountainArray'</span><span class="token punctuation">,</span> l<span class="token punctuation">:</span> int<span class="token punctuation">,</span> r<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 返回山顶元素</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token comment" spellcheck="true"># 取左中位数，因为进入循环，数组一定至少有 2 个元素</span>            <span class="token comment" spellcheck="true"># 因此，左中位数一定有右边元素，数组下标不会发生越界</span>            <span class="token keyword">if</span> mountain_arr<span class="token punctuation">.</span>get<span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> mountain_arr<span class="token punctuation">.</span>get<span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 如果当前的数比右边的数小，它一定不是山顶</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> mid        <span class="token comment" spellcheck="true"># 根据题意，山顶元素一定存在，因此退出 while 循环的时候，不用再单独作判断</span>        <span class="token keyword">return</span> l    <span class="token keyword">def</span> <span class="token function">__find_from_sorted_arr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> mountain_arr<span class="token punctuation">:</span> <span class="token string">'MountainArray'</span><span class="token punctuation">,</span> l<span class="token punctuation">:</span> int<span class="token punctuation">,</span> r<span class="token punctuation">:</span> int<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 在前有序且升序数组中找 target 所在的索引</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> mountain_arr<span class="token punctuation">.</span>get<span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> mid        <span class="token comment" spellcheck="true"># 因为不确定区间收缩成 1 个数以后，这个数是不是要找的数，因此单独做一次判断</span>        <span class="token keyword">if</span> mountain_arr<span class="token punctuation">.</span>get<span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>            <span class="token keyword">return</span> l        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__find_from_inversed_arr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> mountain_arr<span class="token punctuation">:</span> <span class="token string">'MountainArray'</span><span class="token punctuation">,</span> l<span class="token punctuation">:</span> int<span class="token punctuation">,</span> r<span class="token punctuation">:</span> int<span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 在后有序且降序数组中找 target 所在的索引</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token comment" spellcheck="true"># 与 __find_from_sorted_arr 方法不同的地方仅仅在于由原来的小于号改成大于号</span>            <span class="token keyword">if</span> mountain_arr<span class="token punctuation">.</span>get<span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">></span> target<span class="token punctuation">:</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> mid        <span class="token keyword">if</span> mountain_arr<span class="token punctuation">.</span>get<span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>            <span class="token keyword">return</span> l        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>    mountain_array <span class="token operator">=</span> MountainArray<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    target <span class="token operator">=</span> <span class="token number">3</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> solution<span class="token punctuation">.</span>findInMountainArray<span class="token punctuation">(</span>target<span class="token punctuation">,</span> mountain_array<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'res'</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(\log N)$，二分查找法的时间复杂度是对数级别的，这里使用了 $3$ 次二分查找法，是常数倍数，因此可以忽略这个常数系数。</li><li>空间复杂度：$O(1)$，这里使用的额外的辅助空间仅仅是 <code>mountaintop</code>、中位数索引 <code>mid</code> 等，是常数级别，因此空间复杂度为 $O(1)$。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 283 题：移动零（循环不变量）</title>
      <link href="/leetcode-algo/2020/03/30/leetcode-solution/0075-sort-colors/"/>
      <url>/leetcode-algo/2020/03/30/leetcode-solution/0075-sort-colors/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-283-题：移动零"><a href="#「力扣」第-283-题：移动零" class="headerlink" title="「力扣」第 283 题：移动零"></a>「力扣」第 283 题：移动零</h2><ul><li>中文网址：<a href="https://leetcode-cn.com/problems/move-zeroes/description/" target="_blank" rel="noopener">283. 移动零</a> ；</li><li>英文网址：<a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">283. Move Zeroes</a> </li><li>我的题解链接：<a href="https://leetcode-cn.com/problems/move-zeroes/solution/zun-shou-xun-huan-bu-bian-shi-java-by-liweiwei1419/" target="_blank" rel="noopener">遵守循环不变式（Java）</a>。</li></ul><blockquote><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><pre><code>输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol></blockquote><p>思路：循环过程中，保持 <code>[0, j)</code> 这个区间中的元素非零，遍历一次就能够达到题目的要求。</p><p>时间复杂度：$O(n)$；空间复杂度：$O(1)$。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span>    <span class="token comment" spellcheck="true"># 快速排序的方法，最简单，最直接</span>    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: void Do not return anything, modify nums in-place instead.        """</span>        <span class="token comment" spellcheck="true"># 循环不变量保持 [0, j） 保持都非 0，</span>        <span class="token comment" spellcheck="true"># [j, len-1] 为 0</span>        <span class="token comment" spellcheck="true"># j 表示下一个非零元素的位置</span>        j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 遇到 0 放过，不是 0 的交换到前面去</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span>    s<span class="token punctuation">.</span>moveZeroes<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> partition </tag>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」的「圈子」回答：刷题刷到绝望该怎么办？</title>
      <link href="/leetcode-algo/2020/03/01/algorithms-and-data-structures/introduction/"/>
      <url>/leetcode-algo/2020/03/01/algorithms-and-data-structures/introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」的「圈子」回答：刷题刷到绝望该怎么办？"><a href="#「力扣」的「圈子」回答：刷题刷到绝望该怎么办？" class="headerlink" title="「力扣」的「圈子」回答：刷题刷到绝望该怎么办？"></a>「力扣」的「圈子」回答：刷题刷到绝望该怎么办？</h2><ul><li><a href="https://leetcode-cn.com/circle/discuss/xFI0Il/" target="_blank" rel="noopener">原始链接</a></li></ul><p>不是大佬。我个人觉得刷题和智商没有太大的关系，刷题这件事情本身也是需要「方法」的。</p><p>我们针对算法面试准备的算法题，不是智力题，我们觉得刷题有困难，有很大一部分是心理上的因素。其实这一类算法问题非常像我们初高中的数学问题，知识点很多，都有相对固定的思考方向和常考的知识点，答案和思路也是相对固定的。</p><p>刷题这件事情我觉得<strong>一开始以培养兴趣</strong>为主，<strong>从易到难做，同类问题一起做（按标签）做</strong>，是我看到的绝大多数朋友刷题的方式。</p><p>「力扣」的<a href="https://leetcode-cn.com/explore/" target="_blank" rel="noopener">「探索」</a>模块就是适合入门的地方。你可以从「数组」「二分查找」「字符串」「链表」这些模块开始做起，这些模块需要的基础知识较少，并且「探索」板块本身就是一个小的教程。通过知识讲解和练习是可以掌握这一类问题的通用的做法的。</p><ul><li>刷题建议</li></ul><p>做题的时候<strong>需要先仔细读题</strong>，把题目中的文字描述细节和示例看一下，然后再<strong>看看输入数据的范围</strong>，确保自己明确了题意以后想思路，然后再编码。</p><p>编码遇到问题，测试通不过是非常正常的事情。这个时候首先思考是不是本身思路上就存在问题，可以根据不能通过的测试用例，检查自己的思路在哪一方面没有考虑周到。如果是思路正确，那就是在编码实现的时候遇到的问题，这其实是比较考验耐心的。调试程序本身就是一种需要训练的能力，一个简单而有效的方法就是在程序的关键的地方，做一些 <code>System.out.println(i);</code> 之类的打印输出，观察数据是否按照我们所设定的流程执行下去。这件事情看起来枯燥，但是是作为程序员的基本技能，只能靠自己训练获得。</p><p>如果一道问题自己没有思路，完全可以直接看别人的思路。如果别人的思路看不懂，没有关系，看不懂就跳过。看不懂在一些情况下不是问题，不同的朋友表达的方式和语言不一样。写题解和博客的朋友不可能都从头开始写，每个人写题解的侧重点也不同，会假设读者有的算法和数据结构的知识也会不同。</p><p>看完别人的思路，觉得合理可行，再自己尝试编码。遇到问题再去比对别人给的示例代码。</p><p>即使是自己独立做完的问题，也很有必要在做完以后看看别人的思路，这一步也会让自己学习到很多。</p><ul><li>用好收藏夹</li></ul><p>实在不懂又很想搞清楚的问题，不妨就放在收藏夹里，「力扣」本来就有提供收藏夹功能。也可以给自己刷题的 GitHub 仓库提交一个 issue ，把这道题和自己找到相关的参考资料写进去，提醒自己以后花时间去搞清楚。今天怎么想都不明白，过两天一下子就想通的事情也是常有的。因为有些时候学习和思考问题，个人的情绪和状态也是有关系的。</p><p>还有一些比较难的问题，一开始先别去碰，可以先看看题目的意思，不感兴趣就不做，感兴趣的话，不强求自己一定要做出来，就放在那里慢慢花时间搞懂，也是常有的事情，一道题可能重启 4 遍到 5 遍才搞懂是非常正常的，而且这样的问题如果最后自己真的搞定了以后是很有满足感的，力扣的第 4 题、第 5 题、第 47 题、第 41 题、第 300 题，第 42 题、第 84 题差不多就是类似的问题，即使是刷了很多遍以后，我都不敢说我完全搞懂了这些问题，就让它们在收藏夹里先吃灰叭。</p><ul><li>尝试表达输出，尽量用简单、通俗的语言描述自己的思路</li></ul><p>在刷题的过程中，需要自己总结这一类问题的特点，然后用自己的语言表达，写博客、题解或者是和一起刷题的小伙伴讨论。这些虽然不是写代码，但也属于刷题的一部分，可以积累下来形成刷题的「数据」，以后不论是找工作还是自己复习都是十分有帮助的，我和很多小伙伴都是这么做的。</p><ul><li>养成好的编码习惯</li></ul><p>刷题不是只有“数量”这个指标，即使是同样的思路，不同的人写出来的代码也会有很大差异。怎么写代码也是需要自己总结和训练的。代码格式良好，有恰当的、必要的注释，让别人能够很清楚地了解自己的思路，也是需要慢慢锻炼的。虽然刷题是个人行为，但是在写代码的时候按照写工程代码的标准来要求自己，我个人觉得是非常有益处的，我自己也是坚持这么做的，可以让自己避免很多坑和不必要的麻烦。</p><ul><li>不只是为了面试而刷题</li></ul><p>刷题这件事情对于绝大多数朋友，也包括我，目标主要是在面试中得到一个好的成绩，找到一份好的工作。但刷题的过程是很值得经历的，从焦虑到欣喜，再到焦虑和自我怀疑，然后又莫名其妙自我感动，都是很正常的。</p><p>把「力扣」的算法题就想象成解决一个一个日常生活中遇到的问题，我们写的「算法」就是解决这些问题的方法，而「数据结构」是存储和处理数据的容器，是我们可以利用的工具，很多是现成的编程语言的函数库就提供给我们使用的。</p><ul><li>不要把刷题想得很难，很多时候只是心态的问题</li></ul><p>刷题比起很多工作，例如机器学习里的公式推导、打一些数据挖掘竞赛、很多研究生朋友写科研论文，是要简单得多，甚至比起大家考研的时候学习的高等数学、线性代数、概率论与数理统计都要简单很多，要相信自己一定可以慢慢拿下的。</p><p>不要有太大压力，一道题做得出来做不出来，都不能说明太大问题，做对了有可能是侥幸，做错了也有可能是一时头脑短路或者是题目不对味口。</p><p>我有一位非常好的朋友，他是科班出身，听他说他以前刷题的时候，没有思路得去找学长讨论，LeetCode 当时还没有中文社区，看思路和题解、和别人交流得用英文。现在其实我们方便很多了。</p><p>刷基础算法问题和智商绝大多数情况下没有关系（刷 ACM 等竞赛题库除外），我个人觉得是和「态度」有关。可以想一想自己是不是认真地在刷题，参考资料和视频讲解手上都有，还搞不清楚，是不是自己花的时间不够，或者说没有找认真找合适的资料，或者就是自己想偷懒。</p><p>适合自己的刷题方式也是需要慢慢摸索的，一开始需要一些帮助和基础知识储备是必要的。后期就是查缺补漏，重点训练了。一开始不要过于执着一个问题，一个问题没有搞清楚，就放一放，问题很多，不可能全部做完，也不可能全部搞懂。自己需要合理分配时间和精力。</p><p>即使是「回溯算法」「动态规划」「贪心算法」「哈希表」「红黑树」这样高级的数据结构和算法，它们确实很复杂、很难，但是它们的基本思想是很简单的，或者说它们就是从一个很简单的样子一点一点变化，变成我们现在看到的这个样子，绝大多数算法思想都可以在我们的生活中找到对应的例子去理解它。</p><p>「力扣」的周赛其实也是很适合新手的，我现在想做的时候，也都会去做一下周赛，然后会和固定的小伙伴交流做题心得，有的时候也就是简单汇报一下自己做出了哪题，哪题实在想不出来，或者吐槽一下一些问题题目太长或者题意难懂实在不想做。有些朋友会误解我可能做那些问题会很轻松，其实不是的，我现在做周赛也就 2 题到 3 题，从来没有 4 题都做完过。头几次周赛一道题都没做出来就是我了。可以把每次周赛就当做是一次模拟的笔试、有很多小伙伴陪我们一起做，找找感觉，我想说的是，而且一定会有真·大佬出来，在「力扣」的「圈子」板块和题解区、评论区分享它们的做题思路和代码，在一些视频网站也可以看到他们的比赛实况和赛后讲解，讲得都非常不错，我们可以趁机向他们学习。</p><p>个人观点，仅供参考。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习心得 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 33、81、153、154 题：旋转排序数组</title>
      <link href="/leetcode-algo/2018/05/20/leetcode-solution/rotated-sorted-array/"/>
      <url>/leetcode-algo/2018/05/20/leetcode-solution/rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-33、81、153、154-题：旋转排序数组"><a href="#「力扣」第-33、81、153、154-题：旋转排序数组" class="headerlink" title="「力扣」第 33、81、153、154 题：旋转排序数组"></a>「力扣」第 33、81、153、154 题：旋转排序数组</h2><h3 id="「力扣」第-33-题：搜索旋转排序数组"><a href="#「力扣」第-33-题：搜索旋转排序数组" class="headerlink" title="「力扣」第 33 题：搜索旋转排序数组"></a>「力扣」第 33 题：搜索旋转排序数组</h3><p>传送门：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">搜索旋转排序数组</a>。难度：中等。</p><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1</code></pre></blockquote><p>思路：二分查找，<strong>特别要注意边界条件的判断。</strong></p><p>1、注意一个细节：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在只有两个数的区间 $[4,5]$ 找中点的时候，就只会得到 $4$ ，所以要<strong>将</strong> <strong>nums[mid]</strong> <strong>和</strong> <strong>nums[right]</strong> <strong>进行判断</strong>。并且 <code>while</code> 里面是 <code>left &lt;= right</code> 必须要能够取等号。这时可以使用</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>让中点靠近右边。</p><p>2、这道题应用了旋转数组的一个性质，那就是：<strong>分割以后，有且只有其中的一部分是顺序数组，另一个数组是仍是旋转数组</strong>；</p><p>3、一个重要的条件：<strong>你可以假设数组中不存在重复的元素</strong>。你的算法时间复杂度必须是 $O(\log n)$ 级别。</p><p>总结：1、旋转数组任意分割以后，一定有一边是顺序数组，另一边是还是旋转数组</p><p>2、特别要注意分类讨论的情况；</p><p>3、这道题比较适合使用循环来做，递归的话容易写错。</p><p>4、特别注意临界情况，体会 <code>mid = left + (right - left) / 2;</code> 与 <code>int mid = left + (right - left + 1) / 2;</code> 这两者的区别。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                <span class="token keyword">return</span> mid            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># nums[mid + 1:r] 包括左右区间端点有序</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># nums[l:mid - 1] 包括左右区间端点有序</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">:</span>                    r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 从 mid 到 right 都是顺序数组</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 其余的情况就在右边了</span>                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 此时 left 到 mid 是顺序数组</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用“逼近”方式的二分法。</p><p>Python 代码：注意：左右区间“收缩”的方式要一致</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># [7,8,9,1,2,3,4,5,6] ，后半部分有序</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l <span class="token operator">=</span> mid                <span class="token keyword">else</span><span class="token punctuation">:</span>                    r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># [4,5,6,7,8,9,0,1,2]，前半部分有序</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    l <span class="token operator">=</span> mid        <span class="token keyword">return</span> l <span class="token keyword">if</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="「力扣」第-81-题：搜索旋转排序数组-II"><a href="#「力扣」第-81-题：搜索旋转排序数组-II" class="headerlink" title="「力扣」第 81 题：搜索旋转排序数组 II"></a>「力扣」第 81 题：搜索旋转排序数组 <strong>II</strong></h3><p>传送门：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a>。</p><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,0,1,2,2,5,6]</code> 可能变为 <code>[2,5,6,0,0,1,2]</code> )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [2,5,6,0,0,1,2], target = 0输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [2,5,6,0,0,1,2], target = 3输出: false</code></pre><p><strong>进阶:</strong></p><ul><li>这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">搜索旋转排序数组</a> 的延伸题目，本题中的 <code>nums</code>  可能包含重复元素。</li><li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li></ul></blockquote><p>思路：这道题在第 33 题的基础上，加上了可能有重复元素的条件。重点在于：<code>nums[mid] == nums[right]</code> 的判断，因为“可能有重复元素”此时不能断定哪一边一定是旋转数组，哪一边一定是顺序数组，因此，只能够去掉 <code>right</code>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// mid 到 right 是顺序数组</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// nums[mid] > nums[right]</span>                <span class="token comment" spellcheck="true">// left 到 mid 是顺序数组</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 后面是有序的</span>                <span class="token comment" spellcheck="true"># [2,3,4,5,5,6,6,7]</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    l <span class="token operator">=</span> mid                <span class="token keyword">else</span><span class="token punctuation">:</span>                    r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># [3,4,5,5,6,6,7,2]</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    l <span class="token operator">=</span> mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">assert</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>                <span class="token comment" spellcheck="true"># 右边不是才删除</span>                r <span class="token operator">=</span> r <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="「力扣」第-153-题：寻找旋转排序数组中的最小值"><a href="#「力扣」第-153-题：寻找旋转排序数组中的最小值" class="headerlink" title="「力扣」第 153 题：寻找旋转排序数组中的最小值"></a>「力扣」第 153 题：<strong>寻找旋转排序数组中的最小值</strong></h3><p>传送门：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a>。</p><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p><strong>示例 1:</strong></p><pre><code>输入: [3,4,5,1,2]输出: 1</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [4,5,6,7,0,1,2]输出: 0</code></pre></blockquote><p>分析：这个问题中给出的数组没有重复元素。还是利用旋转数组的那个性质，另外不要把问题想得过于复杂。</p><p>下面这个模板是要记住的。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fyzw9rpagaj31180n0dmu.jpg" alt="image-20190109054313705"></p><p>如何理解这个二分法：</p><p>1、<code>nums[mid] &gt; nums[right]</code>：例子：<code>[7,8,9,10,1,2]</code>，<code>mid</code> 肯定不是最小。<br>2、否则，<code>nums[mid] &lt; nums[right]</code>：例子：<code>[8,9,1,2,3,4,5,6]</code>，此时 <code>mid</code> 有可能是最小。</p><p>3、还可以使用分治的思想解决这个问题。</p><p>Python 代码：二分法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'程序出错'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                  <span class="token comment" spellcheck="true"># [3,4,5,6,7,8,1,2]</span>                <span class="token comment" spellcheck="true"># 此时 mid 肯定不是最小元素</span>                  l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">assert</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># [7,8,1,2,3,4,5,6]</span>                <span class="token comment" spellcheck="true"># mid 有可能是最小元素，所以，不能排除它</span>                r <span class="token operator">=</span> mid        <span class="token comment" spellcheck="true"># 一定存在最小元素，因此无须再做判断</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码2：分治法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'程序出错'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__findMin<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> right<span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        <span class="token keyword">if</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> right<span class="token punctuation">:</span>            <span class="token keyword">return</span> min<span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span>        mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">return</span> min<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__findMin<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>__findMin<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="「力扣」第-154-题：找旋转排序数组中的最小值-II"><a href="#「力扣」第-154-题：找旋转排序数组中的最小值-II" class="headerlink" title="「力扣」第 154 题：找旋转排序数组中的最小值 II"></a>「力扣」第 154 题：找旋转排序数组中的最小值 II</h3><p>传送门： <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/description/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a>。</p><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p><strong>示例 1：</strong></p><pre><code>输入: [1,3,5]输出: 1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: [2,2,2,0,1]输出: 0</code></pre><p><strong>说明：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul></blockquote><p>分析：注意数组中可能存在重复的元素。</p><p>注意点1：<code>left &lt; right</code>这是模板二分法的写法。</p><p>注意点2：<code>nums[mid] &lt; nums[right]</code> 进行比较。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMin</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> Exception<span class="token punctuation">(</span><span class="token string">'程序出错'</span><span class="token punctuation">)</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># mid 有可能是最小值</span>                <span class="token comment" spellcheck="true"># [7,8,1,2,3]</span>                r <span class="token operator">=</span> mid            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># mid 肯定不是最小值</span>                <span class="token comment" spellcheck="true"># [7,8,9,10,11,1,2,3]</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 都有可能，所以就把 r 排除了</span>                <span class="token comment" spellcheck="true"># [1,1,1,1,1,0,1]</span>                <span class="token keyword">assert</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                r <span class="token operator">=</span> r <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> first <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> last <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">&lt;</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 例如：[7,8,9,10,11,12,1,2]，最小的一定不在前面，也一定不是 mid</span>                <span class="token comment" spellcheck="true">// 所以可以放心地 + 1</span>                first <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// [1,1,1,1,0,1] 和 [1,0,1,1,1,1] 这两种情况，只能把 last 给排除掉</span>                <span class="token comment" spellcheck="true">// 因为 nums[mid] == nums[last] 相等，最小元素不会丢掉</span>                last <span class="token operator">=</span> last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 当 nums[mid] &lt; nums[last] 的时候</span>                <span class="token comment" spellcheck="true">// mid 有可能是最小解，不能写成 last = mid - 1</span>                last <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这里 return nums[last] 也是可以的，因为跳出那层 while 的时候有，first = last </span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，还可以使用分治的思想。</p><p>如果使用分治法，代码和第 153 题是一模一样的。</p><p>同《剑指 Offer》第 11 题：旋转数组中的最小数字。</p><p>传送门：<a href="https://www.acwing.com/problem/content/20/" target="_blank" rel="noopener">AcWing 22. 旋转数组的最小数字 </a>。</p><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>输入一个升序的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p><p>数组可能包含重复项。</p><p><strong>注意</strong>：数组内所含元素非负，若数组大小为0，请返回-1。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre><code>输入：nums=[2,2,2,0,1]输出：0</code></pre></blockquote><p>分析：使用二分查找算法解决，要注意一些细节，从后向前。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fyy2jdlwtrj30tw11ynpd.jpg" alt="image-20190107154850626"></p><h3 id="LeetCode-第-189-题：生成旋转数组"><a href="#LeetCode-第-189-题：生成旋转数组" class="headerlink" title="LeetCode 第 189 题：生成旋转数组"></a>LeetCode 第 189 题：生成旋转数组</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/rotate-array/description/" target="_blank" rel="noopener">189. Rotate Array</a> ，中文网址：<a href="https://leetcode-cn.com/problems/rotate-array/description/" target="_blank" rel="noopener">189. 旋转数组</a> 。</p><blockquote><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例 1:</strong></p><pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</code></pre><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的原地算法。</li></ul></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: void Do not return anything, modify nums in-place instead.        """</span>        <span class="token comment" spellcheck="true"># 先处理极端情况</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        k <span class="token operator">=</span> k <span class="token operator">%</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 做下面 3 个逆转动作的时候，注意边界条件</span>        <span class="token comment" spellcheck="true"># 技巧就是举具体的例子</span>        self<span class="token punctuation">.</span>__reverse<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>__reverse<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>__reverse<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__reverse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> index1<span class="token punctuation">,</span> index2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        将数组 [index1,index2] 区间内的元素进行逆转        :param nums:        :param index1:        :param index2:        :return:        """</span>        <span class="token keyword">while</span> index1 <span class="token operator">&lt;</span> index2<span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span>            index1 <span class="token operator">+=</span> <span class="token number">1</span>            index2 <span class="token operator">-=</span> <span class="token number">1</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>    k <span class="token operator">=</span> <span class="token number">3</span>    s <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 287 题：数组中的重复数字</title>
      <link href="/leetcode-algo/2018/05/14/leetcode-solution/find-the-duplicate-number/"/>
      <url>/leetcode-algo/2018/05/14/leetcode-solution/find-the-duplicate-number/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-287-题：数组中的重复数字"><a href="#「力扣」第-287-题：数组中的重复数字" class="headerlink" title="「力扣」第 287 题：数组中的重复数字"></a>「力扣」第 287 题：数组中的重复数字</h2><p>关键字：抽屉原理，二分法。</p><p>传送门：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number" target="_blank" rel="noopener">寻找重复数</a>。</p><blockquote><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>示例 1:</p><p>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:</p><p>输入: [3,1,3,4,2]<br>输出: 3<br>说明：</p><p>1、不能更改原数组（假设数组是只读的）。<br>2、只能使用额外的 $O(1)$ 的空间。<br>3、时间复杂度小于 $O(n^2)$ 。<br>4、数组中只有一个重复的数字，但它可能不止重复出现一次。</p></blockquote><p>解题思路：二分法。对“数”做二分，要定位的“数”根据题意在 $1$ 和 $n$ 之间，每一次二分都可以将搜索区间缩小一半。</p><p>以 <code>[1, 2, 2, 3, 4, 5, 6, 7]</code> 为例，一共有 $8$ 个数，每个数都在  $1$ 和 $7$ 之间。$1$ 和 $7$ 的中位数是 $4$，<strong>遍历整个数组</strong>，统计小于 $4$ 的整数的个数，至多应该为 $3$ 个，如果超过 $3$ 个就说明重复的数存在于区间 $[1,4)$ （注意：左闭右开）中；否则，重复的数存在于区间 $[4,7]$（注意：左右都是闭）中。这里小于 $4$ 的整数有 $4$ 个（它们是 1, 2, 2, 3），因此砍掉右半区间，连中位数也砍掉。以此类推，最后区间越来越小，直到变成 $1$ 个整数，这个整数就是我们要找的重复的数。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token number">1</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 取中点有两种方式，偏左和偏右</span>            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token operator">&lt;</span> mid<span class="token punctuation">:</span>                    count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> count <span class="token operator">&lt;</span> mid<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 因为左边不变，所以取中点的时候，就要偏右</span>                left <span class="token operator">=</span> mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 比 4 小的个数，达到 4 或者更多</span>                <span class="token comment" spellcheck="true"># 重复的就落在 [1, 2, 3]</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 跳出循环肯定是因为 start = end</span>        <span class="token keyword">return</span> left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：1、在 Python 中，整除使用 <code>//</code> ，如果使用 <code>/</code> ，在不能整除的时候，会返回一个小数；</p><p>2、之所以写成 <code>mid = left + (right - left + 1) // 2</code> ，是因为下面的分支条件是：<code>left = mid</code> 和 <code>right = mid - 1</code>，如果写成 <code>mid = left + (right - left) // 2</code> 就会陷入死循环。我们还是以具体例子为例。</p><p>当一个整数数组（按升序排列）的个数为奇数时，不论 <code>mid = left + (right - left) // 2</code> 和  <code>mid = left + (right - left + 1) // 2</code>  都落在了相同的一个数，大家不妨拿 <code>[1,2,3,4,5]</code> 做验证；</p><p>当一个整数数组（按升序排列）的个数为偶数时：</p><p>（1） <code>mid = left + (right - left) // 2</code>  找到的是中间位置偏左的元素；</p><p>（2） <code>mid = left + (right - left + 1) // 2</code>  找到的是中间位置偏右的元素。</p><p>可以拿 [1,2,3,4] 验证。</p><p>因此如果分支是：<code>left = mid</code> 和 <code>right = mid - 1</code>，说明，当只有 2 个元素的时候，中位数不能取左边，否则会出现死循环，因此中位数的取法是 <code>mid = left + (right - left + 1) // 2</code>。</p><p>如果分支是：<code>left = mid + 1</code> 和 <code>right = mid</code>，说明，当只有 2 个元素的时候，中位数不能取右边，否则会出现死循环，因此中位数的取法是 <code>mid = left + (right - left) // 2</code>。</p><p>3、<code>while left &lt; right</code> 一定是严格小于，这样退出循环的时候就一定有 <code>l==r</code> 成立，就不必纠结该返回 <code>l</code> 还是 <code>r</code> 了。</p><p>总结一下：<code>while left &lt; right</code> 一定是严格小于，最后把一个区间“夹逼”成一个数，二分法先写两个分支，再根据分支的情况，调整如何取中点。</p><hr><p>分析：</p><p>Python 代码1：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        left <span class="token operator">=</span> <span class="token number">1</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 特别注意：在二分法取中点的算法中，如果有一条分支，不能排除 mid</span>        <span class="token comment" spellcheck="true"># 在写 while 循环的时候，就不能把 = 写进去，否则会出现死循环，</span>        <span class="token comment" spellcheck="true"># 这一点要特别注意</span>        <span class="token comment" spellcheck="true"># 注意，千万不能写 while left &lt;= right，会进入死循环</span>        <span class="token comment" spellcheck="true"># 因为下面有一个分支是 right = mid</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 因为在循环过程中，右边界可能不变，就要使用左偏中点</span>            <span class="token comment" spellcheck="true"># [1,2] 时，</span>            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token operator">&lt;=</span> mid<span class="token punctuation">:</span>                    count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> count <span class="token operator">&lt;=</span> mid<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 在 [left,mid] 这个区间没有重复元素</span>                <span class="token comment" spellcheck="true"># 所以搜索范围在 [mid+1,right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 在 [left,mid] 这个区间有重复元素</span>                <span class="token comment" spellcheck="true"># 所以搜索范围在 [left,mid]</span>                right <span class="token operator">=</span> mid        <span class="token comment" spellcheck="true"># 退出循环的时候 start == end 为 True</span>        <span class="token keyword">return</span> left<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>findDuplicate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码2：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 287. 寻找重复数</span><span class="token comment" spellcheck="true"># 给定一个包含 n + 1 个整数的数组 nums，</span><span class="token comment" spellcheck="true"># 其数字都在 1 到 n 之间（包括 1 和 n），</span><span class="token comment" spellcheck="true"># 可知至少存在一个重复的整数。</span><span class="token comment" spellcheck="true"># 假设只有一个重复的整数，找出这个重复的数。</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        【不修改数组找出重复的数字】        给定一个包含 n + 1 个整数的数组 nums，        其数字都在 1 到 n 之间（包括 1 和 n），        可知至少存在一个重复的整数。        假设只有一个重复的整数，找出这个重复的数。        :type nums: List[int]        :rtype: int        """</span>        left <span class="token operator">=</span> <span class="token number">1</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 特别注意：在二分法取中点的算法中，如果有一条分支，不能排除 mid</span>        <span class="token comment" spellcheck="true"># 在写 while 循环的时候，就不能把 = 写进去，否则会出现死循环，</span>        <span class="token comment" spellcheck="true"># 这一点要特别注意</span>        <span class="token comment" spellcheck="true"># 注意，千万不能写 while left &lt;= right，会进入死循环</span>        <span class="token comment" spellcheck="true"># 因为下面有一个分支是 left = mid</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 取中点有两种方式，偏左和偏右</span>            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true"># 4</span>            count <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token operator">&lt;</span> mid<span class="token punctuation">:</span>                    count <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> count <span class="token operator">&lt;</span> mid<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 比 4 小的个数，最多就只能是 3</span>                <span class="token comment" spellcheck="true"># 所以重复的肯定不是 [1,2,3]</span>                <span class="token comment" spellcheck="true"># 因为左边不变，所以取中点的时候，就要偏右</span>                left <span class="token operator">=</span> mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 比 4 小的个数，达到 4 或者更多</span>                <span class="token comment" spellcheck="true"># 重复的就落在 [1,2,3]</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 跳出循环肯定是因为 start = end</span>        <span class="token keyword">return</span> left<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>findDuplicate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解法3：使用 LeetCode 第 141 题和第 142 题的做法。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 参考了：https://blog.csdn.net/wr339988/article/details/53617914</span>        <span class="token comment" spellcheck="true"># 参考资料：http://www.cnblogs.com/grandyang/p/4843654.html</span>        <span class="token comment" spellcheck="true"># 看下来，其实就是 LeetCode 141 和 142</span>        <span class="token comment" spellcheck="true"># 会了这两题，其实这道题的这个解法就迎刃而解了</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        fast <span class="token operator">=</span> <span class="token number">0</span>        slow <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            fast <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>fast<span class="token punctuation">]</span><span class="token punctuation">]</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>            <span class="token keyword">if</span> fast <span class="token operator">==</span> slow<span class="token punctuation">:</span>                <span class="token keyword">break</span>        point <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> point <span class="token operator">!=</span> slow<span class="token punctuation">:</span>            point <span class="token operator">=</span> nums<span class="token punctuation">[</span>point<span class="token punctuation">]</span>            slow <span class="token operator">=</span> nums<span class="token punctuation">[</span>slow<span class="token punctuation">]</span>        <span class="token keyword">return</span> point<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="LeetCode-第-287-题：寻找重复数"><a href="#LeetCode-第-287-题：寻找重复数" class="headerlink" title="LeetCode 第 287 题：寻找重复数"></a>LeetCode 第 287 题：寻找重复数</h1><table><thead><tr><th>题目地址</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode 第 287 题：寻找重复数</a></td><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/" target="_blank" rel="noopener">桶排序 + 二分法（Python 代码、Java 代码）</a></td></tr></tbody></table><ul><li>提示：点击上面的题解链接，可以看到我制作的幻灯片轮播图。</li></ul><h3 id="方法一：桶排序"><a href="#方法一：桶排序" class="headerlink" title="方法一：桶排序"></a>方法一：桶排序</h3><p>桶排序的思想是“一个萝卜一个坑”。对于这道题而言，遇到两个萝卜一个坑的，返回那个“萝卜”就好了。以数组 <code>[1, 3, 4, 2, 2]</code> 为例。</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/287-1.png" alt="LeetCode 第 287 题-1"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/287-2.png" alt="LeetCode 第 287 题-2"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/287-3.png" alt="LeetCode 第 287 题-3"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/287-4.png" alt="LeetCode 第 287 题-4"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/287-5.png" alt="LeetCode 第 287 题-5"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/287-6.png" alt="LeetCode 第 287 题-6"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/287-7.png" alt="LeetCode 第 287 题-7"></p><p>这里数与要放置的位置的索引有一个偏差，编码的时候要注意这一点。再整理一下思路：<strong>如果数字 <code>i</code> 没有放在索引 <code>i - 1</code> 上，就要执行交换，把数字 <code>i</code> 放在索引 <code>i - 1</code> 上，如果索引  <code>i - 1</code> 上的那个元素恰好和自己相等，就没有必要交换，说明出现重复了，即找到了这个重复的元素，返回即可</strong>。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def findDuplicate(self, nums: List[int]) -> int:        # 桶排序，数字 i 应该在索引 i - 1 上，否则交换        size = len(nums)        for i in range(size):            while nums[i] != i + 1:                if nums[i] == nums[nums[i] - 1]:                    return nums[i]                self.__swap(nums, i, nums[i] - 1)    def __swap(self, nums, index1, index2):        if index1 == index2:            return        nums[index1], nums[index2] = nums[index2], nums[index1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public int findDuplicate(int[] nums) {        int len = nums.length;        for (int i = 0; i < len; i++) {            while (nums[i] != i + 1) {                if (nums[i] == nums[nums[i] - 1]) {                    return nums[i];                }                swap(nums, i, nums[i] - 1);            }        }        // 数组中没有重复的整数，测试用例错误        return 0;    }    private void swap(int[] nums, int index1, int index2) {        if (index1 == index2) {            return;        }        int temp = nums[index1];        nums[index1] = nums[index2];        nums[index2] = temp;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里解释一下编码细节，可能有些朋友会比较晕。</p><p>1、<code>nums[i] != i + 1</code>：想一想正确放置的情况，<code>nums[0] = 1</code>、<code>nums[1] = 2</code>，依次类推，这一步是在判断，在遍历的时候，当前索引上的放置的元素的值是不是正确的“萝卜”；</p><p>2、<code>if nums[i] == nums[nums[i] - 1]:</code>：如果不是正确的“萝卜”，就得根据当前索引上的数值，看一看这个数字应该放在哪个位置上。例如数字 4 应该放在索引 3 上，那么就要检查数字 4（这里是 <code>nums[i]</code>），与索引 3 （这里是 <code>nums[i] - 1</code>）上的数值，即 <code>nums[nums[i] - 1]</code> 是否相等，如果相等，返回这个重复数，如果不相等，交换。</p><p>3、交换我单独写了一个方法，否则中括号会把自己绕晕。</p><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N^2)$，这里需遍历一次整个数组，在遍历的时候还有一个 <code>for</code> 循环，因此时间复杂度为 $O(N^2)$。</li><li>空间复杂度：$O(1)$，这里无需使用额外的辅助空间，因此空间复杂度为 $O(1)$。</li></ul><h3 id="方法二：二分法"><a href="#方法二：二分法" class="headerlink" title="方法二：二分法"></a>方法二：二分法</h3><p>对“数”做二分，要定位的“数”根据题意在 $1$ 和 $n$ 之间，每一次二分都可以将搜索区间缩小一半。</p><p>以 <code>[1, 2, 2, 3, 4, 5, 6, 7]</code> 为例，一共有 $8$ 个数，每个数都在  $1$ 和 $7$ 之间。$1$ 和 $7$ 的中位数是 $4$，<strong>遍历整个数组</strong>，统计小于 $4$ 的整数的个数，至多应该为 $3$ 个，如果超过 $3$ 个就说明重复的数存在于区间 $[1,4)$ （注意：左闭右开）中；否则，重复的数存在于区间 $[4,7]$（注意：左右都是闭）中。这里小于 $4$ 的整数有 $4$ 个（它们是 1, 2, 2, 3），因此砍掉右半区间，连中位数也砍掉。以此类推，最后区间越来越小，直到变成 $1$ 个整数，这个整数就是我们要找的重复的数。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def findDuplicate(self, nums):        """        :type nums: List[int]        :rtype: int        """        left = 1        right = len(nums) - 1        # 特别注意：在二分法取中点的算法中，如果有一条分支，不能排除 mid        # 在写 while 循环的时候，就不能把 = 写进去，否则会出现死循环，        # 这一点要特别注意        # 注意，千万不能写 while left <= right，会进入死循环        # 因为下面有一个分支是 right = mid        while left < right:            # 因为在循环过程中，右边界可能不变，就要使用左偏中点            # [1,2] 时，            mid = left + (right - left) // 2            count = 0            for num in nums:                if num <= mid:                    count += 1            if count <= mid:                # 在 [left,mid] 这个区间没有重复元素                # 所以搜索范围在 [mid+1,right]                left = mid + 1            else:                # 在 [left,mid] 这个区间有重复元素                # 所以搜索范围在 [left,mid]                right = mid        # 退出循环的时候 start == end 为 True        return left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public int findDuplicate(int[] nums) {        int len = nums.length;        int l = 1;        int r = len - 1;        while (l < r) {            int mid = l + (r - l) / 2;            int counter = 0;            for (int num : nums) {                if (num <= mid) {                    counter += 1;                }            }            if (counter > mid) {                r = mid;            } else {                l = mid + 1;            }        }        return l;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：1、在 Python 中，整除使用 <code>//</code> ，如果使用 <code>/</code> ，在不能整除的时候，会返回一个小数；</p><p>2、之所以写成 <code>mid = left + (right - left + 1) // 2</code> ，是因为下面的分支条件是：<code>left = mid</code> 和 <code>right = mid - 1</code>，如果写成 <code>mid = left + (right - left) // 2</code> 就会陷入死循环。我们还是以具体例子为例。</p><p>当一个整数数组（按升序排列）的个数为奇数时，不论 <code>mid = left + (right - left) // 2</code> 和  <code>mid = left + (right - left + 1) // 2</code>  都落在了相同的一个数，大家不妨拿 <code>[1,2,3,4,5]</code> 做验证；</p><p>当一个整数数组（按升序排列）的个数为偶数时：</p><p>（1） <code>mid = left + (right - left) // 2</code>  找到的是中间位置偏左的元素；</p><p>（2） <code>mid = left + (right - left + 1) // 2</code>  找到的是中间位置偏右的元素。</p><p>可以拿 [1,2,3,4] 验证。</p><p>因此如果分支是：<code>left = mid</code> 和 <code>right = mid - 1</code>，说明，当只有 2 个元素的时候，中位数不能取左边，否则会出现死循环，因此中位数的取法是 <code>mid = left + (right - left + 1) // 2</code>。</p><p>如果分支是：<code>left = mid + 1</code> 和 <code>right = mid</code>，说明，当只有 2 个元素的时候，中位数不能取右边，否则会出现死循环，因此中位数的取法是 <code>mid = left + (right - left) // 2</code>。</p><p>3、<code>while left &lt; right</code> 一定是严格小于，这样退出循环的时候就一定有 <code>l==r</code> 成立，就不必纠结该返回 <code>l</code> 还是 <code>r</code> 了。</p><p>总结一下：<code>while left &lt; right</code> 一定是严格小于，最后把一个区间“夹逼”成一个数，二分法先写两个分支，再根据分支的情况，调整如何取中点。</p><p>下面再提供等价的二分法写法，供体会这个二分法模板的好处和使用技巧：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def findDuplicate(self, nums: List[int]) -> int:        size = len(nums)        l = 1        r = size - 1        while l < r:            mid = l + (r - l + 1) // 2            counter = 0            for num in nums:                if num < mid:                    counter += 1            if counter >= mid:                # 如果小于 4 的个数等于 4 或者更多                # 那么重复的数一定位于 1、2、3                r = mid - 1            else:                l = mid        return l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public int findDuplicate(int[] nums) {        int len = nums.length;        int l = 1;        int r = len - 1;        while (l < r) {            int mid = l + (r - l + 1) / 2;            int counter = 0;            for (int num : nums) {                if (num < mid) {                    counter += 1;                }            }            if (counter >= mid) {                // 如果小于 4 的个数等于 4 或者更多                // 那么重复的数一定位于 1、2、3                r = mid - 1;            } else {                l = mid;            }        }        return l;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N \log N)$，二分法的时间复杂度为 $O(\log N)$，在二分法的内部，执行了一次 <code>for</code> 循环，时间复杂度为 $O(N)$，故时间复杂度为 $O(N \log N)$。</li><li>空间复杂度：$O(1)$，使用了一个 <code>count</code> 变量，因此空间复杂度为 $O(1)$。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 74、240 题：二维矩阵的搜索</title>
      <link href="/leetcode-algo/2018/05/06/leetcode-solution/search-a-2d-matrix/"/>
      <url>/leetcode-algo/2018/05/06/leetcode-solution/search-a-2d-matrix/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-74、240-题：二维矩阵的搜索"><a href="#「力扣」第-74、240-题：二维矩阵的搜索" class="headerlink" title="「力扣」第 74、240 题：二维矩阵的搜索"></a>「力扣」第 74、240 题：二维矩阵的搜索</h2><h3 id="LeetCode-第-74-题：二维矩阵的搜索"><a href="#LeetCode-第-74-题：二维矩阵的搜索" class="headerlink" title="LeetCode 第 74  题：二维矩阵的搜索"></a>LeetCode 第 74  题：二维矩阵的搜索</h3><p>传送门：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a>。</p><blockquote><p>编写一个高效的算法来判断 <em>m</em> x <em>n</em> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p><strong>示例 1:</strong></p><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 3输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code>输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 13输出: false</code></pre></blockquote><p>分析：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzd41qoosdj30xa0au4c7.jpg" alt="image-20190120160438674"></p><h2 id="LeetCode-第-240-题：二维矩阵的搜索-II"><a href="#LeetCode-第-240-题：二维矩阵的搜索-II" class="headerlink" title="LeetCode 第 240  题：二维矩阵的搜索 II"></a>LeetCode 第 240  题：二维矩阵的搜索 II</h2><p>传送门：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a>。</p><blockquote><p>编写一个高效的算法来搜索 <em>m</em> x <em>n</em> 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><pre><code>[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]</code></pre><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p></blockquote><p>分析：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzd428qh8xj30xi0iw7v9.jpg" alt="image-20190120160506949"></p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「动态规划」专题 3：理解「无后效性」</title>
      <link href="/leetcode-algo/2018/04/03/leetcode-solution/dynamic-programming-3/"/>
      <url>/leetcode-algo/2018/04/03/leetcode-solution/dynamic-programming-3/</url>
      
        <content type="html"><![CDATA[<h2 id="「动态规划」专题-3：理解「无后效性」"><a href="#「动态规划」专题-3：理解「无后效性」" class="headerlink" title="「动态规划」专题 3：理解「无后效性」"></a>「动态规划」专题 3：理解「无后效性」</h2><p>我们在第 1 节向大家介绍过「无后效性」的两层含义：</p><ul><li><p>在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。</p></li><li><p>某阶段状态一旦确定，就不受之后阶段的决策影响。</p></li></ul><p>下面我们就通过具体的例子向大家进行说明。</p><p>这道问题是经典的「力扣」第 198 题：<a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a>。题目只问最优值，并没有问最优解，因此绝大多数情况下可以考虑使用「动态规划」的方法。</p><p>如果我们直接将问题的问法定义成状态，会发现，当前这个房子「偷」和「不偷」会影响到后面的房子「偷」与「不偷」。</p><p>一般的情况是，只要有约束，就可以增加一个维度消除这种约束带来的影响，还是上一节和大家介绍的方法：把「状态」定义得清楚、准确，「状态转移方程」就容易得到了。</p><h4 id="第-1-步：设计状态"><a href="#第-1-步：设计状态" class="headerlink" title="第 1 步：设计状态"></a>第 1 步：设计状态</h4><p>「状态」这个词可以理解为「记录了求解问题到了哪一个阶段」。</p><p>由于当前这一个房屋是否有两种选择：（1）偷；（2）不偷。</p><p><code>dp[i][0]</code> 表示：考虑区间 <code>[0，i]</code> ，并且下标为 <code>i</code> 的这个房间偷，能够偷窃到的最高金额；<br><code>dp[i][1]</code> 表示：考虑区间 <code>[0，i]</code> ，并且下标为 <code>i</code> 的这个房间不偷，能够偷窃到的最高金额。</p><p>说明：这个定义是<strong>有前缀性质的，即当前的状态值考虑了（或者说综合了）之前的相关的状态值</strong>，第 2 维保存了当前最优值的决策，这种<strong>通过增加维度，消除后效性的操作在「动态规划」问题里是非常常见的</strong>。</p><p>强调：</p><blockquote><p>无后效性的理解：1、后面的决策不会影响到前面的决策； 2、之前的状态怎么来的并不重要。</p></blockquote><p>再联系状态的定义：状态是一个概括的值，这个值是怎么来的，并不记录。因为状态定义更细致，后面的决策才不会影响到前面的决策。</p><h4 id="第-2-步：状态转移方程"><a href="#第-2-步：状态转移方程" class="headerlink" title="第 2 步：状态转移方程"></a>第 2 步：状态转移方程</h4><p>「状态转移方程」可以理解为「不同阶段之间的联系」。</p><p>今天只和昨天的状态相关，依然是分类讨论：</p><ul><li>下标为 <code>i</code> 的房屋不偷：或者是上一间不偷，或者是上一间偷，取二者最大值，即：<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])</code>；</li><li>下标为 <code>i</code> 的房屋偷：只需要从上一间不偷，这一间偷，即：<code>dp[i][1] = dp[i - 1][0] + nums[i]</code>。</li></ul><h4 id="第-3-步：考虑初始化"><a href="#第-3-步：考虑初始化" class="headerlink" title="第 3 步：考虑初始化"></a>第 3 步：考虑初始化</h4><p>从第 2 天开始，每天的状态值只与前一天有关，因此第 1 天就只好老老实实算了。好在不难判断：<code>dp[0][0] = 0</code> 与 <code>dp[0][1] = nums[0]</code>；</p><p>这里有一种<strong>技巧，可以把状态数组多设置一行</strong>，这样可以减少对第 1 天的初始化，这样的代码把第 1 天的情况考虑了进去，但编码的时候要注意状态数组下标的设置， 请见题解最后的「参考代码 3」。</p><h4 id="第-4-步：考虑输出"><a href="#第-4-步：考虑输出" class="headerlink" title="第 4 步：考虑输出"></a>第 4 步：考虑输出</h4><p>由于状态值的定义是前缀性质的，因此最后一天的状态值就考虑了之前所有的天数的情况。下标为 <code>len - 1</code> 这个房屋可以偷，也可以不偷，取二者最大值。</p><p><strong>参考代码 1</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// dp[i][0]：考虑区间 [0, i] ，并且下标为 i 的这个房屋不偷</span>        <span class="token comment" spellcheck="true">// dp[i][1]：考虑区间 [0, i] ，并且下标为 i 的这个房屋偷</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// int[] nums = {1, 2, 3, 1};</span>        <span class="token comment" spellcheck="true">// int[] nums = {2, 7, 9, 3, 1};</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">rob</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，$N$ 是数组的长度；</li><li>空间复杂度：$O(N)$，状态数组的大小为 $2N$。</li></ul><p><strong>参考代码 2</strong>：根据方法一：状态数组多设置一行，以避免对极端用例进行讨论。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意：外层循环从 1 到 =len，相对 dp 数组而言，引用到 nums 数组的时候就要 -1</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，$N$ 是数组的长度；</li><li>空间复杂度：$O(N)$，状态数组的大小为 $2(N + 1)$，记为 $O(N)$。</li></ul><h4 id="第-5-步：考虑是否可以状态压缩"><a href="#第-5-步：考虑是否可以状态压缩" class="headerlink" title="第 5 步：考虑是否可以状态压缩"></a>第 5 步：考虑是否可以状态压缩</h4><p>由于我们只关心最后一个状态值。并且</p><p><code>dp[i]</code> 只参考了 <code>dp[i - 1]</code> 的值，状态可以压缩，可以使用「滚动数组」完成。</p><p>值得说明的是：状态压缩的代码丢失了一定可读性，也会给编码增加一点点难度。</p><p><strong>参考代码 3</strong>：使用「滚动数组」技巧，将空间优化到常数级别</p><p>在编码的时候，需要注意，只要访问到 <code>dp</code> 数组的时候，需要对下标 <code>% 2</code>，等价的写法是 <code>&amp; 1</code>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，$N$ 是数组的长度；</li><li>空间复杂度：$O(1)$，状态数组的大小为 $4$，常数空间。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>「状态」和「状态转移方程」得到以后，这个问题其实就得到了解决，剩下的一些细节的问题在编码的时候只要稍微留意一点就行了。</p><p>到这里「重复子问题」、「最优子结构」、「无后效性」我们就都向大家介绍完了。「动态规划」告诉我们可以「自底向上」去考虑一件事情，并且记录下求解问题的中间过程。</p><p>「动态规划」问题没有套路，我们只有通过不断地联系，去掌握状态设计的一般方法和技巧，体会上面所说的「动态规划」的基本概念和基本特征。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1、「力扣」第 62 题、第 63 题：不同路径。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 15：  动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「动态规划」专题 2：理解「最优子结构」</title>
      <link href="/leetcode-algo/2018/04/02/leetcode-solution/dynamic-programming-2/"/>
      <url>/leetcode-algo/2018/04/02/leetcode-solution/dynamic-programming-2/</url>
      
        <content type="html"><![CDATA[<h2 id="「动态规划」专题-2：理解「最优子结构」"><a href="#「动态规划」专题-2：理解「最优子结构」" class="headerlink" title="「动态规划」专题 2：理解「最优子结构」"></a>「动态规划」专题 2：理解「最优子结构」</h2><p>这一节我们向大家介绍「最优子结构」这个概念，具体来说就是：问题的最优解参考了子问题的最优解。</p><p>这个提法比较学术，我们还是用具体的例子和大家解释。这道题是「力扣」上第 322 号问题：零钱兑换。</p><blockquote><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p></blockquote><p><strong>示例 1:</strong></p><pre><code>输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: coins = [2], amount = 3输出: -1</code></pre><p><strong>说明</strong>:<br>你可以认为每种硬币的数量是无限的。</p><p>思路：</p><ul><li>看题目的问法，只问最优值是多少，没有要我们求最优解，一般情况下就是「动态规划」可以解决的问题。</li><li>最优子结构其实比较明显，我们看示例 1：</li></ul><pre><code>输入: coins = [1, 2, 5], amount = 11</code></pre><p>凑成面值为 <code>11</code> 的最小硬币数可以由以下 $3$ 者的最小值得到：</p><p>1、凑成面值为 <code>10</code> 的最小硬币数（假设已知） + 面值为 <code>1</code> 的这一枚硬币；</p><p>2、凑成面值为 <code>9</code> 的最小硬币数（假设已知） + 面值为 <code>2</code> 的这一枚硬币；</p><p>3、凑成面值为 <code>6</code> 的最小硬币数（假设已知） + 面值为 <code>5</code> 的这一枚硬币；</p><p>即 <code>dp[11] = min (dp[10] + 1, dp[9] + 1, dp[6] + 1)</code>。这就是这个问题的最优子结构，在三种选择中，选出一个最优解。</p><p>这里需要引入一个概念：状态。状态其实我们在「回溯算法」里介绍说。状态在动态规划里其实含义是一样的，依然是表示我们求解一个问题进行到哪个阶段，只不过表现这个变量不想「回溯算法」那么具体，很多时候，它是一个「概括值」。</p><p>我们这里直接把题目的问法设计成「状态」，有些问题不是这样的，我们后面再说。</p><h4 id="第-1-步：定义「状态」"><a href="#第-1-步：定义「状态」" class="headerlink" title="第 1 步：定义「状态」"></a>第 1 步：定义「状态」</h4><p><code>dp[i]</code>：凑齐总价值 <code>i</code> 需要的最少硬币数，状态就是问的问题。</p><h4 id="第-2-步：写出「状态转移方程」"><a href="#第-2-步：写出「状态转移方程」" class="headerlink" title="第 2 步：写出「状态转移方程」"></a>第 2 步：写出「状态转移方程」</h4><p>所谓「状态转移方程」，其实就是「最优子结构」。</p><p>根据对具体例子的分析：</p><pre><code> dp[amount] = min(1 + dp[amount - coin[i]]) for i in [0, len - 1] if coin[i] &lt;= amount</code></pre><p>注意的是：</p><p>1、首先硬币的面值首先要<strong>小于等于</strong>当前要凑出来的面值；</p><p>2、剩余的那个面值应该要能够凑出来，例如：求 <code>dp[11]</code> 需要参考 <code>dp[10]</code> ，如果不能凑出来的话，<code>dp[10]</code> 应该等于一个不可能的值，可以设计为 <code>11 + 1</code>，也可以设计为 <code>-1</code> ，它们的区别只是在具体的代码编写细节上不一样而已。</p><p>再强调一次：新状态的值要参考的值以前计算出来的「有效」状态值。这一点在编码的时候需要特别注意。</p><p>因此，不妨先假设凑不出来，因为比的是小，所以初始化的时候应该设置为一个不可能的数。</p><p><strong>参考代码</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 给 0 占位</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意：因为要比较的是最小值，这个不可能的值就得赋值成为一个最大值</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> coin <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">!=</span> amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li>要求的是恰好填满，所以初始化的时候需要赋值为一个不可能的值：<code>amount + 1</code>。只有在有「正常值」的时候，「状态转移」才可以正常发生。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能有的朋友要问了，斐波拉契数列貌似没有「最优子结构」，事实上的确是这样，严格来说「斐波拉契数列」不是「动态规划」问题，但它却是理解「动态规划」问题的一个例子，主要是通过这个例子理解「动态规划」「自底向上」求解的思想和「重复子问题」的特征。大家先不要去纠结这件事情。</p><p>这节我们向大家介绍了「最优子结构」。希望大家能够体会，我们在设计「状态」的时候，仅仅只是用一个数值表示了求解一个问题的阶段，所以这个数值是一个「概括性」的数值，它不是具体解，但是它可以代表具体解。</p><p>这里要注意：对「状态」的定义一定要非常准确，在这里我的建议是，如果状态定义不是题目问的那个样子，把我们对状态的定义都作为注释写在代码里。</p><p>只有「状态」定义准确，「状态转移方程」才会「准确」。</p><p>其实求解这个问题，还利用到了一个「动态规划」问题的一个特点「无后效性」。我们在下一节向大家解释。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1、「力扣」第 279 题：<a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a>；</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 15：  动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「动态规划」专题 1：理解「重复子问题」</title>
      <link href="/leetcode-algo/2018/04/01/leetcode-solution/dynamic-programming-1/"/>
      <url>/leetcode-algo/2018/04/01/leetcode-solution/dynamic-programming-1/</url>
      
        <content type="html"><![CDATA[<h2 id="「动态规划」专题-1：理解「重复子问题」"><a href="#「动态规划」专题-1：理解「重复子问题」" class="headerlink" title="「动态规划」专题 1：理解「重复子问题」"></a>「动态规划」专题 1：理解「重复子问题」</h2><p>从这一章开始，我们将向大家开启「算法」领域另一个重要的话题「动态规划」。</p><p>首先，「动态规划」这个名字可能听起来有点让琢磨不透，感觉它像是在「运筹学」这个领域里的方法，这一点其实没有错，「动态规划」的方法广泛运用于各行各业，当然包括「运筹学」等「最优化领域」。</p><p>但我们初学「动态规划」的时候，可以暂时忽略这个「动态规划」有点让人捉摸不透的名字。从一个最简单的例子去理解「动态规划」的基本思想。</p><p>首先我们解释「规划」这个词，在《算法导论》这本书里，对「规划」的解释是「表格」，这一点定义我觉得是非常准确的，因为可以用「动态规划」解决的问题，就是让我们在求解问题的过程中，记录每一步求解的结果。</p><p>下面我们解释「动态」，我没有在维基百科以及一些经典的书籍上找到「动态」的解释，我自己是这样理解「动态」这个词。「动态」这是与求解「动态规划」问题的两个思路相关的。</p><p>「动态规划」告诉我们求解一个问题，可以不直接求解这个问题，而是去思考这个问题最开始（规模最小的时候）的时候是什么样子，然后通过递推的方式，一步一步得到结果，直到问题得到解决，这是一种「自下而上」的思想。</p><p>而我们熟悉的「递归」方法，是一种「自上而下」的思想。这两种思想在绝大多数情况下，都能够帮助我们解决问题。而「动态」告诉我们「自上而下」「自下而上」都可以解决这一类问题。在这里给大家一个提示，在我们这门课程里介绍的绝大多数「动态规划」的问题，都可以使用「自底向上」的思路解决，树形 dp 等情况除外。</p><p>对于可以使用「动态规划」解决的问题，主要有下面三个特点：</p><p>1、重复子问题；</p><p>也叫「重复子问题」，从「斐波拉契数列」求解的问题中，我们知道，如果递归地去这个问题，会遇到很多「重复子问题」。这些子问题不应该被重复计算。</p><p>2、最优子结构；</p><p>求解子问题得到的最优解，组成了规模更大的原问题的最优解，这样的动态规划问题，我们称之为具有「最优子结构」。</p><p>动态规划问题通常应用的场景是：我们直接求解这个问题感觉难度较大，但是我们把这个问题拆分为规模更小的问题的时候，这个问题的解通常也就能够找到，这样的解决问题的实现通常都要借助递归来实现。</p><p>3、无后效性。</p><ul><li><p>在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。</p></li><li><p>某阶段状态一旦确定，就不受之后阶段的决策影响。</p></li></ul><p>我们将通过具体的例子来解释可以使用「动态规划」方法解决的问题的这 3 个特点。</p><p>我们先来看一个最最简单的问题：「斐波拉契数列」。</p><p>「力扣」第 509 题：<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">斐波那契数</a>。</p><h3 id="方法一：使用递归"><a href="#方法一：使用递归" class="headerlink" title="方法一：使用递归"></a>方法一：使用递归</h3><p>分析：虽然可以通过，但是认为是错的，因为进行了大量的重复计算。因此时间复杂度是认为指数级别。（这个结论比较粗糙，由于我们是算法基础课程，就不带着代价去研究这个细节了。）</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> N<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200407034805169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x3X3Bvd2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>解决的办法是使用一个数组作为「缓存」，在遇到同样的问题的时候，先查表。</p><ul><li>如果已经计算过，就不再计算；</li><li>如果还没有计算过，就递归去计算一次。</li></ul><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> N<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 0 要占一个位置，所以设置 N + 1 个位置</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>上面「递归」求解的过程是「自底向上」的过程，而「动态规划」告诉我们一种求解问题的思路：「自底向上」，事实上，我们人在计算的时候，更多会这样去计算。</p><ul><li>「自上而下」和 「自底向上」的解法通常都可以称为「动态规划」；</li><li>如果没有学习过「动态规划」，通过「递归」求解，应该需要知道做了大量重复计算，因此需要加入缓存，这种做法叫「记忆化递归」或者「记忆化搜索」；</li><li>而使用「自底向上」的思路可以解决在入门阶段的绝大多数「动态规划」问题，我们就是去想一下，这个问题最开始的时候是什么样子，而不是直接去解决这个问题，请大家在练习的过程中逐渐体会这个思路。</li></ul><p>注意：并不是所有的「动态规划」问题都可以「自底向上」去做，但是初学的时候，大家可以直接适应这种解法，因为「自上而下」的写法就是「递归」的写法，我们已经相对熟悉。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> N<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一小节，希望大家能够体会「动态规划」的一个思路，「自底向上」，并且理解使用「动态规划」解决问题的一个特征：「重复子问题」。</p><p>因为有「重复子问题」，我们在「自底向上」求解的过程中，通过先解决更小规模的问题，在处理更大规模的问题的时候，直接使用了更小规模问题的结果，进而原问题得到了解决。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1、「力扣」第 70 题：<a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener">爬楼梯</a>。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 15：  动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「回溯算法」专题 8：游戏问题（数独问题）</title>
      <link href="/leetcode-algo/2018/02/08/leetcode-solution/backtracking-8/"/>
      <url>/leetcode-algo/2018/02/08/leetcode-solution/backtracking-8/</url>
      
        <content type="html"><![CDATA[<h2 id="「回溯算法」专题-8：游戏问题（数独问题）"><a href="#「回溯算法」专题-8：游戏问题（数独问题）" class="headerlink" title="「回溯算法」专题 8：游戏问题（数独问题）"></a>「回溯算法」专题 8：游戏问题（数独问题）</h2><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 14： 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 树形问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「回溯算法」专题 7：游戏问题（八皇后问题）</title>
      <link href="/leetcode-algo/2018/02/07/leetcode-solution/backtracking-7/"/>
      <url>/leetcode-algo/2018/02/07/leetcode-solution/backtracking-7/</url>
      
        <content type="html"><![CDATA[<h2 id="「回溯算法」专题-7：游戏问题（八皇后问题）"><a href="#「回溯算法」专题-7：游戏问题（八皇后问题）" class="headerlink" title="「回溯算法」专题 7：游戏问题（八皇后问题）"></a>「回溯算法」专题 7：游戏问题（八皇后问题）</h2><p>回溯法是经典的人工智能的基础，这句话中”经典”可以理解为”传统”。现如今，人工智能领域有一个非常流行的话题，那就是机器学习。</p><p>下面我们就来介绍一个传统的人工智能问题：n 皇后问题。同样地，它是典型的递归回溯问题。</p><p>「回溯算法」由于它是一个遍历算法，再加上通常情况下，我们使用一份状态变量去搜索整个「状态空间」，因此「回溯算法」很多时候能够帮助我们解决一些游戏类的问题。</p><p>因为人脑是很难穷举玩所有可能的情况，但是我们可以借助编程语言，来帮助我们玩好一些游戏，因此，在一些人工智能的书籍上，很多时候会先介绍回溯算法，可以认为「回溯算法」是人工智能的基础算法。</p><p>下面我们就来看一个典型的使用「回溯算法」解决的问题：「n 皇后」问题，这道题是「力扣」上第 51 号问题。</p><blockquote><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc3NldHMubGVldGNvZGUtY24uY29tL2FsaXl1bi1sYy11cGxvYWQvdXBsb2Fkcy8yMDE4LzEwLzEyLzgtcXVlZW5zLnBuZw?x-oss-process=image/format,png" alt="img"></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><pre><code>输入: 4输出: [ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><p><strong>分析</strong>：以 4 皇后问题为例，它的「搜索」过程如下，大家完全可以在纸上模拟下面这个过程：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzlkNDNkMDM4OTc4NDY1YmMxZjM1ZTA4OGRlNGNiOGI4ZDI2MDEyOWRiMzM1MTAzNjMxN2EyMjQ2ZTEyMTI0N2YtMDA1MS5naWY" alt="0051.gif">{:width=500}<br>搜索问题的解决策略是画递归树。还以 4 皇后问题为例，画出的递归树如下。</p><p>以下假定给棋盘的每一行从左到右标记为 $1$、$2$、$3$、$4$：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL2E4ODI2MzkxMTY2MmYxOTJmM2YwNWIxNGU5NDg3MzEwZGU4YjVmMGE3MzM3NjE1Nzk0N2UzN2QwYTAwNDAxOGEtaW1hZ2UucG5n?x-oss-process=image/format,png" alt="image.png"><br>{:align=center}</p><p>那么，递归搜索的过程可以表示成如下递归树（只画了 2 层）：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL2QzNjcxZTk1MGMyZWE1OWU0Y2M4NWVkNGNjN2FjYmRlMmJmNzU5ZGZjZTUwYjFkN2MwNDczNzdjMDE5NjkzNDgtaW1hZ2UucG5n?x-oss-process=image/format,png" alt="image.png">{:width=600}<br>这其实就是「全排列」问题 + 「剪枝」 。 「剪枝」的依据就是题目中描述的「N 皇后」问题的规则，有了使用数组 <code>used</code> （哈希表、位图）的经验，我们可以多设置一些「状态」，下面依次进行分析：</p><ol><li>由于是一行一行摆放，因此这些「皇后」一定不在同一行，无需额外设置状态；</li><li>为了保证不再同一列，即不能出现 <code>[2, 2, 1, 3]</code> 这种情况，第 46 的数组 <code>used</code>（哈希表、位图）就是这样的「状态」 变量；</li><li>为了保证至少两个皇后不同时出现在主对角线或者副对角线，我们的策略是，只要「检测」到新摆放的「皇后」与已经摆放好的「皇后」冲突，就尝试摆放下一个位置，在「无处安放」的时候「剪枝」。</li></ol><p>下面我们研究一下主对角线或者副对角线上的元素有什么特性。我们此时能掌握的信息只有行和列的索引，不妨将它标注在棋盘上。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tLzMwMDA2NGM1NWUwZTM1MTNlY2U4MjU0NTFlMzg1N2Y3N2JiYzQ3ODhiMGJlYjk3NGFlNzJhMDZlMGUxMWRkOGYtaW1hZ2UucG5n?x-oss-process=image/format,png" alt="image.png"></p><ul><li>为此，我们可以像数组 <code>used</code> 那样，再为「主对角线」和「副对角线」设置相应的数组变量，只要排定一个「皇后」的位置，就相应低占住相应的位置；</li><li>因为位置有限，可以使用数组，不过我个人先使用的哈希表，原因是副对角那里使用数组的话还要计算一个偏差，另外，数组的元素个数也要归纳得到，因此，使用哈希表表示「状态」，我认为在编码上是比较简洁的；</li><li>写对了「哈希表」以后，说明我们的思路是没有问题的，然后再写「数组」作为状态，最后写「位图」作为「状态」 。</li></ul><p>得到一个符合要求的 「全排列」以后，生成棋盘的代码就很简单了。</p><p>*<em>参考代码 *</em>：使用哈希表分别记录「列占用情况」 、 「主对角线占用情况」 、 「副对角线占用情况」。 </p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashSet<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> col <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> master <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> slave <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> col<span class="token punctuation">,</span> master<span class="token punctuation">,</span> slave<span class="token punctuation">,</span> stack<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>                           <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> col<span class="token punctuation">,</span>                           <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> master<span class="token punctuation">,</span>                           <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> slave<span class="token punctuation">,</span>                           Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">,</span>                           List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> board <span class="token operator">=</span> <span class="token function">convert2board</span><span class="token punctuation">(</span>stack<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 针对每一列，尝试是否可以放置</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>col<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>master<span class="token punctuation">[</span>row <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>slave<span class="token punctuation">[</span>row <span class="token operator">-</span> i <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                col<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                master<span class="token punctuation">[</span>row <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                slave<span class="token punctuation">[</span>row <span class="token operator">-</span> i <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> col<span class="token punctuation">,</span> master<span class="token punctuation">,</span> slave<span class="token punctuation">,</span> stack<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>                slave<span class="token punctuation">[</span>row <span class="token operator">-</span> i <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                master<span class="token punctuation">[</span>row <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                col<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">convert2board</span><span class="token punctuation">(</span>Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> board <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer num <span class="token operator">:</span> stack<span class="token punctuation">)</span> <span class="token punctuation">{</span>            StringBuilder stringBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stringBuilder<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Q"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            board<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>stringBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> board<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>「回溯问题」应用于游戏，一般都比较难，大家可以根据自己的实际情况酌情选择相关的练习来做。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1、「力扣」第 52 题：<a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">N皇后 II</a>；</p><p>2、「力扣」第 37 题：<a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">解数独</a>；</p><p>3、「力扣」第 1307 题：<a href="https://leetcode-cn.com/problems/verbal-arithmetic-puzzle/" target="_blank" rel="noopener">口算难题</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 14： 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 树形问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「回溯算法」专题 6：二维平面上使用回溯法</title>
      <link href="/leetcode-algo/2018/02/06/leetcode-solution/backtracking-6/"/>
      <url>/leetcode-algo/2018/02/06/leetcode-solution/backtracking-6/</url>
      
        <content type="html"><![CDATA[<h2 id="「回溯算法」专题-6：二维平面上使用回溯法"><a href="#「回溯算法」专题-6：二维平面上使用回溯法" class="headerlink" title="「回溯算法」专题 6：二维平面上使用回溯法"></a>「回溯算法」专题 6：二维平面上使用回溯法</h2><p>这一节我们介绍在「力扣」上一类比较经典的问题：在二维平面上的搜索问题。这个问题是「力扣」上第 79 号问题：单词搜索。题目是这样的：</p><blockquote><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p></blockquote><p><strong>示例</strong>：</p><pre><code>board =[  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]]给定 word = &quot;ABCCED&quot;, 返回 true给定 word = &quot;SEE&quot;, 返回 true给定 word = &quot;ABCB&quot;, 返回 false</code></pre><p>提示：</p><ul><li>board 和 word 中只包含大写和小写英文字母。</li><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li><li><code>1 &lt;= word.length &lt;= 10^3</code></li></ul><p>这个问题的思路是这样的，我们首先先遍历二维矩阵，只要找到了这个单词的首字母，就可以在这个起点上搜索第 2 个字符，搜索字符的过程，应该注意一点，那就是，在尝试搜索的时候，已经搜索过的地方应该占住这个位置，如果四个方向都搜索不到结果，就应该释放对当前结点的占用，回退上上一格，继续搜索。</p><p>这样的算法很像叫做 <code>floodfill</code> ，<strong>泛洪填充（</strong>也称为<strong>种子填充）</strong>是一种<a href="https://en.wikipedia.org/wiki/Algorithm" target="_blank" rel="noopener">算法</a>，用于确定<a href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory#Connectivity" target="_blank" rel="noopener">连接</a>到多维<a href="https://en.wikipedia.org/wiki/Array_data_structure" target="_blank" rel="noopener">数组中</a>给定节点的区域。它用于<a href="https://en.wikipedia.org/wiki/Paint_program" target="_blank" rel="noopener">绘画程序</a>的“存储桶”填充工具中，以不同的颜色填充连接的相似颜色的区域，并用于诸如<a href="https://en.wikipedia.org/wiki/Go_(game)" target="_blank" rel="noopener">Go</a>和<a href="https://en.wikipedia.org/wiki/Minesweeper_(video_game)" target="_blank" rel="noopener">Minesweeper之类的</a>游戏中，以确定要清除的部分。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQud2lraW1lZGlhLm9yZy93aWtpcGVkaWEvY29tbW9ucy83LzdlL1JlY3Vyc2l2ZV9GbG9vZF9GaWxsXzRfJTI4YWthJTI5LmdpZg" alt=""></p><p>这样的算法，其实也是一个树形结构。</p><p>编写代码的过程中，我们要注意：</p><p>1、使用方向数组，表示 上下左右 4 个方向；</p><p>2、使用 <code>marked</code> 数组标记当前位置时候被使用过；</p><p>3、还需要一个函数判断当前位置是否越界。</p><p>这些都是非常常规的编码技巧，大家需要多练习，以巩固，并且养成良好的编码习惯。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//        x-1,y</span>    <span class="token comment" spellcheck="true">// x,y-1  x,y    x,y+1</span>    <span class="token comment" spellcheck="true">//        x+1,y</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> direction <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 盘面上有多少行</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 盘面上有多少列</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">private</span> String word<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">exist</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        m <span class="token operator">=</span> board<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>word <span class="token operator">=</span> word<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>board <span class="token operator">=</span> board<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> newX <span class="token operator">=</span> i <span class="token operator">+</span> direction<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> newY <span class="token operator">=</span> j <span class="token operator">+</span> direction<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inArea</span><span class="token punctuation">(</span>newX<span class="token punctuation">,</span> newY<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>marked<span class="token punctuation">[</span>newX<span class="token punctuation">]</span><span class="token punctuation">[</span>newY<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>newX<span class="token punctuation">,</span> newY<span class="token punctuation">,</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">inArea</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        char[][] board =</span><span class="token comment" spellcheck="true">//                {</span><span class="token comment" spellcheck="true">//                        {'A', 'B', 'C', 'E'},</span><span class="token comment" spellcheck="true">//                        {'S', 'F', 'C', 'S'},</span><span class="token comment" spellcheck="true">//                        {'A', 'D', 'E', 'E'}</span><span class="token comment" spellcheck="true">//                };</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//        String word = "ABCCED";</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        String word <span class="token operator">=</span> <span class="token string">"ba"</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> exist <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">exist</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>exist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希望大家通过这个问题，继续体会「回溯算法」里一条路走不通，就「回退」的思想，它依然是「深度优先遍历」的思想。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1、「力扣」第 200 题：<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">岛屿数量</a>。</p><p>2、「力扣」之「剑指 Offer 系列」第 13 题：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">机器人的运动范围</a>。</p><p>3、「力扣」第 733 题：<a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener">图像渲染</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 14： 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 树形问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「回溯算法」专题 5：组合之和问题</title>
      <link href="/leetcode-algo/2018/02/05/leetcode-solution/backtracking-5/"/>
      <url>/leetcode-algo/2018/02/05/leetcode-solution/backtracking-5/</url>
      
        <content type="html"><![CDATA[<h2 id="「回溯算法」专题-5：组合之和问题"><a href="#「回溯算法」专题-5：组合之和问题" class="headerlink" title="「回溯算法」专题 5：组合之和问题"></a>「回溯算法」专题 5：组合之和问题</h2><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 14： 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 树形问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「回溯算法」专题 4：组合问题</title>
      <link href="/leetcode-algo/2018/02/04/leetcode-solution/backtracking-4/"/>
      <url>/leetcode-algo/2018/02/04/leetcode-solution/backtracking-4/</url>
      
        <content type="html"><![CDATA[<h2 id="「回溯算法」专题-4：组合问题"><a href="#「回溯算法」专题-4：组合问题" class="headerlink" title="「回溯算法」专题 4：组合问题"></a>「回溯算法」专题 4：组合问题</h2><p>再次体会分析递归结构的重要意义，画出树形图是关键。并且初步感知递归分支可以修建的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 14： 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 树形问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「回溯算法」专题 3：字符串中的回溯问题</title>
      <link href="/leetcode-algo/2018/02/03/leetcode-solution/backtracking-3/"/>
      <url>/leetcode-algo/2018/02/03/leetcode-solution/backtracking-3/</url>
      
        <content type="html"><![CDATA[<h2 id="「回溯算法」专题-3：字符串中的回溯问题"><a href="#「回溯算法」专题-3：字符串中的回溯问题" class="headerlink" title="「回溯算法」专题 3：字符串中的回溯问题"></a>「回溯算法」专题 3：字符串中的回溯问题</h2><p>我们这一节来看一个在字符串上进行搜索的问题，这道题是「力扣」上第 22 题：括号生成问题。</p><blockquote><p>给出 <code>n</code> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p></blockquote><p>例如，给出 n = 3，生成结果为：</p><pre><code>[  &quot;((()))&quot;,  &quot;(()())&quot;,  &quot;(())()&quot;,  &quot;()(())&quot;,  &quot;()()()&quot;]</code></pre><p>这是一个很典型地使用回溯算法完成的问题，因为要完成一件事情（生成 n 对括号），并且是有效的括号。</p><p>这件事情可以有若干种做法，每一种做法有若干个步骤。并且要我们求出这若干种解法，这样的问题显然可以使用回溯算法解决。</p><p>我们就拿示例 3 在草稿纸做一个计算。</p><p>要得到一个符合条件的字符串，首先第 1 个字符一定是 <code>（</code> ，不可能是右括号；</p><p>第 2 个字符，可以是左括号，也可以是右括号，</p><p>如果第 2 个字符使用了左括号，第 3 个字符可以使用左括号，也可以使用右括号；</p><p>如果第 2 个字符使用了右括号，第 3 个字符只能使用左括号，因为如果使用了右括号，就是不符合题意的括号，在它之前，没有与之配对的括号。</p><p>其实分析到这里，我们的思路就来了，是否可以使用左括号和右括号，其实是和已经使用的左右括号的个数相关的，因此我们在搜索的时候，就需要考虑这个因素。</p><p>我们再把刚才的分析概括一下：</p><ul><li>只要左括号还有剩余的数量，换句话说，只要左括号可以用，那么就可以在当前位置添加左括号；</li><li>右括号的使用是有限制的，如果之前已经使用的左括号数量和右括号数量相等，那么当前就不能够使用右括号，原因我们刚刚也说了，如果使用了右括号，在之前就不能找到与之匹配的左括号。</li></ul><p>根据这样的思路，我们可以把这张图画完。就是这样的一个树形结构。</p><p>（缺个图）</p><p>下面我们看一下如何编码：</p><p>根据我们刚才的分析，需要设计的状态变量有：</p><p>1、左括号还可以使用的个数；</p><p>2、右括号还可以使用的个数；</p><p>3、当前已经拼接出的字符串，可以理解为是一个路径变量</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 做减法</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 执行深度优先遍历，搜索可能的结果</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @param curStr 当前递归得到的结果     * @param left   左括号还有几个可以使用     * @param right  右括号还有几个可以使用     * @param res    结果集     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>String curStr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 因为每一次尝试，都使用新的字符串变量，所以无需回溯</span>        <span class="token comment" spellcheck="true">// 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curStr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>curStr <span class="token operator">+</span> <span class="token string">"("</span><span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>curStr <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是代码。</p><p>我们会发现，这个代码有一点点神奇，它好像没有回溯的过程。但事实上，这个题回溯的过程并不明显。这是因为在 Java 语言里：<code>curStr + &quot;(&quot;</code> 这个语法生成了新的字符串对象，因此，在递归的每一个结点，其实都生成了新的字符串对象。因此，在递归终止的时候，我们直接将字符串添加到结果集中就好了。</p><p>感兴趣的朋友，不妨使用 <code>StringBuilder</code> 字符序列这个类进行搜索，这样的操作就很像我们之前的搜索，就一定会有「撤销选择」和「状态重置」的操作。</p><p>但事实上，它们都是在树形问题上的深度优先遍历，都有「回到过去」的过程，大家依然是需要通过理解「深度优先遍历」这个过程去体会，我们使用「遍历」这个思想，特别是「深度优先遍历」去搜索整个状态空间的思路，它有一个「回到过去」的过程，就是通过回到过去，我们就可以尝试不同的选择，因此命名为「回溯」算法。</p><p>下面提供两道练习题：希望大家通过这两道练习，进一步体会这个思想。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1、「力扣」第 17 题：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">电话号码的字母组合</a></p><p>2、「力扣」第 784 题：<a href="https://leetcode-cn.com/problems/letter-case-permutation/" target="_blank" rel="noopener"> 字母大小写全排列</a></p>]]></content>
      
      
      <categories>
          
          <category> 专题 14： 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 树形问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「回溯算法」专题 2：从「全排列」问题开始认识「回溯算法」</title>
      <link href="/leetcode-algo/2018/02/02/leetcode-solution/backtracking-2/"/>
      <url>/leetcode-algo/2018/02/02/leetcode-solution/backtracking-2/</url>
      
        <content type="html"><![CDATA[<h2 id="「回溯算法」专题-2：从「全排列」问题开始认识「回溯算法」"><a href="#「回溯算法」专题-2：从「全排列」问题开始认识「回溯算法」" class="headerlink" title="「回溯算法」专题 2：从「全排列」问题开始认识「回溯算法」"></a>「回溯算法」专题 2：从「全排列」问题开始认识「回溯算法」</h2><p>体会回溯的方法在求解排列问题中的应用，掌握使用数组记录每次走过的路的技巧，体会在这样的过程中状态重置的意义。</p><p>首先画出这个问题的树形结构。</p><p><img src="https://img-blog.csdnimg.cn/20200219095002354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x3X3Bvd2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>所有符合条件的结点在这棵递归树的叶子结点；</li><li>使用深度优先遍历（DFS）或者广度优先遍历（BFS）遍历这棵递归树，在叶子结点处添加符合题意的一个结果，发现使用 BFS 编码较难。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200219095026148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x3X3Bvd2Vy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>使用 DFS 可以使用递归方法，借助方法栈完成，即<strong>传递的参数通过递归方法的方法栈进行传递，而不用手动编写栈和结点类，把结点类需要的变量通过递归方法的参数进行传递即可</strong>；</li><li><strong>树的每一个结点表示解决这个问题处在了哪一个阶段，我们使用不同的变量进行区分</strong>，这些变量叫做“状态变量”；</li><li>而<strong>深度优先遍历有一个回退的过程</strong>，在回退的时候，所有的“状态”需要和第一次来到这个结点的时候相同，因此这里需要做“状态重置”（或者称“恢复变量”、“撤销选择”），这是深搜称之为“回溯算法”的原因。</li></ul><p>::: warning 注意</p><p>深度优先遍历作为搜索遍历的方法，其思想也是很朴素且深刻的，深搜表现出一种“不撞南墙不回头”的特点。具体的行为是：完成一件事情有多个阶段，在每一个阶段有多种选择，先走其中一个，然后实在走不下去了，再回退到上一个结点继续下一个选择；</p><p>回到上一个结点的步骤就称之为“回溯”，在“回溯”的时候必须保证回到之前刚来到这个结点的状态，这叫做“状态重置”；</p><p>大家想一想在电影《大话西游》里月光宝盒的作用，正是因为月光宝盒有“回到过去”，将所有的一切恢复到之前的样子的功能，至尊宝才能做出最正确的选择；</p><p>在人类的世界里没有“月光宝盒”，但是<strong>在计算机的世界里，“状态重置”是很容易实现的，因此我们可以使用一份状态变量完成所有状态的搜索，只把符合特定条件的“状态”保存下来，作为结果集，这就是“回溯算法”能成为强大的搜索算法的原因</strong>。</p><blockquote><p>需要设计的状态变量有：递归树到了第几层（已经使用了几个数），从根结点到叶子结点的路径（即一个全排列），哪些数是否使用过。</p></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayDeque<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Deque<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 由于只在结尾操作，因此是一个栈，Java 的 Stack 类建议使用 Deque 作为栈的实现</span>        Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 由于是深搜，深搜需要使用栈，而写递归方法就可以把状态变量设计成递归方法参数</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> used<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @param nums  候选数组     * @param len   冗余变量，作为参数传递不用每次都从 nums 中读取 length 属性值     * @param depth 冗余变量，作为参数传递不用每次都从 path 中调用 size() 方法     * @param path  从根结点到叶子结点的路径     * @param used  记录当前结点已经使用了哪些元素，这些元素都在 path 变量中     * @param res   结果集     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">,</span>                     Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> path<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> used<span class="token punctuation">,</span>                     List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">==</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> len<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> used<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 此处是回退的过程，发生状态重置（撤销选择），代码与 dfs 是对称出现的</span>            path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">permute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> size<span class="token punctuation">,</span> depth<span class="token punctuation">,</span> path<span class="token punctuation">,</span> state<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> depth <span class="token operator">==</span> size<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>state <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    dfs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> size<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> path <span class="token operator">+</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> state <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        state <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        dfs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">,</span> res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明</strong>：即使是这样一个简单的回溯搜索算法，这里面也有比较多的细节需要注意。</p><p>请读者思考以下问题：</p><p>1、为什么需要状态重置，不重置是否可以？</p><p>2、在最后 <code>if (depth == len)</code> 这一步，为什么要套一层 <code>new ArrayList&lt;&gt;(path)</code>，这与 Java 和 Python 的方法传递机制相关，<strong>请读者一定要搞清楚这里的细节</strong>；</p><p>3、广搜能不能实现，可以尝试写一下广搜（知道广搜不好写的原因即可，不一定真的写出来），对比与深搜算法的不同；</p><p>4、为什么要设计 <code>used</code> 数组，不使用 <code>used</code> 数组会带来什么变化，搜索会更快吗？</p><p>5、如果会 Python 的朋友，比较一下在给出的 Python 代码与 Java 代码的不同之处。</p><p>在这里为了节约篇幅，突出重点和思想，就不展开叙述了。更多的细节（包括复杂度分析）可以参考我在「力扣」第 46 题：“全排列”问题下写的题解：<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">从全排列问题开始理解“回溯搜索”算法</a>。</p><blockquote><p>回溯算法本质上得通过遍历，因此复杂度一般不低，但是再一些问题我们可以通过在搜索中判断哪些结点一定不会得到符合题意的结果，而跳过某一个分支的遍历，这样的操作犹如在一棵树上剪去一个枝叶，因此称之为“剪枝”；</p><p>“剪枝”的思想其实也很朴素、常见。就像我们在人生道路上，如果能够知道当前某个选择不能达到目标，应该及时停止，不继续投入时间和精力，这就是“剪枝”操作。</p></blockquote><p>第 46 题的扩展问题就是一个运用到剪枝操作的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 14： 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 树形问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「回溯算法」专题 1：在树形问题中使用深度优先遍历</title>
      <link href="/leetcode-algo/2018/02/01/leetcode-solution/backtracking-1/"/>
      <url>/leetcode-algo/2018/02/01/leetcode-solution/backtracking-1/</url>
      
        <content type="html"><![CDATA[<h2 id="「回溯算法」专题-1：在树形问题中使用深度优先遍历"><a href="#「回溯算法」专题-1：在树形问题中使用深度优先遍历" class="headerlink" title="「回溯算法」专题 1：在树形问题中使用深度优先遍历"></a>「回溯算法」专题 1：在树形问题中使用深度优先遍历</h2><p>回溯法是解决很多算法问题的常见思想，甚至可以说是传统人工智能的基础方法。其本质依然是使用递归的方法<strong>在树形空间中寻找解</strong>。在这一章，我们来具体看一下将递归这种技术使用在非二叉树的结构中，从而认识回溯这一基础算法思想。</p><p>在解决二叉树的问题的中我们已经看到了递归算法的威力和有趣之处，也体会到了使用递归算法的痛点。当然，递归算法也绝不仅仅只是适用于二叉树问题的解决。从这一节开始，我们会在更多、更广义的问题上，使用递归算法。</p><p>递归算法还能够解决的一个典型问题，是具有<strong><em>树形结构</em></strong>的问题，当<strong>我们发现一个问题与一个更小的问题之间存在递归关系</strong>的时候，此时，递归关系呈现出来的就是一个树形结构。</p><p>为此，我们从一个比较简单的问题入手，介绍什么是树形问题。</p><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><ul><li>回溯搜索算法就是在树形图上的深度优先遍历；</li><li>正因为「深度优先遍历」有「回退」的过程，才需要「状态重置」或者称「撤销选择」，这就是「回溯」的意思。</li></ul><blockquote><p>理解回溯算法的第一步是<strong>画出树形图</strong>。</p></blockquote><p>参考的练习题在第 1 部分。</p><h3 id="难点-1"><a href="#难点-1" class="headerlink" title="难点 1"></a>难点 1</h3><p>理解「回溯」，倒不如把「回溯」理解成「深度优先遍历」，「回溯」只是现象，本质是 DFS</p><ul><li>回溯算法本质上是遍历的算法，全程使用一份状态变量去搜索状态空间里的所有状态，是节约空间的；</li><li>深度优先遍历呈现「一条道走到底，不撞南墙」不回头的特点。</li></ul><p><img src="http://liweiwei1419.gitee.io/visualgo/blog/backtracking.png" alt=""></p><h3 id="难点-2"><a href="#难点-2" class="headerlink" title="难点 2"></a>难点 2</h3><p>「深度优先遍历」与「广度优先遍历」的联系与差别：</p><ul><li>回溯算法本质上是遍历的算法，全程使用一份状态变量去搜索状态空间里的所有状态，是节约空间的；</li><li>深度优先遍历呈现「一条道走到底，不撞南墙」不回头的特点。</li></ul><p>回溯法是解决很多算法问题的常见思想，甚至可以说是传统人工智能的基础方法。其本质依然是使用递归的方法<strong>在树形空间中寻找解</strong>。在这一章，我们来具体看一下将递归这种技术使用在非二叉树的结构中，从而认识回溯这一基础算法思想。</p><p>在解决二叉树的问题的中我们已经看到了递归算法的威力和有趣之处，也体会到了使用递归算法的痛点。当然，递归算法也绝不仅仅只是适用于二叉树问题的解决。从这一节开始，我们会在更多、更广义的问题上，使用递归算法。</p><p>递归算法还能够解决的一个典型问题，是具有<strong><em>树形结构</em></strong>的问题，当<strong>我们发现一个问题与一个更小的问题之间存在递归关系</strong>的时候，此时，递归关系呈现出来的就是一个树形结构。</p><p>为此，我们从一个比较简单的问题入手，介绍什么是树形问题。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 14： 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 树形问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 1080 题：根到叶路径上的不足节点</title>
      <link href="/leetcode-algo/2018/01/07/leetcode-algo/1080-insufficient-nodes-in-root-to-leaf-paths/"/>
      <url>/leetcode-algo/2018/01/07/leetcode-algo/1080-insufficient-nodes-in-root-to-leaf-paths/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-1080-题：根到叶路径上的不足节点"><a href="#「力扣」第-1080-题：根到叶路径上的不足节点" class="headerlink" title="「力扣」第 1080 题：根到叶路径上的不足节点"></a>「力扣」第 1080 题：根到叶路径上的不足节点</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/insufficient-nodes-in-root-to-leaf-paths/solution/hou-xu-bian-li-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">分治法、后序遍历（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/insufficient-nodes-in-root-to-leaf-paths/" target="_blank" rel="noopener">根到叶路径上的不足节点</a>。</p><blockquote><p>给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点）</p><p>假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。</p><p>请你删除所有不足节点，并返回生成的二叉树的根。</p><p>示例 1：</p><p>输入：root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1</p><p>输出：[1,2,3,4,null,null,7,8,9,null,14]<br>示例 2：</p><p>输入：root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22</p><p>输出：[5,4,8,11,null,17,4,7,null,null,null,5]<br>示例 3：</p><p>输入：root = [5,-6,-6], limit = 0<br>输出：[]</p><p>提示：</p><p>给定的树有 1 到 5000 个节点<br>-10^5 &lt;= node.val &lt;= 10^5<br>-10^9 &lt;= limit &lt;= 10^9</p></blockquote><h3 id="分治法、后序遍历（Python-代码、Java-代码）"><a href="#分治法、后序遍历（Python-代码、Java-代码）" class="headerlink" title="分治法、后序遍历（Python 代码、Java 代码）"></a>分治法、后序遍历（Python 代码、Java 代码）</h3><h3 id="首先考虑结点如何删除"><a href="#首先考虑结点如何删除" class="headerlink" title="首先考虑结点如何删除"></a>首先考虑结点如何删除</h3><p>首先我们考虑如何删除结点的问题。已知一个二叉树中的结点要被删除，有两种办法：</p><ol><li>自己删除自己；</li><li>告诉父亲结点，自己需要从二叉树中被删除。</li></ol><p>“自己删除自己” 让我想到了 “单链表删除某个结点”，如果这个要被删除的结点是末尾结点，那还麻烦了。不过第 2 种办法“告诉父亲结点，自己需要从二叉树中被删除”，就很简单了，<strong>父亲结点收到孩子结点这个信号以后，只要把对孩子结点的引用切断即可</strong>。</p><h3 id="其次考虑使用哪一种遍历方式"><a href="#其次考虑使用哪一种遍历方式" class="headerlink" title="其次考虑使用哪一种遍历方式"></a>其次考虑使用哪一种遍历方式</h3><p>二叉树的问题一定离不开遍历，遍历有 DFS 和 BFS，根据题目中的描述 “考虑它所有 从根到叶的路径”，就知道不能用 BFS 了，那么 DFS 又有 3 种，分别如下：</p><p>1、先序遍历</p><p>（1）先执行当前结点的逻辑；<br>（2）如果有左结点，就递归执行左结点的逻辑；<br>（3）如果有右结点，就递归执行右结点的逻辑。</p><p>2、中序遍历</p><p>（1）如果有左结点，就递归执行左结点的逻辑；<br>（2）先执行当前结点的逻辑；<br>（3）如果有右结点，就递归执行右结点的逻辑。</p><p>3、后序遍历</p><p>（1）如果有左结点，就递归执行左结点的逻辑；<br>（2）如果有右结点，就递归执行右结点的逻辑；<br>（3）先执行当前结点的逻辑。</p><p>再看看我们首先考虑的问题，“告诉父亲结点，自己是否需要从二叉树中被删除”，那么 <strong>首先两个子结点（如果存在的话）要清楚自己是不是需要被删除</strong>，明显使用 “后序遍历”。</p><p>因此，<strong>删除结点（也可以称为 “剪枝”）的过程是从下到上的</strong>。</p><h3 id="最后编码实现"><a href="#最后编码实现" class="headerlink" title="最后编码实现"></a>最后编码实现</h3><p>进行后序遍历的时候，要告诉父亲节点自己是否需要从二叉树中删除，返回一个布尔值就可以了。这里编码要注意几个细节：</p><p>1、使用 Python 编码的朋友，尽量少使用 <code>not</code>，否定的判断出现太多，比较容易把自己绕晕，我这一版代码是改过几次的，原先我的 <code>__dfs</code> 方法设置的返回值的意思是“是否保留”。后来我把返回值的含义改成“是否删除”，就是为了让逻辑中少一些 <code>not</code>；  </p><p>2、当一个结点不是叶子结点的时候，它是否被删除，也要看它的孩子结点，<strong>只要孩子结点有一个被保留，父亲结点就不能被删，换句话说，父亲结点被删除当且仅当它的两个孩子结点均被删除</strong>；  </p><p>（温馨提示：下面的幻灯片中，有几页上有较多的文字，可能需要您停留一下，可以点击右下角的后退 “|◀” 或者前进 “▶|” 按钮控制幻灯片的播放。）</p><p><img src="https://pic.leetcode-cn.com/bbb86d78566a142c2daa2077ec3c28c9dc3c0829c88c95d20e60aeea6ccb29a9-1080-1.png" alt="1080-1.png">),<img src="https://pic.leetcode-cn.com/40229b370a84335b89a845e3f03ce93d9832105787afa6358b2d39b3c3219b24-1080-2.png" alt="1080-2.png">),<img src="https://pic.leetcode-cn.com/16d9e881d0ead4da82aeb6c6de9ed5f06f85fe51813000b0d9c7193f7d98dac8-1080-3.png" alt="1080-3.png">),<img src="https://pic.leetcode-cn.com/fd03f33eac29352e42bc4673aede9c0122bf41047017c69f427c6a98a4f8f7bc-1080-4.png" alt="1080-4.png">),<img src="https://pic.leetcode-cn.com/2adb2be65b0456553104f30d63cc32d97c022965b5736886429a80dcc345978a-1080-5.png" alt="1080-5.png">),<img src="https://pic.leetcode-cn.com/0f3df57c61bd6293c46e49f0a230590c4c3d34feb77ddddfb6241f972df3b8f4-1080-6.png" alt="1080-6.png">),<img src="https://pic.leetcode-cn.com/d5a0587ac83411d7b969188f963009ee2e4c798756ce3371b87acf3716f1c639-1080-7.png" alt="1080-7.png"></p><p>3、<strong>返回值的含义设置成“是否删除”的前提下，左右孩子的默认策略是删除，因为当只有一个孩子结点存在的时候，这个孩子结点的删除与否直接决定了父亲结点是否被删除</strong>，逻辑运算符 <code>and</code> 把不存在的那一边设置为 <code>True</code> ，就符合这个逻辑，不妨看看真值表，把其中一列全部设置成 <code>True</code> ，<code>and</code> 的结果就正好和另外一列是一样的。</p><table><thead><tr><th>左子树是否被删除</th><th>右子树是否被删除</th><th>and</th><th>or</th></tr></thead><tbody><tr><td><code>True</code></td><td><code>True</code></td><td><code>True</code></td><td><code>True</code></td></tr><tr><td><code>True</code></td><td><code>False</code></td><td><code>True</code></td><td><code>False</code></td></tr><tr><td><code>False</code></td><td><code>True</code></td><td><code>False</code></td><td><code>True</code></td></tr><tr><td><code>False</code></td><td><code>False</code></td><td><code>False</code></td><td><code>False</code></td></tr></tbody></table><p>如果你把 <code>__dfs</code> 方法的返回值意义设置成 <code>是否保留</code>，你就得看 <code>or</code> 那一列，并且左右孩子的默认策略就是保留。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题使用后序遍历完成，但更本质上的算法思想是分治法：<strong>把原问题拆解成同样结构且规模更小的子问题，待子问题处理完成以后，原问题就得到了解决</strong>，大家想一想是不是这样。</p><p>下面展示了两种后序遍历的返回值意义的示例代码，请读者比较它们二者的差别。</p><p>如果 <code>__dfs()</code> 方法返回值的意义是“当前结点是否被删除”，参考代码如下。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def __dfs(self, node, s, limit):        """        后序遍历        :param node: 当前遍历的结点        :param s: 当前累计的和        :param limit: 题目中给出的 limit        :return: 是否要删除 node 这个结点，True 表示要删除，False 表示不删除        """        # 先写递归终止条件：如果小于 limit，根据题意，要删除        if node.left is None and node.right is None:            return s + node.val < limit        # 默认为左右结点均剪枝，注意：初值不能设置成 False        l_tree_deleted = True        r_tree_deleted = True        # 如果有左子树，就先递归处理左子树        if node.left:            l_tree_deleted = self.__dfs(node.left, s + node.val, limit)        # 如果有右子树，就先递归处理右子树        if node.right:            r_tree_deleted = self.__dfs(node.right, s + node.val, limit)        # 左右子树是否删除的结论得到了，由自己来执行是否删除它们        if l_tree_deleted:            node.left = None        if r_tree_deleted:            node.right = None        # 只有左右子树都被删除了，自己才没有必要保留        return l_tree_deleted and r_tree_deleted    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:        root_deleted = self.__dfs(root, 0, limit)        if root_deleted:            return None        return root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution2 {    /**     * @param node     * @param s     * @param limit     * @return 返回 node 结点是否被删除（注意：这个返回值的意义，直接影响整个逻辑。）     */    private Boolean dfs(TreeNode node, int s, int limit) {        if (node.left == null && node.right == null) {            return s + node.val < limit;        }        // 注意：如果 dfs 的返回值的意义是这个结点是否被删除，它们的默认值应该设置为 true        boolean lTreeDeleted = true;        boolean rTreeDeleted = true;        // 如果有左子树，就先递归处理左子树        if (node.left != null) {            lTreeDeleted = dfs(node.left, s + node.val, limit);        }        // 如果有右子树，就先递归处理右子树        if (node.right != null) {            rTreeDeleted = dfs(node.right, s + node.val, limit);        }        // 左右子树是否保留的结论得到了，由自己来执行是否删除它们        if (lTreeDeleted) {            node.left = null;        }        if (rTreeDeleted) {            node.right = null;        }        // 只有左右子树都被删除了，自己才没有必要保留        return lTreeDeleted && rTreeDeleted;    }    public TreeNode sufficientSubset(TreeNode root, int limit) {        boolean rootDeleted = dfs(root, 0, limit);        if (rootDeleted) {            return null;        }        return root;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 <code>__dfs()</code> 方法返回值的意义是“当前结点是否被保留”，参考代码如下。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = None# 算法思想：分治法# 后序遍历：dfs 的返回值是：是否保留这个节点class Solution:    def __dfs(self, node, s, limit):        """        后序遍历        :param node: 当前遍历的结点        :param s: 当前累计的和        :param limit: 题目中给出的 limit        :return: 是否要保留 node 这个结点，True 表示要保留，False 表示不保留        """        # 先写递归终止条件：如果大于等于 limit，根据题意，要保留        if node.left is None and node.right is None:            return node.val + s >= limit        # 默认为左右结点均剪枝        # 注意：初值不能设置成 True        # 因为，当左右子树只有一个存在的时候，这个子树的逻辑值直接决定了父结点是否被保留        ltree_saved = False        rtree_saved = False        # 如果有左子树，就先递归处理左子树        if node.left:            ltree_saved = self.__dfs(node.left, s + node.val, limit)        # 如果有右子树，就先递归处理右子树        if node.right:            rtree_saved = self.__dfs(node.right, s + node.val, limit)        # 左右子树是否保留的结论得到了，由自己来执行是否保留它们        if not ltree_saved:            node.left = None        if not rtree_saved:            node.right = None        # 只要左右结点有一个被保留，这个结点就得被保留        return ltree_saved or rtree_saved    def sufficientSubset(self, root: TreeNode, limit: int) -> TreeNode:        root_saved = self.__dfs(root, 0, limit)        if not root_saved:            return None        return root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) {        val = x;    }}public class Solution {    /**     * @param node     * @param s     * @param limit     * @return 返回 node 结点是否被保留（注意：这个返回值的意义，直接影响整个逻辑。）     */    private Boolean dfs(TreeNode node, int s, int limit) {        if (node.left == null && node.right == null) {            return s + node.val >= limit;        }        // 注意：如果 dfs 的返回值的意义是这个结点是否被保留，它们的默认值应该设置为 false        boolean ltree_saved = false;        boolean rtree_saved = false;        // 如果有左子树，就先递归处理左子树        if (node.left != null) {            ltree_saved = dfs(node.left, s + node.val, limit);        }        // 如果有右子树，就先递归处理右子树        if (node.right != null) {            rtree_saved = dfs(node.right, s + node.val, limit);        }        // 左右子树是否保留的结论得到了，由自己来执行是否删除它们        if (!ltree_saved) {            node.left = null;        }        if (!rtree_saved) {            node.right = null;        }        // 左右子树有一颗被保留，自己就应该被保留        return ltree_saved || rtree_saved;    }    public TreeNode sufficientSubset(TreeNode root, int limit) {        boolean root_saved = dfs(root, 0, limit);        if (!root_saved) {            return null;        }        return root;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，$N$ 为二叉树结点的个数。</li><li>空间复杂度：$O(1)$。</li></ul><Vssue title="median-of-two-sorted-arrays"/>]]></content>
      
      
      <categories>
          
          <category> 专题 13： 分治算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 315 题：计算右侧小于当前元素的个数</title>
      <link href="/leetcode-algo/2018/01/06/leetcode-solution-new/count-of-smaller-numbers-after-self/"/>
      <url>/leetcode-algo/2018/01/06/leetcode-solution-new/count-of-smaller-numbers-after-self/</url>
      
        <content type="html"><![CDATA[<h1 id="「力扣」第-315-题：计算右侧小于当前元素的个数"><a href="#「力扣」第-315-题：计算右侧小于当前元素的个数" class="headerlink" title="「力扣」第 315 题：计算右侧小于当前元素的个数"></a>「力扣」第 315 题：计算右侧小于当前元素的个数</h1><table><thead><tr><th>题目地址</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">LeetCode 第 315 题：计算右侧小于当前元素的个数</a></td><td><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/gui-bing-pai-xu-suo-yin-shu-zu-python-dai-ma-java-/" target="_blank" rel="noopener">归并排序 + 索引数组（Python 代码、Java 代码）</a></td></tr></tbody></table><h3 id="归并排序（索引数组）"><a href="#归并排序（索引数组）" class="headerlink" title="归并排序（索引数组）"></a>归并排序（索引数组）</h3><p>如果有学习过一个数组的“逆序对”如何计算的朋友，对求解这道问题应该不陌生。求解“逆序对”的关键在于：<strong>当其中一个数字放进最终归并以后的有序数组中的时候，这个数字与之前看过的数字个数（或者是未看过的数字个数）可以直接统计出来，而不必一个一个数”</strong>。</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/315-1.png" alt="LeetCode 第 315 题-1"></p><p>“归并排序”完成以后，原数组的“逆序数”也数出来了。</p><p><strong>下面这句话很重要</strong>：</p><blockquote><p>回到本题，本题让我们求“在一个数组的某个元素的右边，比自己小的元素的个数”，因此，我们就应该在“前有序数组”的元素出列的时候，数一数“后有序数组”已经出列了多少元素，因为这些已经出列的元素都比当前出列的元素要小（或者等于）。</p></blockquote><p><strong>发现问题</strong></p><p>不过题目中要求我们要具体计算到元素级别。“归并排序”完成以后，原始数组的位置就已经变化了，因此如何定位元素是关键。</p><p><strong>想一想这一列问题是怎么解决的</strong></p><p><strong>一个元素在算法的执行过程中位置发生变化，我们还想定位它</strong>，这样的场景我们在“最小索引堆”中曾经学习过，从中得到启发，不妨也设置一个“索引数组”吧。使用“索引数组”的关键在于：</p><blockquote><p><strong>“原始数组”不变，用于比较两个元素的大小，真正位置变换的是“索引数组”</strong>。</p></blockquote><p>下面我尝试解释一下“索引数组”的使用方法：</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/315-2.png" alt="LeetCode 第 315 题-2"></p><p>为了完成“索引数组”的归并，我们还需要一个“索引数组”长度的临时数组，把索引数组的值复制过去，比较完成以后，再赋值回“索引数组”。具体请看下面的代码。</p><p><strong>编码注意事项</strong></p><p>一、可以复习一下“归并排序”的细节。</p><p>1、如果“前有序数组”和“后有序数组”直接合并的时候，就有序，就不必归并；<br>2、在“归并”的时候，全局使用一个临时存储数组，而不必每一个归并都新建临时的存储空间。</p><p>二、出列一个元素的时候，马上得到右边比自己小的元素的个数，是通过不同的指针之间的距离得到的。</p><p><strong>在编码的时候，建议在草稿纸上写写画画，用具体的数值带进去，才能确保你计算的指针之间的距离正确</strong>。例如我写的 Python 代码 <code>res[indexes[i]] += (right - mid)</code> 和 <code>res[indexes[i]] += (r - mid - 1)</code> 这两句代码的计算，我就是在草稿纸上画出来的。</p><p>三、如果你写过“逆序数”的计算的代码，你就会发现，“逆序数”的计算可以在“前有序数组”元素出列的时候计算逆序数，也可以在“后有序数组”元素出列的时候计算逆序数，你可以比较一下它们在编码时候的不同之处。下面是我写“逆序数”的计算代码写的草稿。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/315-3.png" alt="LeetCode 第 315 题-3"></p><p>参考代码：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def countSmaller(self, nums):        size = len(nums)        if size == 0:            return []        if size == 1:            return [0]        temp = [None for _ in range(size)]        indexes = [i for i in range(size)]        res = [0 for _ in range(size)]        self.__helper(nums, 0, size - 1, temp, indexes, res)        return res    def __helper(self, nums, left, right, temp, indexes, res):        if left == right:            return        mid = left + (right - left) // 2        # 计算一下左边        self.__helper(nums, left, mid, temp, indexes, res)        # 计算一下右边        self.__helper(nums, mid + 1, right, temp, indexes, res)        if nums[indexes[mid]] <= nums[indexes[mid + 1]]:            return        self.__sort_and_count_smaller(nums, left, mid, right, temp, indexes, res)    def __sort_and_count_smaller(self, nums, left, mid, right, temp, indexes, res):        # [left,mid] 前有序数组        # [mid+1,right] 后有序数组        # 先拷贝，再合并        for i in range(left, right + 1):            temp[i] = indexes[i]        l = left        r = mid + 1        for i in range(left, right + 1):            if l > mid:                # l 用完，就拼命使用 r                # [1,2,3,4] [5,6,7,8]                indexes[i] = temp[r]                r += 1            elif r > right:                # r 用完，就拼命使用 l                # [6,7,8,9] [1,2,3,4]                indexes[i] = temp[l]                l += 1                # 注意：此时前面剩下的数，比后面所有的数都大                res[indexes[i]] += (right - mid)            elif nums[temp[l]] <= nums[temp[r]]:                # [3,5,7,9] [4,6,8,10]                indexes[i] = temp[l]                l += 1                # 注意：                res[indexes[i]] += (r - mid - 1)            else:                assert nums[temp[l]] > nums[temp[r]]                # 上面两种情况只在其中一种统计就可以了                # [3,5,7,9] [4,6,8,10]                indexes[i] = temp[r]                r += 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.ArrayList;import java.util.List;public class Solution {    private int[] temp;    private int[] counter;    private int[] indexes;    public List<Integer> countSmaller(int[] nums) {        List<Integer> res = new ArrayList<>();        int len = nums.length;        if (len == 0) {            return res;        }        temp = new int[len];        counter = new int[len];        indexes = new int[len];        for (int i = 0; i < len; i++) {            indexes[i] = i;        }        mergeAndCountSmaller(nums, 0, len - 1);        for (int i = 0; i < len; i++) {            res.add(counter[i]);        }        return res;    }    /**     * 针对数组 nums 指定的区间 [l, r] 进行归并排序，在排序的过程中完成统计任务     *     * @param nums     * @param l     * @param r     */    private void mergeAndCountSmaller(int[] nums, int l, int r) {        if (l == r) {            // 数组只有一个元素的时候，没有比较，不统计            return;        }        int mid = l + (r - l) / 2;        mergeAndCountSmaller(nums, l, mid);        mergeAndCountSmaller(nums, mid + 1, r);        // 归并排序的优化，同样适用于该问题        // 如果索引数组有序，就没有必要再继续计算了        if (nums[indexes[mid]] > nums[indexes[mid + 1]]) {            mergeOfTwoSortedArrAndCountSmaller(nums, l, mid, r);        }    }    /**     * [l, mid] 是排好序的     * [mid + 1, r] 是排好序的     *     * @param nums     * @param l     * @param mid     * @param r     */    private void mergeOfTwoSortedArrAndCountSmaller(int[] nums, int l, int mid, int r) {        // 3,4  1,2        for (int i = l; i <= r; i++) {            temp[i] = indexes[i];        }        int i = l;        int j = mid + 1;        // 左边出列的时候，计数        for (int k = l; k <= r; k++) {            if (i > mid) {                indexes[k] = temp[j];                j++;            } else if (j > r) {                indexes[k] = temp[i];                i++;                // 此时 j 用完了，[7,8,9 | 1,2,3]                // 之前的数就和后面的区间长度构成逆序                counter[indexes[k]] += (r - mid);            } else if (nums[temp[i]] <= nums[temp[j]]) {                indexes[k] = temp[i];                i++;                // 此时 [4,5, 6   | 1,2,3 10 12 13]                //           mid          j                counter[indexes[k]] += (j - mid - 1);            } else {                // nums[indexes[i]] > nums[indexes[j]] 构成逆序                indexes[k] = temp[j];                j++;            }        }    }    public static void main(String[] args) {        int[] nums = new int[]{5, 2, 6, 1};        Solution solution = new Solution();        List<Integer> countSmaller = solution.countSmaller(nums);        System.out.println(countSmaller);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N \log N)$，数组的元素个数是 $N$，递归执行分治法，时间复杂度是对数级别的，因此时间复杂度是 $O(N \log N)$。</li><li>空间复杂度：$O(N)$，需要 $3$ 个数组，一个索引数组，一个临时数组用于索引数组的归并，还有一个结果数组，它们的长度都是 $N$，故空间复杂度是 $O(N)$。</li></ul><h1 id="LeetCode-第-315-题：“计算右侧小于当前元素的个数”题解"><a href="#LeetCode-第-315-题：“计算右侧小于当前元素的个数”题解" class="headerlink" title="LeetCode 第 315 题：“计算右侧小于当前元素的个数”题解"></a>LeetCode 第 315 题：“计算右侧小于当前元素的个数”题解</h1><p>题解地址：<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/gui-bing-pai-xu-suo-yin-shu-zu-python-dai-ma-java-/" target="_blank" rel="noopener">归并排序 + 索引数组</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">计算右侧小于当前元素的个数</a>。</p><blockquote><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p><p>示例:</p><p>输入: [5,2,6,1]<br>输出: [2,1,1,0]<br>解释:<br>5 的右侧有 2 个更小的元素 (2 和 1).<br>2 的右侧仅有 1 个更小的元素 (1).<br>6 的右侧有 1 个更小的元素 (1).<br>1 的右侧有 0 个更小的元素.</p></blockquote><h2 id="归并排序-索引数组"><a href="#归并排序-索引数组" class="headerlink" title="归并排序 + 索引数组"></a>归并排序 + 索引数组</h2><h3 id="归并排序-索引数组-1"><a href="#归并排序-索引数组-1" class="headerlink" title="归并排序 + 索引数组"></a>归并排序 + 索引数组</h3><p>如果有学习过一个数组的“逆序对”如何计算的朋友，对求解这道问题应该不陌生。</p><p><img src="https://pic.leetcode-cn.com/a8a8a0cb737e1100766f9b406e141f3cff0918b85c6443071456a34f50faf164-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/72f9f4e33a03726166812906eb63194dd81a2b02b969d86bfecaff6ca1faf7e3-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/b4b3251eaed3bbed98a5d8792d694aec4b95c3079d1e36d65581b56b11f10d94-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/7cdcdc78c3f2f056bf5c7e1fe116de0d1e2066bb8839c44a8b33755389dc63ac-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/fec652674db89aa8acda91e2ce84203168769f5d6d720797045dcc5865160a01-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/4b70e0bcf059b3dcbbea7ab46eb22314c65cc2bed74f17ef74a2eb5c0f73090b-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/2cd9099d60d56edf0c66ff41bdd6859c5327e6b39d4225449bff299c82073635-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/7babb0fcd83ce8f9b6dd5da2ee187268ad680c26bcc3ca5d6ab96aed4acde679-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/5de2c79dd9eeec39ceb44ad597a26da192060c29cf9845868243c2b6390f0e06-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/4e4a67de3359c904345bd27bfc78f0a41f6c438fd6275a8b6f3dc3c3d46abfcd-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/00082337651ccbf3115aaa5b3f5a66a59d5190c3d9f76f057ad92d44fecc35f3-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/5e4b3bcdd091e08cee30a8269856ec310d3cec16f784866c59c0e77f9670ad71-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/e49182d0eae38f0f762f614fed6f52b9f2eca9efd9554bb36bcc21137bdd9d4e-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/cc9d7b17dbfc5faced0d388271e9e4079e43c8ce5851d33ebe28d94fcacda3cc-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/9a8f56b50225b81c906d19d8929591fe34f8c1c3eb45966d6c8dd81b22b9450d-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/7a23dc334b01e693f787d3b3c3d98a685e5b6f48fd02b090985cd291cdc78cf6-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/5f01a5dd1866e4d728cd395232d1d52451e949030af6085ed76ade6a3c0f562a-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/b4f55e533b0fcf8166964cfb496c8e25393d4cfefb4dce3714b8806827f9b270-image.png" alt="image.png">),<img src="https://pic.leetcode-cn.com/c46a294e23a05d320e6903a932932fecd130bdeb78c718fe9a3b35e34d2f0056-image.png" alt="image.png"></p><p>求解 “逆序对” 的关键在于：<strong>当其中一个数字放进最终归并以后的有序数组中的时候，这个数字与之前看过的数字个数（或者是未看过的数字个数）可以直接统计出来，而不必一个一个数”</strong>。</p><p><img src="https://pic.leetcode-cn.com/729ec13f1387a428a264c143def1ff0e211952fa5c4f22424dbfb760509fa2bc-315-1.png" alt="315-1.png"></p><p>“归并排序” 完成以后，原数组的 “逆序数” 也数出来了。</p><p><strong>下面这句话很重要</strong>：</p><blockquote><p>回到本题，本题让我们求 “在一个数组的某个元素的右边，比自己小的元素的个数”，因此，我们就 <strong>应该在 “前有序数组” 的元素出列的时候，数一数 “后有序数组” 已经出列了多少元素</strong>，因为这些已经出列的元素都比当前出列的元素要小（或者等于）。</p></blockquote><p><strong>发现问题</strong></p><p>不过题目中要求我们要具体计算到元素级别。“归并排序” 完成以后，原始数组的位置就已经变化了，因此如何定位元素是关键。</p><p><strong>想一想这一类问题是怎么解决的</strong></p><p><strong>一个元素在算法的执行过程中位置发生变化，我们还想定位它</strong>，这样的场景我们在 “最小索引堆” 中曾经学习过，从中得到启发，不妨也设置一个 “索引数组” 吧。使用 “索引数组” 的关键在于：</p><blockquote><p><strong>“原始数组” 不变，用于比较两个元素的大小，真正位置变换的是 “索引数组”</strong>。</p></blockquote><p>下面我尝试解释一下 “索引数组” 的使用方法：</p><p><img src="https://pic.leetcode-cn.com/84953655bc88f3c6342d71a79895270675e9034593a713f833fd3edf1c39d231-315-2.png" alt="315-2.png"></p><p>为了完成 “索引数组” 的归并，我们还需要一个 “索引数组” 长度的临时数组，把索引数组的值复制过去，比较完成以后，再赋值回 “索引数组”。具体请看下面的代码。</p><p><strong>总结：</strong></p><blockquote><p>1、我们借助计算 “逆序数” 的思路完成本题，关键在于这里我们只能在 “前有序数组” 出列的时候计算逆序数；<br>如果题目让我们计算 “<code>nums[i]</code> 左侧小于 <code>nums[i]</code> 的元素的数量” 可以在 “后有序数组” 出列的时候计算逆序数；</p><p>2、体会 “索引数组” 这个使用技巧。</p></blockquote><p><strong>编码注意事项</strong></p><p>一、可以复习一下 “归并排序” 的细节。</p><p>1、如果 “前有序数组” 和 “后有序数组” 直接合并的时候，就有序，就不必归并；</p><p>2、在 “归并” 的时候，全局使用一个临时存储数组，而不必每一个归并都新建临时的存储空间。</p><p>二、出列一个元素的时候，马上得到右边比自己小的元素的个数，是通过不同的指针之间的距离得到的。</p><p><strong>在编码的时候，建议在草稿纸上写写画画，用具体的数值带进去，才能确保你计算的指针之间的距离正确</strong>。例如我写的 Python 代码 <code>res[indexes[i]] += (right - mid)</code> 和 <code>res[indexes[i]] += (r - mid - 1)</code> 这两句代码的计算，我就是在草稿纸上画出来的。</p><p>三、如果你写过 “逆序数” 的计算的代码，你就会发现，“逆序数” 的计算可以在 “前有序数组” 元素出列的时候计算逆序数，也可以在 “后有序数组” 元素出列的时候计算逆序数，你可以比较一下它们在编码时候的不同之处。</p><p><img src="https://pic.leetcode-cn.com/dab4062c5b86895c7ce2fa4ae4902443692bd33f8648d4420609d00d0171c0ff-inverse-pairs-1.png" alt="inverse-pairs-1.png"></p><p><img src="https://pic.leetcode-cn.com/0d5881f4ed023caafc73baf6bd7ce0bca265bea5c1d00215d506de8be2fafb18-inverse-pairs-2.png" alt="inverse-pairs-2.png"></p><p><strong>参考代码</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def countSmaller(self, nums):        size = len(nums)        if size == 0:            return []        if size == 1:            return [0]        temp = [None for _ in range(size)]        indexes = [i for i in range(size)]        res = [0 for _ in range(size)]        self.__helper(nums, 0, size - 1, temp, indexes, res)        return res    def __helper(self, nums, left, right, temp, indexes, res):        if left == right:            return        mid = left + (right - left) // 2        # 计算一下左边        self.__helper(nums, left, mid, temp, indexes, res)        # 计算一下右边        self.__helper(nums, mid + 1, right, temp, indexes, res)        if nums[indexes[mid]] <= nums[indexes[mid + 1]]:            return        self.__sort_and_count_smaller(nums, left, mid, right, temp, indexes, res)    def __sort_and_count_smaller(self, nums, left, mid, right, temp, indexes, res):        # [left,mid] 前有序数组        # [mid+1,right] 后有序数组        # 先拷贝，再合并        for i in range(left, right + 1):            temp[i] = indexes[i]        l = left        r = mid + 1        for i in range(left, right + 1):            if l > mid:                # l 用完，就拼命使用 r                # [1,2,3,4] [5,6,7,8]                indexes[i] = temp[r]                r += 1            elif r > right:                # r 用完，就拼命使用 l                # [6,7,8,9] [1,2,3,4]                indexes[i] = temp[l]                l += 1                # 注意：此时前面剩下的数，比后面所有的数都大                res[indexes[i]] += (right - mid)            elif nums[temp[l]] <= nums[temp[r]]:                # [3,5,7,9] [4,6,8,10]                indexes[i] = temp[l]                l += 1                # 注意：                res[indexes[i]] += (r - mid - 1)            else:                assert nums[temp[l]] > nums[temp[r]]                # 上面两种情况只在其中一种统计就可以了                # [3,5,7,9] [4,6,8,10]                indexes[i] = temp[r]                r += 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.ArrayList;import java.util.List;public class Solution {    private int[] temp;    private int[] counter;    private int[] indexes;    public List<Integer> countSmaller(int[] nums) {        List<Integer> res = new ArrayList<>();        int len = nums.length;        if (len == 0) {            return res;        }        temp = new int[len];        counter = new int[len];        indexes = new int[len];        for (int i = 0; i < len; i++) {            indexes[i] = i;        }        mergeAndCountSmaller(nums, 0, len - 1);        for (int i = 0; i < len; i++) {            res.add(counter[i]);        }        return res;    }    /**     * 针对数组 nums 指定的区间 [l, r] 进行归并排序，在排序的过程中完成统计任务     *     * @param nums     * @param l     * @param r     */    private void mergeAndCountSmaller(int[] nums, int l, int r) {        if (l == r) {            // 数组只有一个元素的时候，没有比较，不统计            return;        }        int mid = l + (r - l) / 2;        mergeAndCountSmaller(nums, l, mid);        mergeAndCountSmaller(nums, mid + 1, r);        // 归并排序的优化，同样适用于该问题        // 如果索引数组有序，就没有必要再继续计算了        if (nums[indexes[mid]] > nums[indexes[mid + 1]]) {            mergeOfTwoSortedArrAndCountSmaller(nums, l, mid, r);        }    }    /**     * [l, mid] 是排好序的     * [mid + 1, r] 是排好序的     *     * @param nums     * @param l     * @param mid     * @param r     */    private void mergeOfTwoSortedArrAndCountSmaller(int[] nums, int l, int mid, int r) {        // 3,4  1,2        for (int i = l; i <= r; i++) {            temp[i] = indexes[i];        }        int i = l;        int j = mid + 1;        // 左边出列的时候，计数        for (int k = l; k <= r; k++) {            if (i > mid) {                indexes[k] = temp[j];                j++;            } else if (j > r) {                indexes[k] = temp[i];                i++;                // 此时 j 用完了，[7,8,9 | 1,2,3]                // 之前的数就和后面的区间长度构成逆序                counter[indexes[k]] += (r - mid);            } else if (nums[temp[i]] <= nums[temp[j]]) {                indexes[k] = temp[i];                i++;                // 此时 [4,5, 6   | 1,2,3 10 12 13]                //           mid          j                counter[indexes[k]] += (j - mid - 1);            } else {                // nums[indexes[i]] > nums[indexes[j]] 构成逆序                indexes[k] = temp[j];                j++;            }        }    }    public static void main(String[] args) {        int[] nums = new int[]{5, 2, 6, 1};        Solution solution = new Solution();        List<Integer> countSmaller = solution.countSmaller(nums);        System.out.println(countSmaller);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N \log N)$，数组的元素个数是 $N$，递归执行分治法，时间复杂度是对数级别的，因此时间复杂度是 $O(N \log N)$。</li><li>空间复杂度：$O(N)$，需要 $3$ 个数组，一个索引数组，一个临时数组用于索引数组的归并，还有一个结果数组，它们的长度都是 $N$，故空间复杂度是 $O(N)$。</li></ul><p>这道题还可以使用树状数组求解，这一点我们以后再介绍。</p><Vssue title="count-of-smaller-numbers-after-self"/>]]></content>
      
      
      <categories>
          
          <category> 专题 13： 分治算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治算法 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 索引数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 240 题：搜索二维矩阵 II</title>
      <link href="/leetcode-algo/2018/01/05/leetcode-algo/0240-search-a-2d-matrix-ii/"/>
      <url>/leetcode-algo/2018/01/05/leetcode-algo/0240-search-a-2d-matrix-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-240-题：搜索二维矩阵-II"><a href="#「力扣」第-240-题：搜索二维矩阵-II" class="headerlink" title="「力扣」第 240 题：搜索二维矩阵 II"></a>「力扣」第 240 题：搜索二维矩阵 II</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/er-fen-fa-pai-chu-fa-python-dai-ma-java-dai-ma-by-/" target="_blank" rel="noopener">排除法（不是什么新方法，就是你们最常看到的那个解法，从右下角、左上角开始）（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a>。</p><blockquote><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-a-2d-matrix-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="排除法（不是什么新方法，就是你们最常看到的那个解法，从右下角、左上角开始）（Python-代码、Java-代码）"><a href="#排除法（不是什么新方法，就是你们最常看到的那个解法，从右下角、左上角开始）（Python-代码、Java-代码）" class="headerlink" title="排除法（不是什么新方法，就是你们最常看到的那个解法，从右下角、左上角开始）（Python 代码、Java 代码）"></a>排除法（不是什么新方法，就是你们最常看到的那个解法，从右下角、左上角开始）（Python 代码、Java 代码）</h2><p><strong>思路分析</strong>：</p><p>这道题比较容易想到的是还继续利用矩阵中的行和列有序的特性，使用二分查找法。思路不止一种，我也尝试写过，后来发现：编写二分查找法要考虑的边界问题比较多，如果对二分查找掌握得不熟练，很可能会出错。</p><p>下面介绍的这个方法，我认为是最优解，虽然它的时间复杂度并不是最优。</p><ul><li><p>如果我们要用二分查找法，可以发现，如果一行的开头那个元素就比目标元素大，那么这一行的所有元素，以及行号大于这一行的元素都不在考虑的范围内。</p></li><li><p>我们首先尝试从左上角开始走，发现横着走数值增大，竖着走数值也增大，目标数值这在两个方向上都有可能存在。那如果我们从右上角或者左下角除法，找目标元素，那就不一样了，于是有了下面的“排除法”。</p></li></ul><h3 id="方法：排除法"><a href="#方法：排除法" class="headerlink" title="方法：排除法"></a>方法：排除法</h3><p>1、如果选择左下角为起点</p><p>可以绘图如下：</p><p><img src="https://pic.leetcode-cn.com/4510e2eb3e1c68f28040bc920f5ec3959a5ee89d012d7df5c21aa8a4f039e3e2-0240-lower-left-corner.gif" alt="0240-lower-left-corner.gif"></p><p>总结出“搜索”的规律是：</p><p>如果当前数比目标元素小，当前列就不可能存在目标值，“指针”就向右移一格（纵坐标加 $1$）；<br>如果当前数比目标元素大，当前行就不可能存在目标值，“指针”就向上移一格（横坐标减 $1$）。</p><p>在编码的过程中要注意数组下标越界的问题。</p><p><strong>参考代码</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def searchMatrix(self, matrix, target):        # 特判        rows = len(matrix)        if rows == 0:            return False        cols = len(matrix[0])        if cols == 0:            return False        # 起点：左下角        x = rows - 1        y = 0        # 不越界的条件是：行大于等于 0，列小于等于 cols - 1        while x >= 0 and y < cols:            if matrix[x][y] > target:                x -= 1            elif matrix[x][y] < target:                y += 1            else:                return True        return False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public boolean searchMatrix(int[][] matrix, int target) {        int rows = matrix.length;        if (rows == 0) {            return false;        }        int cols = matrix[0].length;        if (cols == 0) {            return false;        }        // 起点：左下角        int x = rows - 1;        int y = 0;        // 不越界的条件是：行大于等于 0，列小于等于 cols - 1        while (x >= 0 && y < cols) {            // 打开注释，可以用于调试的代码            // System.out.println("沿途走过的数字：" + matrix[x][y]);            if (matrix[x][y] > target) {                x--;            } else if (matrix[x][y] < target) {                y++;            } else {                return true;            }        }        return false;    }    public static void main(String[] args) {        int[][] matrix = {                {1, 4, 7, 11, 15},                {2, 5, 8, 12, 19},                {3, 6, 9, 16, 22},                {10, 13, 14, 17, 24},                {18, 21, 23, 26, 30}        };        int target = 12;        Solution solution = new Solution();        boolean searchMatrix = solution3.searchMatrix(matrix, target);        System.out.println(searchMatrix);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(M + N)$，$M$ 是这个矩阵的行数，$N$ 是这个矩阵的列数，我们看到，这种算法是“不回头”的，至多走 $M + N$ 步就能搜索到目标数值，或者判定目标数值在矩阵中不存子啊。</li><li>空间复杂度：$O(1)，算法使用了常数个变量$。</li></ul><p>2、如果选择右上角为起点</p><p>可以绘图如下：</p><p><img src="https://pic.leetcode-cn.com/939fa5d769027cfd688b84423dbf93ec5696774dc576bf286c2267ea3c17a230-0240-top-right-corner.gif" alt="0240-top-right-corner.gif"></p><p>总结出“搜索”的规律是：</p><p>如果当前数比目标元素大，当前列就不可能存在目标值，“指针”就向左移一格（纵坐标减 $1$）；<br>如果当前数比目标元素小，当前行就不可能存在目标值，“指针”就向下移一格（横坐标加 $1$）。</p><p>在编码的过程中同样要注意数组下标越界的问题。</p><p><strong>参考代码</strong>：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def searchMatrix(self, matrix, target):        # 特判        rows = len(matrix)        if rows == 0:            return False        cols = len(matrix[0])        if cols == 0:            return False        # 起点：右上        x = 0        y = cols -1        # 不越界的条件是：行小于等于 rows - 1，列大于等于 0        while x < rows and y >= 0:            if matrix[x][y] > target:                y -= 1            elif matrix[x][y] < target:                x += 1            else:                return True        return False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public boolean searchMatrix(int[][] matrix, int target) {        // 特判        int rows = matrix.length;        if (rows == 0) {            return false;        }        int cols = matrix[0].length;        if (cols == 0) {            return false;        }        // 起点：右上角        int x = 0;        int y = cols - 1;        // 不越界的条件是：行小于等于 rows - 1，列大于等于 0        while (x < rows && y >= 0) {            // 打开注释，可以用于调试的代码            // System.out.println("沿途走过的数字：" + matrix[x][y]);            if (matrix[x][y] > target) {                y--;            } else if (matrix[x][y] < target) {                x++;            } else {                return true;            }        }        return false;    }    public static void main(String[] args) {        int[][] matrix = {                {1, 4, 7, 11, 15},                {2, 5, 8, 12, 19},                {3, 6, 9, 16, 22},                {10, 13, 14, 17, 24},                {18, 21, 23, 26, 30}        };        int target = 10;        Solution solution = new Solution();        boolean searchMatrix = solution2.searchMatrix(matrix, target);        System.out.println(searchMatrix);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><p>（同上）。</p><p>说明：这个搜索的过程也可以使用二分查找法加快，时间复杂度收缩到 $O(\log M + long N) = O(\log MN)$，但是在编码的时候会稍显麻烦，还要考虑一些边界条件，我就不展示自己写的又臭又长的代码了。如果大家有更优雅的写法，欢迎分享出来。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 13： 分治算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 109 题：有序链表转换二叉搜索树</title>
      <link href="/leetcode-algo/2018/01/04/leetcode-algo/0109-convert-sorted-list-to-binary-search-tree/"/>
      <url>/leetcode-algo/2018/01/04/leetcode-algo/0109-convert-sorted-list-to-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-109-题：有序链表转换二叉搜索树"><a href="#「力扣」第-109-题：有序链表转换二叉搜索树" class="headerlink" title="「力扣」第 109 题：有序链表转换二叉搜索树"></a>「力扣」第 109 题：有序链表转换二叉搜索树</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/fen-zhi-fa-python-dai-ma-java-dai-ma-by-liweiwei14/" target="_blank" rel="noopener">分治法（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a>。</p><blockquote><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定的有序链表： [-10, -3, 0, 5, 9],</p><p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p><pre><code>  0 / \</code></pre><p>   -3   9<br>   /   /<br> -10  5</p></blockquote><h2 id="分治法（Python-代码、Java-代码）"><a href="#分治法（Python-代码、Java-代码）" class="headerlink" title="分治法（Python 代码、Java 代码）"></a>分治法（Python 代码、Java 代码）</h2><p><strong>思路分析</strong>：</p><p>思路其实<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/you-xu-lian-biao-zhuan-huan-er-cha-sou-suo-shu-by-/" target="_blank" rel="noopener">官方题解</a>已经写得非常清楚了，建议看看其中的动画，生动形象。</p><p>在这里主要想说二叉树的很多问题基本上都可以通过“分而治之”的策略完成。这里首先找到<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/submissions/" target="_blank" rel="noopener">单链表的中间结点</a>，然后递归构造左子树和右子树。还有一种做法是把单链表变成有序数组，这就是 <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">「力扣」第 108 题：将有序数组转换为二叉搜索树</a>。</p><p>编码的细节已经体现在代码注释中。</p><p><strong>参考代码</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def sortedListToBST(self, head: ListNode) -> TreeNode:        # 特判：当结点为空，或者单结点的时候的简单逻辑        if head is None:            return None        if head.next is None:            return TreeNode(head.val)        # 设置 pre 指针是为了切断单链表 mid 的前半部分        pre = None        slow = head        fast = head        # 如果写 while fast and fast.next: 后面的代码稍有不同        while fast.next and fast.next.next:            pre = slow            slow = slow.next            fast = fast.next.next        # 此时 slow 结点就位于链表的中部，        # 它的值就作为 BST 的根结点返回        root = TreeNode(slow.val)        # 因为要传入下一个递归方法，所以得先保存索引        new_head = slow.next        slow.next = None        # 当链表只有 2 个结点的时候，pre 指针此时为 None，不用递归构造左子树        if pre:            pre.next = None            root.left = self.sortedListToBST(head)        root.right = self.sortedListToBST(new_head)        return root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">class ListNode {    int val;    ListNode next;    ListNode(int x) {        val = x;    }}class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) {        val = x;    }}public class Solution {    public TreeNode sortedListToBST(ListNode head) {        // 特判：当结点为空，或者单结点的时候的简单逻辑        if (head == null) {            return null;        }        if (head.next == null) {            return new TreeNode(head.val);        }        // 设置 pre 指针是为了切断单链表 mid 的前半部分        ListNode pre = null;        ListNode slow = head;        ListNode fast = head;        // 如果写 while fast and fast.next: 后面的代码稍有不同        while (fast.next != null && fast.next.next != null) {            pre = slow;            slow = slow.next;            fast = fast.next.next;        }        // 此时 slow 结点就位于链表的中部，        // 它的值就作为 BST 的根结点返回        TreeNode root = new TreeNode(slow.val);        // 因为要传入下一个递归方法，所以得先保存索引        ListNode newHead = slow.next;        slow.next = null;        // 当链表只有 2 个结点的时候，pre 指针此时为 null，不用递归构造左子树        if(pre != null){            pre.next = null;            root.left = sortedListToBST(head);        }        root.right = sortedListToBST(newHead);        return root;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><Vssue title="convert-sorted-list-to-binary-search-tree"/>]]></content>
      
      
      <categories>
          
          <category> 专题 13： 分治算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 106 题：从中序与后序遍历序列构造二叉树</title>
      <link href="/leetcode-algo/2018/01/03/leetcode-algo/0106-construct-binary-tree-from-inorder-and-postorder-traversal/"/>
      <url>/leetcode-algo/2018/01/03/leetcode-algo/0106-construct-binary-tree-from-inorder-and-postorder-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-106-题：从中序与后序遍历序列构造二叉树"><a href="#「力扣」第-106-题：从中序与后序遍历序列构造二叉树" class="headerlink" title="「力扣」第 106 题：从中序与后序遍历序列构造二叉树"></a>「力扣」第 106 题：从中序与后序遍历序列构造二叉树</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/hou-xu-bian-li-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">分治法（Python、Java）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a>。</p><blockquote><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p></blockquote><h2 id="分治法（Python、Java）"><a href="#分治法（Python、Java）" class="headerlink" title="分治法（Python、Java）"></a>分治法（Python、Java）</h2><p><strong>思路分析</strong>：</p><p>二叉树相关的很多问题的解决思路都有分治法的思想在里面。</p><p>复习一下分治法的思想：<strong>把原问题拆解成若干个与原问题结构相同但规模更小的子问题，待子问题解决以后，原问题就得以解决</strong>，“归并排序” 和 “快速排序” 都是分治法思想的应用，其中 “归并排序” 先无脑地“分”，在 “合” 的时候就麻烦一些；“快速排序” 开始在 partition 上花了很多时间，即在 “分” 上使了很多劲，然后就递归处理下去就好了，没有在 “合” 上再花时间。</p><p>以题目中给出的例子为例，讲解如何构建二叉树。</p><blockquote><p>中序遍历 <code>inorder = [9,3,15,20,7]</code><br>后序遍历 <code>postorder = [9,15,7,20,3]</code></p></blockquote><p><img src="https://pic.leetcode-cn.com/40c56ab66dc7288be11bc93fe9e31fd05daf6d6377fae8d1aa11054a67b4d62f-106-1.png" alt="106-1.png"></p><p>图画完以后才发现这个例子不太好，数组长度多一些就能把思路展现得更清楚了，各位客官老爷将就看一下啦。或者可以看一下我写的「力扣」第 105 题的题解<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/" target="_blank" rel="noopener">《分治法（Python 代码、Java 代码）》</a>，两道问题的解法是一样的。</p><p><strong>注意</strong>：这道问题其实并不难，我们在草稿纸上写写画画，就能把思路想清楚，但是在编码上会有一些小陷阱，在计算索引边界值要认真一些。</p><p>下面给出两种写法，区别在于空间复杂度：</p><h3 id="方法一：在递归方法中，传入数组的拷贝（了解，不推荐）"><a href="#方法一：在递归方法中，传入数组的拷贝（了解，不推荐）" class="headerlink" title="方法一：在递归方法中，传入数组的拷贝（了解，不推荐）"></a>方法一：在递归方法中，传入数组的拷贝（了解，不推荐）</h3><p>该方法在计算索引的时候会稍微容易一些。</p><p><strong>参考代码 1</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:        assert len(inorder) == len(postorder)        if len(inorder) == 0:            return None        if len(inorder) == 1:            # 这里要返回结点，而不是返回具体的数            return TreeNode(inorder[0])        # 后序遍历的最后一个结点就是根结点        root = TreeNode(postorder[-1])        # 在中序遍历中找到根结点的索引，得到左右子树的一个划分        pos = inorder.index(postorder[-1])        # 这里的列表切片使用的是复制值，使用了一些空间，因此空间复杂度是 O(N)        root.left = self.buildTree(inorder[:pos], postorder[:pos])        root.right = self.buildTree(inorder[pos + 1:], postorder[pos:-1])        return root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Arrays;class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) {        val = x;    }}public class Solution {    /**     * @param inorder   中序遍历序列     * @param postorder 后序遍历序列     * @return     */    public TreeNode buildTree(int[] inorder, int[] postorder) {        int inlen = inorder.length;        int postlen = postorder.length;        assert inlen == postlen;        if (inlen == 0) {            return null;        }        if (inlen == 1) {            return new TreeNode(inorder[0]);        }        // 后序遍历的最后一个结点就是根结点        int rootVal = postorder[postlen - 1];        // 在中序遍历中找到根结点的索引，得到左右子树的一个划分        int dividePoint = 0;        for (int i = 0; i < inlen; i++) {            if (inorder[i] == rootVal) {                dividePoint = i;                break;            }        }        TreeNode rootNode = new TreeNode(rootVal);        // Arrays.copyOfRange() 方法的第 1 个参数是源数组        // 第 2 个参数是源数组的起始位置（可以取到）        // 第 3 个参数是源数组的起始位置（不可以取到）        // 这里复制了数组，使用了一些空间，因此空间复杂度是 O(N)        rootNode.left = buildTree(Arrays.copyOfRange(inorder, 0, dividePoint), Arrays.copyOfRange(postorder, 0, dividePoint));        rootNode.right = buildTree(Arrays.copyOfRange(inorder, dividePoint + 1, inlen), Arrays.copyOfRange(postorder, dividePoint, postlen - 1));        return rootNode;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N \log N)$，这里 $N$ 是二叉树的结点个数，算法中每个结点都会被看到一次，是线性级别的，递归的深度是对数级别的，因此时间复杂度是 $O(N \log N)$。</li><li>空间复杂度：$O(N)$，构造一棵树需要 $N$ 个结点（待讨论）。</li></ul><h3 id="方法二：在递归方法中，传入子数组的边界索引"><a href="#方法二：在递归方法中，传入子数组的边界索引" class="headerlink" title="方法二：在递归方法中，传入子数组的边界索引"></a>方法二：在递归方法中，传入子数组的边界索引</h3><p><strong>注意</strong>：在递归方法中，有一个数组的边界索引，得通过计算得到，计算的依据是递归方法传入的“中序遍历数组”（的子数组）和“后序遍历数组”（的子数组）的长度是一样的。我的办法是解方程计算未知数，哈哈，傻呼呼的。具体需要计算哪个参数我在下面的代码中已经注明了。</p><p><strong>参考代码 2</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def __init__(self):        self.inorder = None        self.postorder = None    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:        assert len(inorder) == len(postorder)        size = len(inorder)        self.inorder = inorder        self.postorder = postorder        return self.__dfs(0, size - 1, 0, size - 1)    def __dfs(self, in_l, in_r, post_l, post_r):        if in_l > in_r or post_l > post_r:            return None        val = self.postorder[post_r]        # 后序遍历的最后一个结点就是根结点        root = TreeNode(val)        # 在中序遍历中找到根结点的索引，得到左右子树的一个划分        pos = self.inorder.index(val)        # 注意：第 4 个参数是计算出来的，依据：两边区间长度相等        root.left = self.__dfs(in_l, pos - 1, post_l, pos - 1 - in_l + post_l)        # 注意：第 3 个参数是计算出来的，依据：两边区间长度相等        root.right = self.__dfs(pos + 1, in_r, post_r - in_r + pos, post_r - 1)        return root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) {        val = x;    }}public class Solution {    private int[] inorder;    private int[] postorder;    public TreeNode buildTree(int[] inorder, int[] postorder) {        this.inorder = inorder;        this.postorder = postorder;        int len = inorder.length;        return dfs(0, len - 1, 0, len - 1);    }    private TreeNode dfs(int inl, int inr, int postl, int postr) {        if (inl > inr || postl > postr) {            return null;        }        int val = postorder[postr];        int k = 0;        for (int i = inl; i < inr + 1; i++) {            if (inorder[i] == val) {                k = i;                break;            }        }        TreeNode root = new TreeNode(val);        // 注意：第 4 个参数是计算出来的，依据：两边区间长度相等        root.left = dfs(inl, k - 1, postl, k - 1 - inl + postl);        // 注意：第 3 个参数是计算出来的，依据：两边区间长度相等        root.right = dfs(k + 1, inr, postr + k - inr, postr - 1);        return root;    }    public static void main(String[] args) {        int[] inorder = {1, 3, 2};        int[] postorder = {3, 2, 1};        Solution solution = new Solution();        TreeNode res = solution.buildTree(inorder, postorder);        System.out.println(res);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N \log N)$，这里 $N$ 是二叉树的结点个数，算法中每个结点都会被看到一次，是线性级别的，递归的深度是对数级别的，因此时间复杂度是 $O(N \log N)$。</li><li>空间复杂度：$O(N)$，构造一棵树需要 $N$ 个结点（待讨论）。</li></ul><Vssue title="construct-binary-tree-from-inorder-and-postorder-traversal"/>]]></content>
      
      
      <categories>
          
          <category> 专题 13： 分治算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 105 题：从前序与中序遍历序列构造二叉树</title>
      <link href="/leetcode-algo/2018/01/02/leetcode-algo/0105-construct-binary-tree-from-preorder-and-inorder-traversal/"/>
      <url>/leetcode-algo/2018/01/02/leetcode-algo/0105-construct-binary-tree-from-preorder-and-inorder-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-105-题：从前序与中序遍历序列构造二叉树"><a href="#「力扣」第-105-题：从前序与中序遍历序列构造二叉树" class="headerlink" title="「力扣」第 105 题：从前序与中序遍历序列构造二叉树"></a>「力扣」第 105 题：从前序与中序遍历序列构造二叉树</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/qian-xu-bian-li-python-dai-ma-java-dai-ma-by-liwei/" target="_blank" rel="noopener">分治法（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a>。</p><blockquote><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p><p>   3<br>  / <br> 9  20<br>   /  <br>  15   7</p></blockquote><h2 id="分治法（Python-代码、Java-代码）"><a href="#分治法（Python-代码、Java-代码）" class="headerlink" title="分治法（Python 代码、Java 代码）"></a>分治法（Python 代码、Java 代码）</h2><p><strong>思路分析</strong>：</p><p>二叉树相关的很多问题的解决思路都有分治法的思想在里面。我们复习一下分治法的思想：<strong>把原问题拆解成若干个与原问题结构相同但规模更小的子问题，待子问题解决以后，原问题就得以解决</strong>，“归并排序”和“快速排序”都是分治法思想的应用，其中“归并排序”先无脑地“分”，在“合”的时候就麻烦一些；“快速排序”开始在 partition 上花了很多时间，即在“分”上使了很多劲，然后就递归处理下去就好了，没有在“合”上再花时间。</p><p>抓住“前序遍历的第 1 个元素一定是二叉树的根结点”，不难写出代码。关键还是拿 LeetCode 上面的例子画一个图，思路就很清晰了。</p><p>前序遍历数组的第 $1$ 个数（索引为 $0$）的数一定是二叉树的根结点，于是可以在中序遍历中找这个根结点的索引，然后把“前序遍历数组”和“中序遍历数组”分为两个部分，就分别对应二叉树的左子树和右子树，分别递归完成就可以了。</p><p><img src="https://pic.leetcode-cn.com/fe215cdc993b06a2eeca7939ac04d370f3fe725e7e568e6ced17d1757020be9f-105-1.png" alt="105-1.png"></p><p>这道题完成了以后可以顺便把 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">「力扣」 第 106 题：从中序与后序遍历序列构造二叉树</a>也一起做了，加油加油！</p><p><strong>参考代码</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class TreeNode(object):    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution(object):    def buildTree(self, preorder, inorder):        plen = len(preorder)        ilen = len(inorder)        return self.__helper(preorder, 0, plen - 1, inorder, 0, ilen - 1)    def __helper(self, preorder, prel, prer,                 inorder, inl, inr):        if prel > prer:            return None        root_val = preorder[prel]        l = inl        while l < inr and inorder[l] != root_val:            l += 1        # 走到这里 inorder[l] == root 为 True        root_node = TreeNode(root_val)        root_node.left = self.__helper(preorder, prel + 1, prel + l - inl,                                       inorder, inl, l - 1)        root_node.right = self.__helper(preorder, prel + l - inl + 1, prer,                                        inorder, l + 1, inr)        return root_node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) {        val = x;    }}public class Solution {    // 使用前序遍历和中序遍历构建二叉树    // 举出具体例子来分析就会很清晰，这里一定要分析清楚索引的起始    // 例如：    // pre: A B D E H I C F K G    // in : D B H E I A F K C G    public TreeNode buildTree(int[] preorder, int[] inorder) {        int preLen = preorder.length;        int inLen = inorder.length;        return helper(preorder, 0, preLen - 1, inorder, 0, inLen - 1);    }    private TreeNode helper(int[] preorder,                            int preL, int preR,                            int[] inorder,                            int inL, int inR) {        if (preL > preR || inL > inR) {            return null;        }        int rootVal = preorder[preL];        int l = inL;        while (l <= inR && inorder[l] != rootVal) {            l++;        }        TreeNode root = new TreeNode(rootVal);        root.left = helper(preorder, preL + 1, preL + l - inL, inorder, inL, l - 1);        root.right = helper(preorder, preL + l - inL + 1, preR, inorder, l + 1, inR);        return root;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N)$，这里 $N$ 是二叉树的结点个数。</li><li>空间复杂度：$O(N)$。</li></ul><Vssue title="construct-binary-tree-from-preorder-and-inorder-traversal"/>]]></content>
      
      
      <categories>
          
          <category> 专题 13： 分治算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「分治算法」专题：概述与经典问题</title>
      <link href="/leetcode-algo/2018/01/01/leetcode-tag/divide-and-conquer/"/>
      <url>/leetcode-algo/2018/01/01/leetcode-tag/divide-and-conquer/</url>
      
        <content type="html"><![CDATA[<h1 id="「分治算法」专题：概述与经典问题"><a href="#「分治算法」专题：概述与经典问题" class="headerlink" title="「分治算法」专题：概述与经典问题"></a>「分治算法」专题：概述与经典问题</h1><hr><p>（占位，以后再补充。）</p><h3 id="「力扣」第-53-题：连续子数组的最大和"><a href="#「力扣」第-53-题：连续子数组的最大和" class="headerlink" title="「力扣」第 53 题：连续子数组的最大和"></a>「力扣」第 53 题：连续子数组的最大和</h3><p>参考资料：<a href="https://www.zybuluo.com/liweiwei1419/note/1394321" target="_blank" rel="noopener">LeetCode 第 53 题：连续子数组的最大和</a>。</p><p>要做第 95 题，得先完成第 96 题。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 13： 分治算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「树」专题 6：二分搜索树中的问题</title>
      <link href="/leetcode-algo/2017/11/21/leetcode-solution/binary-tree-6/"/>
      <url>/leetcode-algo/2017/11/21/leetcode-solution/binary-tree-6/</url>
      
        <content type="html"><![CDATA[<h2 id="「树」专题-6：二分搜索树中的问题"><a href="#「树」专题-6：二分搜索树中的问题" class="headerlink" title="「树」专题 6：二分搜索树中的问题"></a>「树」专题 6：二分搜索树中的问题</h2><h3 id="回顾二分搜索树的定义"><a href="#回顾二分搜索树的定义" class="headerlink" title="回顾二分搜索树的定义"></a>回顾二分搜索树的定义</h3><h3 id="二分搜索树的重要性质"><a href="#二分搜索树的重要性质" class="headerlink" title="二分搜索树的重要性质"></a>二分搜索树的重要性质</h3><p>二分搜索树的重要性质如下，初学的时候经常会被忽略或者错误地理解：</p><ul><li>左子树中所有的结点<strong>都小于</strong>当前结点；</li><li>右子树中所有的结点<strong>都大于</strong>当前结点。</li><li>以左右孩子为根的子树仍为二分搜索树。</li></ul><h3 id="回顾二分搜索树中的基本操作"><a href="#回顾二分搜索树中的基本操作" class="headerlink" title="回顾二分搜索树中的基本操作"></a>回顾二分搜索树中的基本操作</h3><p>既然学习到这个专题，我们就有必要来复习巩固之前在学习《二分搜索树》的时候所进行的一些基本操作，这些操作都是十分重要而且基础的。由于二分搜索树的性质，我们总能以 $O(logn)$ 时间复杂度来完成上面的操作。</p><p>1、插入 insert</p><p>2、查找 find</p><p>3、删除 delete</p><p>4、最大值，最小值 minimum, maximum</p><p>5、前驱，后继 successor, predecessor</p><p>6、上界，下界 floor, ceil</p><p>7、某个元素的排名 rank</p><p>8、寻找第 k大（小）元素 select</p><p>9、如何将二分搜索树改造成平衡搜索树，平衡搜索树的一个重要应用就是红黑树。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 12：树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「树」专题 5：稍复杂的递归逻辑 Path Sum III</title>
      <link href="/leetcode-algo/2017/11/20/leetcode-solution/binary-tree-5/"/>
      <url>/leetcode-algo/2017/11/20/leetcode-solution/binary-tree-5/</url>
      
        <content type="html"><![CDATA[<h2 id="「树」专题-5：稍复杂的递归逻辑-Path-Sum-III"><a href="#「树」专题-5：稍复杂的递归逻辑-Path-Sum-III" class="headerlink" title="「树」专题 5：稍复杂的递归逻辑 Path Sum III"></a>「树」专题 5：稍复杂的递归逻辑 Path Sum III</h2>]]></content>
      
      
      <categories>
          
          <category> 专题 12：树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「树」专题 4：如何使用递归函数的返回值</title>
      <link href="/leetcode-algo/2017/11/19/leetcode-solution/binary-tree-4/"/>
      <url>/leetcode-algo/2017/11/19/leetcode-solution/binary-tree-4/</url>
      
        <content type="html"><![CDATA[<h2 id="「树」专题-4：如何使用递归函数的返回值"><a href="#「树」专题-4：如何使用递归函数的返回值" class="headerlink" title="「树」专题 4：如何使用递归函数的返回值"></a>「树」专题 4：如何使用递归函数的返回值</h2>]]></content>
      
      
      <categories>
          
          <category> 专题 12：树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「树」专题 3：注意递归的终止条件</title>
      <link href="/leetcode-algo/2017/11/18/leetcode-solution/binary-tree-3/"/>
      <url>/leetcode-algo/2017/11/18/leetcode-solution/binary-tree-3/</url>
      
        <content type="html"><![CDATA[<h2 id="「树」专题-3：注意递归的终止条件"><a href="#「树」专题-3：注意递归的终止条件" class="headerlink" title="「树」专题 3：注意递归的终止条件"></a>「树」专题 3：注意递归的终止条件</h2>]]></content>
      
      
      <categories>
          
          <category> 专题 12：树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「二叉树」专题 2：反转一棵二叉树</title>
      <link href="/leetcode-algo/2017/11/17/leetcode-solution/binary-tree-2/"/>
      <url>/leetcode-algo/2017/11/17/leetcode-solution/binary-tree-2/</url>
      
        <content type="html"><![CDATA[<h2 id="「二叉树」专题-2：反转一棵二叉树"><a href="#「二叉树」专题-2：反转一棵二叉树" class="headerlink" title="「二叉树」专题 2：反转一棵二叉树"></a>「二叉树」专题 2：反转一棵二叉树</h2><p>注：这一节练习 3 和练习 4 都是很经典的问题。</p><p>和二叉树相关的问题，在面试中是非常常见的。一旦我们熟悉了这些问题以后，会发现这些问题其实是非常简单的。</p><h3 id="「力扣」第-226-题：反转一棵二叉树"><a href="#「力扣」第-226-题：反转一棵二叉树" class="headerlink" title="「力扣」第 226 题：反转一棵二叉树"></a>「力扣」第 226 题：反转一棵二叉树</h3><ul><li><p>中文网址：<a href="https://leetcode-cn.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">226. 翻转二叉树</a> ；</p></li><li><p>英文网址：<a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">226. Invert Binary Tree</a> 。</p></li></ul><blockquote><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><pre><code>4/   \2     7/ \   / \1   3 6   9</code></pre><p>输出：</p><pre><code>4/   \7     2/ \   / \9   6 3   1</code></pre><p><strong>备注:</strong><br>这个问题是受到 <a href="https://twitter.com/mxcl" target="_blank" rel="noopener">Max Howell </a>的 <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="noopener">原问题</a> 启发的 ：</p><blockquote><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p></blockquote></blockquote><p>分析：算法是非常重要的基本功。即使是大公司都非常注重基础问题的考察。</p><p>这道问题可以说是一个经典的问题。LeetCode 上有如下备注：</p><blockquote><p>这个问题是受到 Max Howell 的 原问题 启发的 ：</p><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p></blockquote><p>思路1：我们可以使用递归方法来完成，我们写好之后，会发现其实就是完成了一次深度优先遍历，并且是前序遍历，有的朋友可能写出来的后序遍历，那么我们不禁要问，中序遍历可不可以，答案是不可以，因为中序遍历很可能一个结点会被翻转两次，这与我们的要求是违背的。</p><p>Java 代码：</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/226-1.jpg" alt="LeetCode 第 226 题：反转一棵二叉树"></p><p>Java 代码：后序遍历</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// swap root.left 和  root.right</span>        TreeNode temp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：与上面的代码等价</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        TreeNode right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法一：前序遍历"><a href="#方法一：前序遍历" class="headerlink" title="方法一：前序遍历"></a>方法一：前序遍历</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 左子树和右子树交换，即使左右子树都空也不影响正确性</span>        TreeNode temp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 递归翻转左右子树</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：中序遍历"><a href="#方法二：中序遍历" class="headerlink" title="方法二：中序遍历"></a>方法二：中序遍历</h3><p><strong>注意</strong>：写中序遍历的时候，不能仅仅只是将前序遍历的代码顺序调整一下。</p><p>因为在“中序遍历”的时候，左右子树已经交换过了，因此原来写 <code>invertTree(root.right);</code> 的地方，应该写作 <code>invertTree(root.left);</code>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode temp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意：因为左右子树已经交换了，因此这里不能写 invertTree(root.right);</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三：后序遍历"><a href="#方法三：后序遍历" class="headerlink" title="方法三：后序遍历"></a>方法三：后序遍历</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode temp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法四：层序遍历"><a href="#方法四：层序遍历" class="headerlink" title="方法四：层序遍历"></a>方法四：层序遍历</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Queue<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 结点为空的特殊情况要先考虑</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            TreeNode curNode <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 只要其中之一非空，我都交换，并且把非空的结点添加到队列里</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">||</span> curNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 先翻转</span>                TreeNode temp <span class="token operator">=</span> curNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                curNode<span class="token punctuation">.</span>left <span class="token operator">=</span> curNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                curNode<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 把非空的节点加入队列</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://upload-images.jianshu.io/upload_images/414598-3188d0a8a664c517.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20181214103339221"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 12：树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「树」专题 1：树与递归</title>
      <link href="/leetcode-algo/2017/11/16/leetcode-solution/binary-tree-1/"/>
      <url>/leetcode-algo/2017/11/16/leetcode-solution/binary-tree-1/</url>
      
        <content type="html"><![CDATA[<h2 id="「树」专题-1：树与递归"><a href="#「树」专题-1：树与递归" class="headerlink" title="「树」专题 1：树与递归"></a>「树」专题 1：树与递归</h2><ul><li>树是理解「递归」和「分治」算法的很好的数据结构；</li><li>很多高级数据结构都是从「树」来的。</li></ul><p>我们开始介绍「二叉树和递归」。递归，是使用计算机解决问题的一种重要的思考方式。而二叉树由于其天然的递归结构，使得基于二叉树的算法，均拥有着递归性质。使用二叉树，是研究学习递归算法的最佳入门方式。在这一章里，我们就来看一看二叉树中的递归算法。</p><p>在前面知识的学习中，我们看到了在基础算法以及系统设计中都用到了递归。深度优先遍历中也用到了递归。从这一部分开始，我们从另一个视角看递归。</p><h3 id="从二叉树的角度看递归"><a href="#从二叉树的角度看递归" class="headerlink" title="从二叉树的角度看递归"></a>从二叉树的角度看递归</h3><p>二叉树天然具有递归的性质。二叉树的定义就是用二叉树定义二叉树。对于二叉树的定义来说，应该补充一点：空是一棵二叉树。</p><p>下面，我们来观察一个二叉树的前序遍历的递归方法。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这里 <code>System.out.print(node.val);</code> 这一行代码表示“处理这个结点的逻辑”。</p><p>在这里，我们先强调编写递归函数的第 1 个注意事项：首先明确这个函数要表达的任务（逻辑），明确参数的定义和返回值的意义。</p><p>接下来，我们将上面的代码改造一下。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 先写递归终止条件</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 再写递归过程</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preorder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实这样的写法更像递归结构，因为对于我们定义的每一个递归函数来说，应该包含下面两个部分：1、<strong>递归终止条件</strong>；2、设立<strong>递归过程</strong>，定义清楚函数的语义。</p><p>这就是我们编写一个递归函数应该注意的第 2 件事情。</p><p>接下来，我们再看一个方法：在一个二叉树中查看是否存在一个键值。写这个递归方法的步骤：想想（1）递归终止条件是什么？（2）递归过程是什么？参数 Node node 是什么意思？我们这里定义的参数 Node 对象，是在以 node 为根结点的二叉树中寻找指定的 key。于是，我们的逻辑是：如果 node 本身不是我们要找的结点的话，我们继续在 node 的左孩子和右孩子中继续查找。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contain</span><span class="token punctuation">(</span>Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先我们要处理递归到底的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">contain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">contain</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么，我们可以再想想如何释放以 Node 为根结点的二叉树？</p>]]></content>
      
      
      <categories>
          
          <category> 专题 12：树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 1319 题：等式方程的可满足性</title>
      <link href="/leetcode-algo/2017/11/04/leetcode-algo/0990-satisfiability-of-equality-equations/"/>
      <url>/leetcode-algo/2017/11/04/leetcode-algo/0990-satisfiability-of-equality-equations/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-1319-题：连通网络的操作次数"><a href="#「力扣」第-1319-题：连通网络的操作次数" class="headerlink" title="「力扣」第 1319 题：连通网络的操作次数"></a>「力扣」第 1319 题：连通网络的操作次数</h2><blockquote><p>连通性问题，比较容易想到使用并查集，并查集在写的时候，可以尽量封装起来，以凸显主干逻辑。并且路径压缩与按 <code>rank</code> 合并这两个优化技巧，选择其中一个即可。</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/solution/bing-cha-ji-by-liweiwei1419/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>用以太网线缆将 <code>n</code> 台计算机连接成一个网络，计算机的编号从 <code>0</code> 到 <code>n-1</code>。线缆用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 连接了计算机 <code>a</code> 和 <code>b</code>。</p><p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p><p>给你这个计算机网络的初始布线 <code>connections</code>，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png" alt="img"></p><pre><code>输入：n = 4, connections = [[0,1],[0,2],[1,2]]输出：1解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_2_1677.png" alt="img"></p><pre><code>输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]输出：2</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]输出：-1解释：线缆数量不足。</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]输出：0</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5)</code></li><li><code>connections[i].length == 2</code></li><li><code>0 &lt;= connections[i][0], connections[i][1] &lt; n</code></li><li><code>connections[i][0] != connections[i][1]</code></li><li>没有重复的连接。</li><li>两台计算机不会通过多条线缆连接。</li></ul></blockquote><p>思路：</p><ul><li>记录一个变量，表示多余的边；</li><li>在合并的时候，返回是否合并成功。如果合并不成功，表示在一个连通分量里，这条边是多余的边（用于以后连接独立的连通分量）；</li><li>如果多余的边不够剩余的连通分量个数，返回 -1；如果够用，每用一条边都可以减少一个连通分量的个数；</li><li>否则多余的边数够用，返回连通分量 -1 即可（减去的这个 1 是最大的那个连通分量）。</li></ul><p><strong>参考代码</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    private class UnionFind {        /**         * 父亲结点标识数组         */        private int[] parent;        /**         * 连通分量个数         */        private int count;        public UnionFind(int n) {            count = n;            parent = new int[n];            for (int i = 0; i < n; i++) {                parent[i] = i;            }        }        public int find(int x) {            while (x != parent[x]) {                // 路径压缩（隔代压缩）                parent[x] = parent[parent[x]];                x = parent[x];            }            return x;        }        /**         * @param x         * @param y         * @return 是否合并成功，如果 x 和 y 本来就在一个连通分量里，返回 false         */        public boolean union(int x, int y) {            int rootX = find(x);            int rootY = find(y);            if (rootX == rootY) {                return false;            }            parent[rootX] = rootY;            count--;            return true;        }    }    public int makeConnected(int n, int[][] connections) {        // 特判        if (connections.length < n - 1) {            return -1;        }        UnionFind unionFind = new UnionFind(n);        // 多余的边的条数        int cnt = 0;        for (int[] connection : connections) {            boolean success = unionFind.union(connection[0], connection[1]);            if (!success) {                cnt++;            }        }        // 特判        if (unionFind.count == 1) {            return 0;        }        // 扣掉的 1 是当前结点数最大的连通分量        if (cnt < unionFind.count - 1) {            return -1;        }        return unionFind.count - 1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 990 题：等式方程的可满足性</title>
      <link href="/leetcode-algo/2017/11/03/leetcode-algo/0990-satisfiability-of-equality-equations/"/>
      <url>/leetcode-algo/2017/11/03/leetcode-algo/0990-satisfiability-of-equality-equations/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-990-题：等式方程的可满足性"><a href="#「力扣」第-990-题：等式方程的可满足性" class="headerlink" title="「力扣」第 990 题：等式方程的可满足性"></a>「力扣」第 990 题：等式方程的可满足性</h2><blockquote><p>有些问题不以并查集为背景，但的确可以使用并查集的知识帮助我们解决问题。由于等式相等具有传递性，比较容易想到使用并查集。</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/solution/shi-yong-bing-cha-ji-chu-li-bu-xiang-jiao-ji-he-we/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p><p><strong>示例 1：</strong></p><pre><code>输入：[&quot;a==b&quot;,&quot;b!=a&quot;]输出：false解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</code></pre><p><strong>示例 2：</strong></p><pre><code>输出：[&quot;b==a&quot;,&quot;a==b&quot;]输入：true解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]输出：true</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]输出：false</code></pre><p><strong>示例 5：</strong></p><pre><code>输入：[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]输出：true</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= equations.length &lt;= 500</code></li><li><code>equations[i].length == 4</code></li><li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li><li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li><li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li></ol></blockquote><p>题目给我们一系列等式和不等式，然后问我们这些等式和不等式组成的变量之间的关系是否有冲突，如果没有冲突，说明等式和不等式的关系是正确的，返回 <code>true</code> ，否则返回 <code>false</code>。</p><p>由于等式相等具有传递性，所有相等的变量属于一个集合，比较容易想到使用并查集，因为并查集其实主要是就是在解决在不在一个集合中的问题。</p><p>为此设计算法如下：</p><p>1、扫描所有等式，将等式两边的顶点进行合并；</p><p>2、再扫描所有不等式，<strong>检查</strong>每一个不等式的两个顶点是不是在一个连通分量里，如果在，则返回 <code>false</code> 表示等式方程有矛盾。如果所有检查都没有矛盾，返回 <code>true</code>。</p><p><strong>参考代码</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    private class UnionFind {        private int[] parent;        public UnionFind(int n) {            parent = new int[n];            for (int i = 0; i < n; i++) {                parent[i] = i;            }        }        public int find(int x) {            while (x != parent[x]) {                parent[x] = parent[parent[x]];                x = parent[x];            }            return x;        }        /**         * @param x         * @param y         * @return 如果合并成功，返回 true         */        public void union(int x, int y) {            int rootX = find(x);            int rootY = find(y);            parent[rootX] = rootY;        }        public boolean isConnected(int x, int y) {            return find(x) == find(y);        }    }    public boolean equationsPossible(String[] equations) {        UnionFind unionFind = new UnionFind(26);        for (String equation : equations) {            if (equation.charAt(1) == '=') {                int index1 = equation.charAt(0) - 'a';                int index2 = equation.charAt(3) - 'a';                unionFind.union(index1, index2);            }        }        for (String equation : equations) {            if (equation.charAt(1) == '!') {                int index1 = equation.charAt(0) - 'a';                int index2 = equation.charAt(3) - 'a';                if (unionFind.isConnected(index1, index2)) {                    // 如果合并失败，表示等式有矛盾，根据题意，返回 false                    return false;                }            }        }        // 如果检查了所有不等式，都没有发现矛盾，返回 true        return true;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题我们为并查集设计了 <code>isConnected()</code> 方法，判断两个结点是否在一个连通分量中。</p><h3 id="并查集知识小结："><a href="#并查集知识小结：" class="headerlink" title="并查集知识小结："></a>并查集知识小结：</h3><p>1、解决的是两个顶点是否连通的问题，可以用于检测图中是否存在环；</p><p>2、代表元法：采用 <code>parent</code> 数组实现，以每个结点的根结点作为代表元；</p><p>3、并查集的优化有两种策略：</p><p>（1）路径压缩；</p><p>有“隔代压缩”与“完全压缩”。</p><ul><li>“隔代压缩”性能比较高，虽然压缩不完全，不过多次执行“隔代压缩”也能达到“完全压缩”的效果，我本人比较偏向使用“隔代压缩”的写法。</li><li>“完全压缩”需要借助系统栈，使用递归的写法。或者先找到当前结点的根结点，然后把沿途上所有的结点都指向根结点，得遍历两次。</li></ul><p>（2）按秩合并。</p><p>秩也有两种含义：① 秩表示以当前结点为根结点的子树结点总数，即这里的“秩”表示 <code>size</code> 含义；② 秩表示以当前结点为根结点的子树的高度，即这里的“秩”表示 <code>rank</code> 含义。</p><p>4、如果同时使用“路径压缩”与“按秩合并”，这里的“秩”就失去了它的定义，但即使秩表示的含义不准确，也能够作为合并时候很好的“参考”。在这种情况下，并查集的查询与合并的时间复杂度可以达到接近 $O(1)$。</p><p>感兴趣的朋友可以在互联网上搜索关键字“并查集”、“阿克曼函数”深入了解同时使用“路径压缩”与“按秩合并”时候的并查集的时间复杂度。</p><p>我使用的策略是这样的（仅供参考）：用“隔代压缩”，代码比较好写。不写“按秩合并”，除非题目有一些关于“秩”的信息需要讨论。一般来说，这样写也能得到不错的性能，如果性能不太好的话，再考虑“按秩合并”。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 952 题：按公因数计算最大组件大小（困难）</title>
      <link href="/leetcode-algo/2017/11/02/leetcode-algo/0952-largest-component-size-by-common-factor/"/>
      <url>/leetcode-algo/2017/11/02/leetcode-algo/0952-largest-component-size-by-common-factor/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-952-题：按公因数计算最大组件大小（困难）"><a href="#「力扣」第-952-题：按公因数计算最大组件大小（困难）" class="headerlink" title="「力扣」第 952 题：按公因数计算最大组件大小（困难）"></a>「力扣」第 952 题：按公因数计算最大组件大小（困难）</h2><ul><li><a href="https://leetcode-cn.com/problems/largest-component-size-by-common-factor/" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/largest-component-size-by-common-factor/solution/bing-cha-ji-java-python-by-liweiwei1419/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>给定一个由不同正整数的组成的非空数组 <code>A</code>，考虑下面的图：</p><ul><li>有 <code>A.length</code> 个节点，按从 <code>A[0]</code> 到 <code>A[A.length - 1]</code> 标记；</li><li>只有当 <code>A[i]</code> 和 <code>A[j]</code> 共用一个大于 1 的公因数时，<code>A[i]</code> 和 <code>A[j]</code> 之间才有一条边。</li></ul><p>返回图中最大连通组件的大小。</p><p><strong>示例 1：</strong></p><pre><code>输入：[4,6,15,35]输出：4</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex1.png" alt="img"></p><p><strong>示例 2：</strong></p><pre><code>输入：[20,50,9,63]输出：2</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex2.png" alt="img"></p><p><strong>示例 3：</strong></p><pre><code>输入：[2,3,6,7,4,12,21,39]输出：8</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/01/ex3.png" alt="img"> </p><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 20000</code></li><li><code>1 &lt;= A[i] &lt;= 100000</code></li></ol></blockquote><p>这道题题目都直接画成了连通图，显然可以考虑使用并查集。</p><p>1、这些数的所有质因子，是连接不同候选数的桥梁，即两个数因为有了相同的质因子，它们才能在一个连通分量里；</p><p>2、最大连通组件那里，要绕一个弯子，对于候选数组中的每一个数，查询一下这个数在并查集中的代表元（即根结点是谁），然后做一个计数统计，记录那个出现最多的代表元的个数即可。</p><p><img src="https://pic.leetcode-cn.com/ca07130ef4f7e002de91efa0b9962cbf18d8277ffa7f744023c4f64c16d78cb4-952-1.png" alt="952-1.png"><br><img src="https://pic.leetcode-cn.com/6b5d0fafdc0764918e57c8bc378ae96c0a0ac445612b70f249481e7402df31d0-952-2.png" alt="952-2.png"></p><p><strong>参考代码</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 使用了路径压缩</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没有实现按秩合并</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootX <span class="token operator">!=</span> rootY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestComponentSize</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxVal <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxVal<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 0 位置不使用，因此需要 + 1</span>        UnionFind unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>maxVal <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">double</span> upBound <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> upBound<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num <span class="token operator">/</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将候选数组映射成代表元，统计代表元出现的次数，找出最大者</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>maxVal <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> A<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> root <span class="token operator">=</span> unionFind<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            cnt<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cnt<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> math <span class="token keyword">import</span> sqrt<span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">largestComponentSize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>                root_x <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>x<span class="token punctuation">)</span>                root_y <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>y<span class="token punctuation">)</span>                <span class="token keyword">if</span> root_x <span class="token operator">!=</span> root_y<span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root_x<span class="token punctuation">]</span> <span class="token operator">=</span> root_y            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">while</span> x <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span>                    x <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span>                <span class="token keyword">return</span> x        max_val <span class="token operator">=</span> max<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        union_find <span class="token operator">=</span> UnionFind<span class="token punctuation">(</span>max_val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> A<span class="token punctuation">:</span>            up_bound <span class="token operator">=</span> int<span class="token punctuation">(</span>sqrt<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> up_bound <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    union_find<span class="token punctuation">.</span>union<span class="token punctuation">(</span>num<span class="token punctuation">,</span> i<span class="token punctuation">)</span>                    union_find<span class="token punctuation">.</span>union<span class="token punctuation">(</span>num<span class="token punctuation">,</span> num <span class="token operator">//</span> i<span class="token punctuation">)</span>        cnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>max_val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> A<span class="token punctuation">:</span>            root <span class="token operator">=</span> union_find<span class="token punctuation">.</span>find<span class="token punctuation">(</span>num<span class="token punctuation">)</span>            cnt<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> cnt<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 765 题：情侣牵手（中等）</title>
      <link href="/leetcode-algo/2017/11/01/leetcode-algo/0765-couples-holding-hands/"/>
      <url>/leetcode-algo/2017/11/01/leetcode-algo/0765-couples-holding-hands/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-765-题：情侣牵手（中等）"><a href="#「力扣」第-765-题：情侣牵手（中等）" class="headerlink" title="「力扣」第 765 题：情侣牵手（中等）"></a>「力扣」第 765 题：情侣牵手（中等）</h2><blockquote><p>这题比较有意思，关键在表示相邻两个位置的技巧。</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/couples-holding-hands/" target="_blank" rel="noopener">链接</a></li></ul><blockquote><p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p><p>人和座位用 <code>0</code> 到 <code>2N-1</code> 的整数表示，情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2N-2, 2N-1)</code>。</p><p>这些情侣的初始座位 <code>row[i]</code> 是由最初始坐在第 i 个座位上的人决定的。</p><p><strong>示例 1:</strong></p><pre><code>输入: row = [0, 2, 1, 3]输出: 1解释: 我们只需要交换row[1]和row[2]的位置即可。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: row = [3, 2, 0, 1]输出: 0解释: 无需交换座位，所有的情侣都已经可以手牵手了。</code></pre><p><strong>说明:</strong></p><ol><li><code>len(row)</code> 是偶数且数值在 <code>[4, 60]</code>范围内。</li><li>可以保证<code>row</code> 是序列 <code>0...len(row)-1</code> 的一个全排列。</li></ol></blockquote><p>观察示例 2：<code>row = [3, 2, 0, 1]</code>，这是最好的情况，不用交换。</p><p>我们看这组数字有什么特点，两个两个来看，它们除以 $2$ 的结果是一样的。</p><table><thead><tr><th>row</th><th>3</th><th>2</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>除以 2（向下取整）</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>因此这些数除以 $2$ 的结果（<strong>注意：下取整</strong>），我们可以定义为第几对情侣。</p><p>再观察示例 1：<code>[0, 2, 1, 3]</code>，可以看到有 2 对情侣。</p><table><thead><tr><th>row</th><th>0</th><th>2</th><th>1</th><th>3</th></tr></thead><tbody><tr><td>除以 2（向下取整）</td><td>0</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>因此做这个问题，感觉好像在玩“消消乐”一样，我可以两个两个拿出来的编号，除以 $2$（<strong>注意：下取整</strong>）的值如果一样，在结果集中就可以不考虑了。剩下的就是那些除了 $2$ 以后不相等的数，我们把它们放在一起，考虑如何交换次数最少，使得情侣坐在一起。</p><p>即接下来的操作就是将“不配对的情侣拆散”，这里得用一点逆向思维，即做拆解的工作，思路如下：</p><ul><li>最理想的情况，$N$ 对情侣都配对成功，彼此没有连接，如果画在一张图中，就表示有 $N$ 个连通分量；</li><li>一开始可以假设 $N$ 对情侣都配对成功，即连通分量有 $N$ 个，如果两个本来属于不同连通分量的放在了一起，连通分量就少 $1$，在问题中，就得做一次交换的操作，让这个连通分量加回去。（强行解释，我也是醉了，欢迎朋友们拍砖。）</li></ul><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count <span class="token operator">=</span> n<span class="token punctuation">;</span>            parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSwapsCouples</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> row<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> row<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        UnionFind unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> row<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> N <span class="token operator">-</span> unionFind<span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> row <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// int[] row = {3, 2, 0, 1};</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">minSwapsCouples</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 721 题：账户合并</title>
      <link href="/leetcode-algo/2017/10/31/leetcode-algo/0721-accounts-merge/"/>
      <url>/leetcode-algo/2017/10/31/leetcode-algo/0721-accounts-merge/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-721-题：账户合并"><a href="#「力扣」第-721-题：账户合并" class="headerlink" title="「力扣」第 721 题：账户合并"></a>「力扣」第 721 题：账户合并</h2><blockquote><p>这题就是题目有点长，但是是相对容易的。</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/accounts-merge/" target="_blank" rel="noopener">链接</a></li></ul><blockquote><p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code> 是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code> 是 <em>名称 (name)*，其余元素是 *emails</em> 表示该帐户的邮箱地址。</p><p>现在，我们想合并这些帐户。如果两个帐户都有一些共同的邮件地址，则两个帐户必定属于同一个人。请注意，即使两个帐户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的帐户，但其所有帐户都具有相同的名称。</p><p>合并帐户后，按以下格式返回帐户：每个帐户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。accounts 本身可以以任意顺序返回。</p><p><strong>例子 1:</strong></p><pre><code>Input: accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]Output: [[&quot;John&quot;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;],  [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]Explanation:   第一个和第三个 John 是同一个人，因为他们有共同的电子邮件 &quot;johnsmith@mail.com&quot;。   第二个 John 和 Mary 是不同的人，因为他们的电子邮件地址没有被其他帐户使用。  我们可以以任何顺序返回这些列表，例如答案[[&#39;Mary&#39;，&#39;mary@mail.com&#39;]，[&#39;John&#39;，&#39;johnnybravo@mail.com&#39;]，  [&#39;John&#39;，&#39;john00@mail.com&#39;，&#39;john_newyork@mail.com&#39;，&#39;johnsmith@mail.com&#39;]]仍然会被接受。</code></pre><p><strong>注意：</strong></p><ul><li><code>accounts</code>的长度将在<code>[1，1000]</code>的范围内。</li><li><code>accounts[i]</code>的长度将在<code>[1，10]</code>的范围内。</li><li><code>accounts[i][j]</code>的长度将在<code>[1，30]</code>的范围内。</li></ul></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">accountsMerge</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> accounts<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> accounts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        UnionFind unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 邮箱：用户的编号</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 拿到这个用户的名字和邮箱列表</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> account <span class="token operator">=</span> accounts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> currentSize <span class="token operator">=</span> account<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> currentSize<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String email <span class="token operator">=</span> account<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                Integer personId <span class="token operator">=</span> hashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>email<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>personId <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>email<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> personId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 用户编号：邮件列表</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> emailList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> entry <span class="token operator">:</span> hashMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String email <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Integer personId <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 找到这个人的代表元</span>            <span class="token keyword">int</span> rootPerson <span class="token operator">=</span> unionFind<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>personId<span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> rootEmailList <span class="token operator">=</span> emailList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootPerson<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootEmailList <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                List<span class="token operator">&lt;</span>String<span class="token operator">></span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                temp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>email<span class="token punctuation">)</span><span class="token punctuation">;</span>                emailList<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>rootPerson<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                rootEmailList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>email<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> personId <span class="token operator">:</span> emailList<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> temp <span class="token operator">=</span> emailList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>personId<span class="token punctuation">)</span><span class="token punctuation">;</span>            Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> account <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            account<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>accounts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>personId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            account<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>account<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> accounts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> account1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        account1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        account1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"johnsmith@mail.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        account1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"john00@mail.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> account2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        account2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        account2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"johnnybravo@mail.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> account3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        account3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        account3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"johnsmith@mail.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        account3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"john_newyork@mail.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> account4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        account4<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Mary"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        account4<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"mary@mail.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        accounts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>account1<span class="token punctuation">)</span><span class="token punctuation">;</span>        accounts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>account2<span class="token punctuation">)</span><span class="token punctuation">;</span>        accounts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>account3<span class="token punctuation">)</span><span class="token punctuation">;</span>        accounts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>account4<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">accountsMerge</span><span class="token punctuation">(</span>accounts<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 685 题：冗余连接 II（困难）</title>
      <link href="/leetcode-algo/2017/10/30/leetcode-algo/0685-redundant-connection-ii/"/>
      <url>/leetcode-algo/2017/10/30/leetcode-algo/0685-redundant-connection-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-685-题：冗余连接-II（困难）"><a href="#「力扣」第-685-题：冗余连接-II（困难）" class="headerlink" title="「力扣」第 685 题：冗余连接 II（困难）"></a>「力扣」第 685 题：冗余连接 II（困难）</h2><blockquote><p>注意细节的调试。</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">链接</a></li></ul><blockquote><p>在本问题中，有根树指满足以下条件的<strong>有向</strong>图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以<code>边</code>组成的二维数组。 每一个<code>边</code> 的元素是一对 <code>[u, v]</code>，用以表示<strong>有向</strong>图中连接顶点 <code>u</code> and <code>v</code>和顶点的边，其中父节点<code>u</code>是子节点<code>v</code>的一个父节点。</p><p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p><strong>示例 1:</strong></p><pre><code>输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的有向图如下:  1 / \v   v2--&gt;3</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]输出: [4,1]解释: 给定的有向图如下:5 &lt;- 1 -&gt; 2     ^    |     |    v     4 &lt;- 3</code></pre><p><strong>注意:</strong></p><ul><li>二维数组大小的在3到1000范围内。</li><li>二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。</li></ul></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * @param x         * @param y         * @return 如果合并成功返回 true         */</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findRedundantDirectedConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> edges<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 入度数组，记录指向某个结点的边的条数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inDegree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            inDegree<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 从后向前看，如果某个顶点的入度为 2，尝试把它去掉，看看会不会构成环</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果不构成环，这条边就是要去掉的那条边</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">judgeCircle</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> len<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 从后向前看，如果某个顶点的入度为 1，尝试把它去掉，看看会不会构成环</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果不构成环，这条边就是要去掉的那条边</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">judgeCircle</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> len<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"输入不符合要求。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将 remove 去掉以后，剩下的有向边是否构成环     *     * @param edges     * @param len     * @param remove     * @return 构成环，返回 true     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">judgeCircle</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> remove<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UnionFind unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> remove<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 合并失败，表示 edges[i][0] 和 edges[i][1] 在一个连通分量里，即构成了环</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">findRedundantDirectedConnection</span><span class="token punctuation">(</span>edges<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 684 题：冗余连接（中等）</title>
      <link href="/leetcode-algo/2017/10/29/leetcode-algo/0684-redundant-connection/"/>
      <url>/leetcode-algo/2017/10/29/leetcode-algo/0684-redundant-connection/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-684-题：冗余连接（中等）"><a href="#「力扣」第-684-题：冗余连接（中等）" class="headerlink" title="「力扣」第 684 题：冗余连接（中等）"></a>「力扣」第 684 题：冗余连接（中等）</h2><blockquote><p>这是一道考察「并查集」很基础的问题。</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">链接</a></li></ul><blockquote><p>在本问题中, 树指的是一个连通且无环的<strong>无向</strong>图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以<code>边</code>组成的二维数组。每一个<code>边</code>的元素是一对<code>[u, v]</code> ，满足 <code>u &lt; v</code>，表示连接顶点<code>u</code> 和<code>v</code>的<strong>无向</strong>图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code> 应满足相同的格式 <code>u &lt; v</code>。</p><p><strong>示例 1：</strong></p><pre><code>输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为:  1 / \2 - 3</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]输出: [1,4]解释: 给定的无向图为:5 - 1 - 2    |   |    4 - 3</code></pre><p><strong>注意:</strong></p><ul><li>输入的二维数组大小在 3 到 1000。</li><li>二维数组中的整数在1到N之间，其中N是输入数组的大小。</li></ul><p><strong>更新(2017-09-26):</strong><br>我们已经重新检查了问题描述及测试用例，明确图是<strong><em>无向</em></strong> 图。对于有向图详见<strong><a href="https://leetcodechina.com/problems/redundant-connection-ii/description/" target="_blank" rel="noopener">冗余连接II</a>。</strong>对于造成任何不便，我们深感歉意。</p></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * @param x         * @param y         * @return 如果合并成功返回 true         */</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findRedundantDirectedConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> edges<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 入度数组，记录指向某个结点的边的条数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inDegree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            inDegree<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 从后向前看，如果某个顶点的入度为 2，尝试把它去掉，看看会不会构成环</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果不构成环，这条边就是要去掉的那条边</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">judgeCircle</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> len<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 从后向前看，如果某个顶点的入度为 1，尝试把它去掉，看看会不会构成环</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果不构成环，这条边就是要去掉的那条边</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">judgeCircle</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> len<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"输入不符合要求。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将 remove 去掉以后，剩下的有向边是否构成环     *     * @param edges     * @param len     * @param remove     * @return 构成环，返回 true     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">judgeCircle</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> remove<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UnionFind unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> remove<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 合并失败，表示 edges[i][0] 和 edges[i][1] 在一个连通分量里，即构成了环</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">findRedundantDirectedConnection</span><span class="token punctuation">(</span>edges<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 547 题：朋友圈（中等）</title>
      <link href="/leetcode-algo/2017/10/28/leetcode-algo/0547-friend-circles/"/>
      <url>/leetcode-algo/2017/10/28/leetcode-algo/0547-friend-circles/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-547-题：朋友圈（中等）"><a href="#「力扣」第-547-题：朋友圈（中等）" class="headerlink" title="「力扣」第 547 题：朋友圈（中等）"></a>「力扣」第 547 题：朋友圈（中等）</h2><blockquote><p>并查集的典型问题。题目也非常接地气。</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/friend-circles/solution/bing-cha-ji-python-dai-ma-java-dai-ma-by-liweiwei1/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>班上有 <strong>N</strong> 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 <strong>N * N</strong> 的矩阵 <strong>M</strong>，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生<strong>互为</strong>朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p><strong>示例 1:</strong></p><pre><code>输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</code></pre><p><strong>注意：</strong></p><ol><li><code>N</code> 在 <code>[1, 200]</code> 的范围内。</li><li>对于所有学生，有 <code>M[i][i] = 1</code>。</li><li>如果有 <code>M[i][j] = 1</code>，则有 <code>M[j][i] = 1</code>。</li></ol></blockquote><h3 id="方法一：并查集"><a href="#方法一：并查集" class="headerlink" title="方法一：并查集"></a>方法一：并查集</h3><p>好友关系是双向关系，因此题目中给出的矩阵其实是一个邻接矩阵，所以问题就转化为求图中有几个连通分量的问题了。</p><p>我们还可以用并查集来解决它。由于是对阵矩阵，我们其实只要看这个矩阵的下三角形部分就可以了。又因为自己肯定是自己的好友，所以还可以不看对角。</p><p>并查集的特点是<strong>孩子结点指向父亲结点，两个结点连接在一起即它们有相同的根结点</strong>。下面是对编码的两点说明：</p><p>1、这里使用了基于 <code>rank</code> 的结点指向策略，<code>rank</code> 的含义是以自己为根结点的树的高度。</p><p>2、在 <code>find</code> 的过程中，实现了路径压缩算法，简而言之就在查询的过程中，修改结点的指向，将原本指向父亲结点修改成指向爷爷结点，以压缩这个多叉树的高度。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count <span class="token operator">=</span> n<span class="token punctuation">;</span>            parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> M<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        UnionFind unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>M<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> unionFind<span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> M <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">findCircleNum</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">class UnionFind {    /**     * 连通分量的个数     */    private int count;    private int[] parent;    /**     * 以索引为 i 的元素为根结点的树的深度（最深的那个深度）     */    private int[] rank;    public UnionFind(int n) {        this.count = n;        this.parent = new int[n];        this.rank = new int[n];        for (int i = 0; i < n; i++) {            this.parent[i] = i;            // 初始化时，所有的元素只包含它自己，只有一个元素，所以 rank[i] = 1            this.rank[i] = 1;        }    }    public int getCount() {        return this.count;    }    public int find(int p) {        // 在 find 的时候执行路径压缩        while (p != this.parent[p]) {            // 两步一跳完成路径压缩            this.parent[p] = this.parent[this.parent[p]];            p = this.parent[p];        }        return p;    }    public boolean isConnected(int p, int q) {        return find(p) == find(q);    }    public void union(int p, int q) {        int pRoot = find(p);        int qRoot = find(q);        if (pRoot == qRoot) {            return;        }        // 这一步是与第 3 版不同的地方        if (rank[pRoot] > rank[qRoot]) {            parent[qRoot] = pRoot;        } else if (rank[pRoot] < rank[qRoot]) {            parent[pRoot] = qRoot;        } else {            parent[qRoot] = pRoot;            rank[pRoot]++;        }        // 每次 union 以后，连通分量减 1        count--;    }}public class Solution {    public int findCircleNum(int[][] M) {        int len = M.length;        UnionFind uf = new UnionFind(len);        for (int i = 0; i < len; i++) {            for (int j = 0; j < i; j++) {                if (M[i][j] == 1) {                    uf.union(i, j);                }            }        }        return uf.getCount();    }    public static void main(String[] args) {        int[][] M = {{1, 1, 0},                {1, 1, 0},                {0, 0, 1}};        Solution solution = new Solution();        int res = solution.findCircleNum(M);        System.out.println(res);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def findCircleNum(self, M: List[List[int]]) -> int:        """        :type M: List[List[int]]        :rtype: int        """        class UnionFind:            def __init__(self, n):                self.count = n                self.parent = [i for i in range(n)]                self.rank = [1 for i in range(n)]            def get_count(self):                return self.count            def find(self, p):                while p != self.parent[p]:                    self.parent[p] = self.parent[self.parent[p]]                    p = self.parent[p]                return p            def is_connected(self, p, q):                return self.find(p) == self.find(q)            def union(self, p, q):                p_root = self.find(p)                q_root = self.find(q)                if p_root == q_root:                    return                if self.rank[p_root] > self.rank[q_root]:                    self.parent[q_root] = p_root                elif self.rank[p_root] < self.rank[q_root]:                    self.parent[p_root] = q_root                else:                    self.parent[q_root] = p_root                    self.rank[p_root] += 1                self.count -= 1        m = len(M)        union_find_set = UnionFind(m)        for i in range(m):            for j in range(i):                if M[i][j] == 1:                    union_find_set.union(j, i)        return union_find_set.get_count()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type M: List[List[int]]        :rtype: int        """</span>        <span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>                root <span class="token operator">=</span> p                <span class="token comment" spellcheck="true"># 只要不是最上层的那个结点，就不停向上找</span>                <span class="token keyword">while</span> root <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>                    root <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># 此时 root 就是大 boss</span>                <span class="token comment" spellcheck="true"># 接下来把 p 到 root 沿途所有的结点都指向 root</span>                <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                    temp <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> root                    p <span class="token operator">=</span> temp                <span class="token keyword">return</span> root            <span class="token keyword">def</span> <span class="token function">is_connected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                p_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                q_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>                <span class="token keyword">if</span> p_id <span class="token operator">==</span> q_id<span class="token punctuation">:</span>                    <span class="token keyword">return</span>                self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p_id<span class="token punctuation">]</span> <span class="token operator">=</span> q_id        m <span class="token operator">=</span> len<span class="token punctuation">(</span>M<span class="token punctuation">)</span>        union_find_set <span class="token operator">=</span> UnionFind<span class="token punctuation">(</span>m<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 只看下三角矩阵(不包括对角线)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> M<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    union_find_set<span class="token punctuation">.</span>union<span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span>        counter <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># print(union_find_set.parent)</span>        <span class="token comment" spellcheck="true"># 自己的父亲是自己的话，这个结点就是根结点，是老大，是 boss</span>        <span class="token comment" spellcheck="true"># boss 的特点就是，他上面没有人，例如：李彦宏、马云</span>        <span class="token comment" spellcheck="true"># 数一数有几个老大，就有几个朋友圈</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> parent <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>union_find_set<span class="token punctuation">.</span>parent<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> parent<span class="token punctuation">:</span>                counter <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> counter<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    M <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>         <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>         <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>findCircleNum<span class="token punctuation">(</span>M<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：深度优先遍历"><a href="#方法二：深度优先遍历" class="headerlink" title="方法二：深度优先遍历"></a>方法二：深度优先遍历</h3><p>C++ 代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">/**     * 记录是否被访问过     */</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> visited<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 一共 N 名学生     */</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token operator">&amp;</span>M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果是朋友关系，就继续遍历下去，这是深度优先遍历</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>M<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token operator">&amp;</span>M<span class="token punctuation">)</span> <span class="token punctuation">{</span>        N <span class="token operator">=</span> M<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 连通分量</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        visited<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="例题1：LeetCode-第-547-题：朋友圈"><a href="#例题1：LeetCode-第-547-题：朋友圈" class="headerlink" title="例题1：LeetCode 第 547 题：朋友圈"></a>例题1：LeetCode 第 547 题：<a href="https://leetcode-cn.com/problems/friend-circles" target="_blank" rel="noopener">朋友圈</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="noopener">547. Friend Circles</a>，中文网址：<a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">547. 朋友圈</a>。</p><blockquote><p>班上有 <strong>N</strong> 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 <strong>N * N</strong> 的矩阵 <strong>M</strong>，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生<strong>互为</strong>朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p><strong>示例 1:</strong></p><pre><code>输入: [[1,1,0],[1,1,0],[0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [[1,1,0],[1,1,1],[0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。</code></pre><p><strong>注意：</strong></p><ol><li>N 在[1,200]的范围内。</li><li>对于所有学生，有M[i][i] = 1。</li><li>如果有M[i][j] = 1，则有M[j][i] = 1。</li></ol></blockquote><p>思路1：好友关系是双向关系，因此题目中给出的矩阵其实是一个邻接矩阵，所以问题就转化为求图中有几个连通分量的问题了。</p><p>思路2：我们还可以用并查集来解决它。由于是对阵矩阵，我们其实只要看这个矩阵的下三角形部分就可以了。又因为自己肯定是自己的好友，所以还可以不看对角线，。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> M<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type M: List[List[int]]        :rtype: int        """</span>        <span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>                root <span class="token operator">=</span> p                <span class="token comment" spellcheck="true"># 只要不是最上层的那个结点，就不停向上找</span>                <span class="token keyword">while</span> root <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>                    root <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># 此时 root 就是大 boss</span>                <span class="token comment" spellcheck="true"># 接下来把 p 到 root 沿途所有的结点都指向 root</span>                <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                    temp <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> root                    p <span class="token operator">=</span> temp                <span class="token keyword">return</span> root            <span class="token keyword">def</span> <span class="token function">is_connected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                p_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                q_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>                <span class="token keyword">if</span> p_id <span class="token operator">==</span> q_id<span class="token punctuation">:</span>                    <span class="token keyword">return</span>                self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p_id<span class="token punctuation">]</span> <span class="token operator">=</span> q_id        m <span class="token operator">=</span> len<span class="token punctuation">(</span>M<span class="token punctuation">)</span>        union_find_set <span class="token operator">=</span> UnionFind<span class="token punctuation">(</span>m<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 只看下三角矩阵(不包括对角线)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> M<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    union_find_set<span class="token punctuation">.</span>union<span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token punctuation">)</span>        counter <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># print(union_find_set.parent)</span>        <span class="token comment" spellcheck="true"># 自己的父亲是自己的话，这个结点就是根结点，是老大，是 boss</span>        <span class="token comment" spellcheck="true"># boss 的特点就是，他上面没有人，例如：李彦宏、马云</span>        <span class="token comment" spellcheck="true"># 数一数有几个老大，就有几个朋友圈</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> parent <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>union_find_set<span class="token punctuation">.</span>parent<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> parent<span class="token punctuation">:</span>                counter <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> counter<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    M <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>         <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>         <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>findCircleNum<span class="token punctuation">(</span>M<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 399 题：除法求值（困难）</title>
      <link href="/leetcode-algo/2017/10/27/leetcode-algo/0399-longest-consecutive-sequence/"/>
      <url>/leetcode-algo/2017/10/27/leetcode-algo/0399-longest-consecutive-sequence/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-399-题：除法求值（困难）"><a href="#「力扣」第-399-题：除法求值（困难）" class="headerlink" title="「力扣」第 399 题：除法求值（困难）"></a>「力扣」第 399 题：除法求值（困难）</h2><blockquote><p>带权值的「并查集」，搞清楚方向。</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">链接</a></li></ul><blockquote><p>给出方程式 <code>A / B = k</code>, 其中 <code>A</code> 和 <code>B</code> 均为代表字符串的变量， <code>k</code> 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 <code>-1.0</code>。</p><p><strong>示例 :</strong><br>给定 <code>a / b = 2.0, b / c = 3.0</code><br>问题: <code>a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</code><br>返回 <code>[6.0, 0.5, -1.0, 1.0, -1.0 ]</code></p><p>输入为: <code>vector&gt; equations, vector&amp; values, vector&gt; queries</code>(方程式，方程式结果，问题方程式)， 其中 <code>equations.size() == values.size()</code>，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回<code>vector</code>类型。</p><p>基于上述例子，输入如下：</p><pre><code>equations(方程式) = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],values(方程式结果) = [2.0, 3.0],queries(问题方程式) = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ]. </code></pre><p>输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。</p></blockquote><p>思路：这道题别看题目很长，但是表达意思是很简单的。给出一些关系式，让我们根据这些关系式，求出题目问的两个变量的结果。</p><ul><li>这道题和上一题其实蛮像的，只不过上一题是等式，而这一题两个变量之间有一个系数的关系。我们只需要维护这个变量的关系就好。</li><li>上一题，我们把元素放进并查集的时候，做了一个转换，因为等式都是小写字母，因此可以与 0 - 25 做一个映射，这里我们还需要绑定一个权值信息，进而我们将一个元素和一个结点类绑定在一起，为此我们设计一个结点类，并且并查集内部的数组我们使用哈希表代替（事实上不使用哈希表也是可以的，这里为了展示并查集实现的灵活性，使用哈希表代替，请大家自行完并查集内部使用两个数组，一个表示元素，另一个表示结点之间关系）。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gamygdg8icj315m0lsq5j.jpg" alt="image-20200106171023029"></p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用并查集，带权值的并查集</span>    <span class="token keyword">class</span> <span class="token class-name">Pair</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> String str<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">double</span> val<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Pair</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">double</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>str <span class="token operator">=</span> str<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"Pair{"</span> <span class="token operator">+</span>                    <span class="token string">"str='"</span> <span class="token operator">+</span> str <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                    <span class="token string">", val="</span> <span class="token operator">+</span> val <span class="token operator">+</span>                    <span class="token string">'}'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Pair<span class="token operator">></span> parent<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 返回根结点的 Pair 对象         *         * @param A         * @return         */</span>        <span class="token keyword">private</span> Pair <span class="token function">find</span><span class="token punctuation">(</span>String A<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果不是根结点，继续找父结点</span>                Pair p <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 把 A 的父结点直线 p ，这是路径压缩</span>                parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span>str <span class="token operator">=</span> p<span class="token punctuation">.</span>str<span class="token punctuation">;</span>                parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">.</span>val <span class="token operator">*=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span>String A<span class="token punctuation">,</span> String B<span class="token punctuation">,</span> <span class="token keyword">double</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parent<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>parent<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                parent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 如果 A 是独立的，就把 A 指向 B</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parent<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 如果 B 是独立的，就把 B 指向 A</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parent<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">/</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 走到这里就是 A 和 B 在一个集合里的情况</span>            Pair rootA <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>            Pair rootB <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootA <span class="token operator">!=</span> rootB<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rootA<span class="token punctuation">.</span>str <span class="token operator">=</span> rootB<span class="token punctuation">.</span>str<span class="token punctuation">;</span>                rootA<span class="token punctuation">.</span>val <span class="token operator">*=</span> <span class="token punctuation">(</span>val <span class="token operator">*</span> rootB<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">calcEquation</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> equations<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> queries<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> equationsSize <span class="token operator">=</span> equations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        UnionFind unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> equationsSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String A <span class="token operator">=</span> equations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String B <span class="token operator">=</span> equations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">double</span> k <span class="token operator">=</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> queries<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">double</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String X <span class="token operator">=</span> queries<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String Y <span class="token operator">=</span> queries<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>unionFind<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>unionFind<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>Y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Pair rootX <span class="token operator">=</span> unionFind<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span>            Pair rootY <span class="token operator">=</span> unionFind<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>Y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootX<span class="token punctuation">.</span>str<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>rootY<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">.</span>val <span class="token operator">/</span> rootY<span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一类经典的带权值的并查集问题，事实上，并查集问题是算法竞赛中的常客，我们学习并查集，主要理解它的思想和应用即可。太难的问题，我个人觉得如果只是应付面试，争取更好的工作机会，我个人觉得暂时没有必要一定要把很难的问题做出来。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 200 题：岛屿的个数（中等）</title>
      <link href="/leetcode-algo/2017/10/26/leetcode-algo/0200-number-of-islands/"/>
      <url>/leetcode-algo/2017/10/26/leetcode-algo/0200-number-of-islands/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-200-题：岛屿的个数（中等）"><a href="#「力扣」第-200-题：岛屿的个数（中等）" class="headerlink" title="「力扣」第 200 题：岛屿的个数（中等）"></a>「力扣」第 200 题：岛屿的个数（中等）</h2><blockquote><p>典型的使用「并查集」解决的问题。掌握二维坐标向一位坐标的转换，非常常见。</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">链接</a></li></ul><blockquote><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p><strong>示例 1:</strong></p><pre><code>输入:11110110101100000000输出: 1</code></pre><p><strong>示例 2:</strong></p><pre><code>输入:11000110000010000011输出: 3</code></pre></blockquote><h3 id="方法一：深度优先遍历"><a href="#方法一：深度优先遍历" class="headerlink" title="方法一：深度优先遍历"></a>方法一：深度优先遍历</h3><p>在二维平面上的深度优先遍历，也叫 floorfill。</p><p>注意事项：可以直接在二维平面上做修改，无须状态重置。</p><p>C++ 代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rows<span class="token punctuation">;</span>    <span class="token keyword">int</span> cols<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">inArea</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> cols<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> <span class="token operator">&amp;</span>grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> newX <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> newY <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inArea</span><span class="token punctuation">(</span>newX<span class="token punctuation">,</span> newY<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>newX<span class="token punctuation">]</span><span class="token punctuation">[</span>newY<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>newX<span class="token punctuation">,</span> newY<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> <span class="token operator">&amp;</span>grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rows <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rows <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cols <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cols <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cols<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>                    res<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：并查集"><a href="#方法二：并查集" class="headerlink" title="方法二：并查集"></a>方法二：并查集</h3><blockquote><p>使用并查集，把所有的 <code>&quot;0&quot;</code>都合并到一个虚拟的结点上，然后扫描整个二维矩阵。</p></blockquote><p>这道题给我们一个矩阵，表示一个二维平面，问我们，被海水包围的陆地一共有多少个。</p><p>注意到所有的用字符 <code>1</code> 表示的陆地在这个问题中是连成一片的，而字符 <code>0</code> 表示的海水也是连成一片的，因此很自然想到使用“并查集”解决这个问题。</p><p>为此设计算法如下：</p><p>1、如果当前是“陆地”，尝试与周围合并一下；</p><p>2、如果当前是“水域”，就把所有的“水域”合并在一起。请注意，这里应该是“所有的”水域为一个整体。因此，需要设置了一个虚拟的结点，表示“所有的水域都和这个虚拟结点是连接的”。</p><p><strong>注意</strong>：</p><p>1、针对上面的第 1 点：如果当前是 “陆地”，尝试与周围合并一下”，此时 “周围” 并不需要像 “深度优先遍历” 和 “广度优先遍历” 一样，方向是四周。事实上，只要 “向右”、“向下” 两个方向就可以了，原因很简单，你可以在脑子里想象一个 “4 个方向” 和 “2 个方向” 的算法执行流程（或者看我下面展示的动画），就知道 “4 个方向” 没有必要；</p><p>2、针对上面的第 2 点：由于我设置了“虚拟结点”，最后返回“岛屿个数”的时候，应该是连通分量个数 - 1，不要忘记将 “虚拟结点” 代表的 “水域” 分量去掉，剩下的连通分量个数就是 “岛屿个数”。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 连通分量个数         */</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count <span class="token operator">=</span> n<span class="token punctuation">;</span>            parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">inArea</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> cols<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">*</span> cols <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rows <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cols <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cols <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> directions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> rows <span class="token operator">*</span> cols<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 多开一个结点，把 '0' 都与最后这个结点连在一起</span>        UnionFind unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cols<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> direction <span class="token operator">:</span> directions<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> newX <span class="token operator">=</span> i <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> newY <span class="token operator">=</span> j <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inArea</span><span class="token punctuation">(</span>newX<span class="token punctuation">,</span> newY<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>newX<span class="token punctuation">]</span><span class="token punctuation">[</span>newY<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span><span class="token function">getIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getIndex</span><span class="token punctuation">(</span>newX<span class="token punctuation">,</span> newY<span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span><span class="token function">getIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> unionFind<span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 连通分量个数         */</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count <span class="token operator">=</span> n<span class="token punctuation">;</span>            parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 只实现了路径压缩，并且是隔代压缩</span>                parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>            count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> count<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">inArea</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> cols<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">*</span> cols <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rows <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cols <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cols <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> directions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> rows <span class="token operator">*</span> cols<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 多开一个结点，把 '0' 都与最后这个结点连在一起</span>        UnionFind unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cols<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> direction <span class="token operator">:</span> directions<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> newX <span class="token operator">=</span> i <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> newY <span class="token operator">=</span> j <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">inArea</span><span class="token punctuation">(</span>newX<span class="token punctuation">,</span> newY<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>newX<span class="token punctuation">]</span><span class="token punctuation">[</span>newY<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span><span class="token function">getIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getIndex</span><span class="token punctuation">(</span>newX<span class="token punctuation">,</span> newY<span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span><span class="token function">getIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> unionFind<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要掌握的技巧：</p><p>1、把所有的方向，设置在一个二维数组里，是一个二维平面问题常用的技巧；</p><p>2、二维坐标与一维索引的转换需要特别熟练，如果实在想不清楚，举几个具体的例子，在纸上计算一下便不难分析出来。</p><hr><h3 id="练习3：LeetCode-第-200-题：岛屿的个数"><a href="#练习3：LeetCode-第-200-题：岛屿的个数" class="headerlink" title="练习3：LeetCode 第 200 题：岛屿的个数"></a>练习3：LeetCode 第 200 题：<a href="https://leetcode-cn.com/problems/number-of-islands" target="_blank" rel="noopener">岛屿的个数</a></h3><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p><strong>示例 1:</strong></p><pre><code>输入:11110110101100000000输出: 1</code></pre><p><strong>示例 2:</strong></p><pre><code>输入:11000110000010000011输出: 3</code></pre><p>思路1：floorfill，可以在<a href="https://github.com/liweiwei1419/LeetCode-Solution-Python/blob/master/08-%E9%80%92%E5%BD%92%E5%92%8C%E5%9B%9E%E6%BA%AF%E6%B3%95/0200-%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0.py" target="_blank" rel="noopener">这里</a>看到这个思路的代码。</p><p>思路2：使用并查集，把所有的“0”都合并到一个虚拟的结点上，然后扫描整个二维矩阵。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type grid: List[List[str]]        :rtype: int        """</span>        <span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>                root <span class="token operator">=</span> p                <span class="token keyword">while</span> root <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>                    root <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span>                <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                    temp <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> root                    p <span class="token operator">=</span> temp                <span class="token keyword">return</span> root            <span class="token keyword">def</span> <span class="token function">is_connected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                p_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                q_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>                <span class="token keyword">if</span> p_id <span class="token operator">==</span> q_id<span class="token punctuation">:</span>                    <span class="token keyword">return</span>                self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p_id<span class="token punctuation">]</span> <span class="token operator">=</span> q_id        row <span class="token operator">=</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">)</span>        <span class="token keyword">if</span> row <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        col <span class="token operator">=</span> len<span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">get_index</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> x <span class="token operator">*</span> col <span class="token operator">+</span> y        directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 多开一个空间，把 "0" 都归到这个虚拟的老大上</span>        dummy_node <span class="token operator">=</span> row <span class="token operator">*</span> col        uf <span class="token operator">=</span> UnionFind<span class="token punctuation">(</span>dummy_node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">:</span>                    uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> dummy_node<span class="token punctuation">)</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 向下向右如果都是 "1" 就要合并一下</span>                    <span class="token keyword">for</span> direction <span class="token keyword">in</span> directions<span class="token punctuation">:</span>                        new_x <span class="token operator">=</span> i <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                        new_y <span class="token operator">=</span> j <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> new_x <span class="token operator">&lt;</span> row <span class="token operator">and</span> new_y <span class="token operator">&lt;</span> col <span class="token operator">and</span> grid<span class="token punctuation">[</span>new_x<span class="token punctuation">]</span><span class="token punctuation">[</span>new_y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">:</span>                            uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> get_index<span class="token punctuation">(</span>new_x<span class="token punctuation">,</span> new_y<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 因为一定要减掉 "0" 的区域，因此起始值是 -1</span>        res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> parent <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>uf<span class="token punctuation">.</span>parent<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> parent <span class="token operator">==</span> index<span class="token punctuation">:</span>                res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后附上我以前学习并查集的时候写的笔记，传送门：<a href="https://www.jianshu.com/p/aa92245f7682" target="_blank" rel="noopener">高级数据结构：并查集（Java 实现）</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 130 题：被围绕的区域</title>
      <link href="/leetcode-algo/2017/10/25/leetcode-algo/0130-surrounded-regions/"/>
      <url>/leetcode-algo/2017/10/25/leetcode-algo/0130-surrounded-regions/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-130-题：被围绕的区域"><a href="#「力扣」第-130-题：被围绕的区域" class="headerlink" title="「力扣」第 130 题：被围绕的区域"></a>「力扣」第 130 题：被围绕的区域</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/surrounded-regions/</a></li></ul><blockquote><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p><p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><p><strong>示例:</strong></p><pre><code>X X X XX O O XX X O XX O X X</code></pre><p>运行你的函数后，矩阵变为：</p><pre><code>X X X XX X X XX X X XX O X X</code></pre><p><strong>解释:</strong></p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 <code>&#39;O&#39;</code> 都不会被填充为 <code>&#39;X&#39;</code>。 任何不在边界上，或不与边界上的 <code>&#39;O&#39;</code> 相连的 <code>&#39;O&#39;</code> 最终都会被填充为 <code>&#39;X&#39;</code>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><p>分析：其实就是将不与边上的  <code>&#39;O&#39;</code> 相连的 <code>&#39;O&#39;</code> 改成  <code>&#39;X&#39;</code>，可以使用并查集完成。</p></blockquote><p>Python 代码1：一开始的写法，不太好理解。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type board: List[List[str]]        :rtype: void Do not return anything, modify board in-place instead.        """</span>        <span class="token comment" spellcheck="true"># 使用并查集</span>        <span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>                root <span class="token operator">=</span> p                <span class="token keyword">while</span> root <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>                    root <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span>                <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                    temp <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> root                    p <span class="token operator">=</span> temp                <span class="token keyword">return</span> root            <span class="token keyword">def</span> <span class="token function">is_connected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                p_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                q_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>                <span class="token keyword">if</span> p_id <span class="token operator">==</span> q_id<span class="token punctuation">:</span>                    <span class="token keyword">return</span>                self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p_id<span class="token punctuation">]</span> <span class="token operator">=</span> q_id        <span class="token comment" spellcheck="true"># 一开始是常规的代码</span>        m <span class="token operator">=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span>        <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">get_index</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> x <span class="token operator">*</span> n <span class="token operator">+</span> y        directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 这里多留了一个位置，表示与边上的 'O' 相连</span>        uf <span class="token operator">=</span> UnionFind<span class="token punctuation">(</span>m <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 把所有不被 'X' 包围的 'O' 放在同一个集合里</span>                    <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> i <span class="token operator">==</span> m <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">or</span> j <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                        uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true"># 向 4 个方向找，只用看 4 个方向，不要和回溯算法混淆了</span>                        <span class="token comment" spellcheck="true"># 只要都是 'O' ，才有必要合并</span>                        <span class="token keyword">for</span> direction <span class="token keyword">in</span> directions<span class="token punctuation">:</span>                            new_i <span class="token operator">=</span> i <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                            new_j <span class="token operator">=</span> j <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                            <span class="token keyword">if</span> board<span class="token punctuation">[</span>new_i<span class="token punctuation">]</span><span class="token punctuation">[</span>new_j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                                uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> get_index<span class="token punctuation">(</span>new_i<span class="token punctuation">,</span> new_j<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 最后，才内圈里，只要是 'O'，且不与边上的 'O' 连接，都改成 'X' 即可  </span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span> <span class="token operator">and</span> <span class="token operator">not</span> uf<span class="token punctuation">.</span>is_connected<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'X'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个版本写出来，感觉思路不是很清晰，于是，我又写了一版。</p><p>Python 代码2：其实并查集的写法容易受 floorfill 的影响，用并查集的时候，其实只用每一行的右边和下面都看一下，只针对“O”，能合并就合并一下。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">solve</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type board: List[List[str]]        :rtype: void Do not return anything, modify board in-place instead.        """</span>        <span class="token comment" spellcheck="true"># 使用并查集</span>        <span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">:</span>            <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>                root <span class="token operator">=</span> p                <span class="token keyword">while</span> root <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>                    root <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span>                <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>                    temp <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span>                    self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> root                    p <span class="token operator">=</span> temp                <span class="token keyword">return</span> root            <span class="token keyword">def</span> <span class="token function">is_connected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>            <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>                p_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span>                q_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>                <span class="token keyword">if</span> p_id <span class="token operator">==</span> q_id<span class="token punctuation">:</span>                    <span class="token keyword">return</span>                self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p_id<span class="token punctuation">]</span> <span class="token operator">=</span> q_id        <span class="token comment" spellcheck="true"># 一开始是常规的代码</span>        m <span class="token operator">=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span>        <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">get_index</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> x <span class="token operator">*</span> n <span class="token operator">+</span> y        dummy_node <span class="token operator">=</span> m <span class="token operator">*</span> n        uf <span class="token operator">=</span> UnionFind<span class="token punctuation">(</span>m <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 先把四条边上的 "O" 全部连起来</span>        <span class="token keyword">for</span> row_index <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> board<span class="token punctuation">[</span>row_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>row_index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dummy_node<span class="token punctuation">)</span>            <span class="token keyword">if</span> board<span class="token punctuation">[</span>row_index<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>row_index<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dummy_node<span class="token punctuation">)</span>        <span class="token keyword">for</span> col_index <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col_index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> col_index<span class="token punctuation">)</span><span class="token punctuation">,</span> dummy_node<span class="token punctuation">)</span>            <span class="token keyword">if</span> board<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col_index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> col_index<span class="token punctuation">)</span><span class="token punctuation">,</span> dummy_node<span class="token punctuation">)</span>        directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 只向 2 个方向找，只用看 2 个方向，不要和回溯算法混淆了</span>                    <span class="token keyword">for</span> direction <span class="token keyword">in</span> directions<span class="token punctuation">:</span>                        new_i <span class="token operator">=</span> i <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                        new_j <span class="token operator">=</span> j <span class="token operator">+</span> direction<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> new_i <span class="token operator">&lt;</span> m <span class="token operator">and</span> new_j <span class="token operator">&lt;</span> n <span class="token operator">and</span> board<span class="token punctuation">[</span>new_i<span class="token punctuation">]</span><span class="token punctuation">[</span>new_j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span><span class="token punctuation">:</span>                            uf<span class="token punctuation">.</span>union<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> get_index<span class="token punctuation">(</span>new_i<span class="token punctuation">,</span> new_j<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'O'</span> <span class="token operator">and</span> <span class="token operator">not</span> uf<span class="token punctuation">.</span>is_connected<span class="token punctuation">(</span>get_index<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'X'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 128 题：最长连续序列（困难）</title>
      <link href="/leetcode-algo/2017/10/24/leetcode-algo/0128-longest-consecutive-sequence/"/>
      <url>/leetcode-algo/2017/10/24/leetcode-algo/0128-longest-consecutive-sequence/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-128-题：最长连续序列（困难）"><a href="#「力扣」第-128-题：最长连续序列（困难）" class="headerlink" title="「力扣」第 128 题：最长连续序列（困难）"></a>「力扣」第 128 题：最长连续序列（困难）</h2><blockquote><p>这道题因为有判断「是否在并查集」中的需要，因此需要把并查集的底层数组设置为「哈希表」。</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">链接</a></li></ul><blockquote><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为 $O(n)$。</p><p><strong>示例</strong>：</p><pre><code>输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</code></pre></blockquote><p>注意：这里封装的「并查集」有一些特殊，<code>union</code> 方法返回的是 <code>size</code> ，可以理解成基于 <code>size</code> 合并的意思，这里的 <code>size</code> 在这道问题里是有实际意义。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> parent<span class="token punctuation">;</span>        <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> size<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>            size <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>                size<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            parent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>rootX<span class="token punctuation">,</span> rootY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> size<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootX<span class="token punctuation">)</span> <span class="token operator">+</span> size<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootY<span class="token punctuation">)</span><span class="token punctuation">;</span>            size<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>rootY<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * 实现了路径压缩         *         * @param x         * @return         */</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                parent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> parent<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        UnionFind unionFind <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>unionFind<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>unionFind<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> unionFind<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并查集」专题 8：并查集第 7 版（易于理解的路径压缩算法，复杂度较高，不用掌握）</title>
      <link href="/leetcode-algo/2017/10/23/leetcode-algo/union-find-set-08/"/>
      <url>/leetcode-algo/2017/10/23/leetcode-algo/union-find-set-08/</url>
      
        <content type="html"><![CDATA[<h2 id="「并查集」专题-8：并查集第-7-版（易于理解的路径压缩算法，复杂度较高，不用掌握）"><a href="#「并查集」专题-8：并查集第-7-版（易于理解的路径压缩算法，复杂度较高，不用掌握）" class="headerlink" title="「并查集」专题 8：并查集第 7 版（易于理解的路径压缩算法，复杂度较高，不用掌握）"></a>「并查集」专题 8：并查集第 7 版（易于理解的路径压缩算法，复杂度较高，不用掌握）</h2><blockquote><p>重点提示：这一节了解即可。</p></blockquote><p>这个版本的并查集在 find 的时候做得更彻底，把在“查找”过程中沿途经过的“结点”直接指向了最终的根结点。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">UnionFind7</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> n    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        查找元素 p 根节点的编号        :param p:        :return:        """</span>        <span class="token keyword">assert</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> p <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>count        root <span class="token operator">=</span> p        <span class="token keyword">while</span> root <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">:</span>            root <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 此时 root 就是大 boss</span>        <span class="token comment" spellcheck="true"># 下面这一步就是最直接的路径压缩：</span>        <span class="token comment" spellcheck="true"># 把沿途查找过的结点都指向 root</span>        <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>            temp <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> root            p <span class="token operator">=</span> temp        <span class="token keyword">return</span> root    <span class="token keyword">def</span> <span class="token function">is_connected</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        查询元素 p 和 q 是否属于同一个集合        有共同的父亲，就表示它们属于同一个集合        :param p:        :param q:        :return:        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        合并元素 p 和元素 q 所属于的集合        O(n)复杂度        :param p:        :param q:        :return:        """</span>        p_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>p<span class="token punctuation">)</span>        q_id <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>q<span class="token punctuation">)</span>        <span class="token keyword">if</span> p_id <span class="token operator">==</span> q_id<span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment" spellcheck="true"># 任意指向即可</span>        self<span class="token punctuation">.</span>parent<span class="token punctuation">[</span>p_id<span class="token punctuation">]</span> <span class="token operator">=</span> q_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并查集」专题 7：quick-union 基于路径压缩的递归实现</title>
      <link href="/leetcode-algo/2017/10/22/leetcode-algo/union-find-set-07/"/>
      <url>/leetcode-algo/2017/10/22/leetcode-algo/union-find-set-07/</url>
      
        <content type="html"><![CDATA[<h2 id="「并查集」专题-7：quick-union-基于路径压缩的递归实现"><a href="#「并查集」专题-7：quick-union-基于路径压缩的递归实现" class="headerlink" title="「并查集」专题 7：quick-union 基于路径压缩的递归实现"></a>「并查集」专题 7：quick-union 基于路径压缩的递归实现</h2><blockquote><p>重点提示：这一节了解即可。</p></blockquote><p>代码的实现的理解有一些绕。这一版我们实现压缩更彻底的路径压缩。其实我们不看上面的分析，我们想象路径压缩的目的是什么，就是让我们的并查集表示的树结构层数更低，那么最优的情况应该是下面这样，把一棵树压缩成 $2$ 层，所有的结点都指向一个根，这才是把一个并查集压缩到最彻底的情况。</p><p><img src="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9-5.jpg" alt="高级数据结构：并查集-13"></p><p>那么，代码又应该如何实现呢？我们需要使用递归的思想。这一版代码的实现难点就在于：应该定义 <code>find(p)</code> <strong>返回的是 <code>p</code> 这个结点的父结点</strong>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 返回索引为 p 的元素的根结点 * 理解这个方法的关键点：我们就是要把这个结点的父结点指向根结点， * 既然父亲结点不是根结点，我们就继续拿父亲结点找根结点 * 一致递归找下去， * 最后返回的时候，写 parent[p] 是可以的 * 写 parent[parent[p]] 也是没有问题的 * * @param p * @return */</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在 find 的时候执行路径压缩</span>    <span class="token keyword">assert</span> p <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">&lt;</span> count<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 注意：这里是 if 不是 while，否则就变成循环</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这一行代码的逻辑要想想清楚</span>        <span class="token comment" spellcheck="true">// 只要不是根结点</span>        <span class="token comment" spellcheck="true">// 就把父亲结点指向父亲结点的父亲结点</span>        parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，我们来比较一下基于路径压缩的两种方法。</p><p><img src="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83.jpg" alt="高级数据结构：并查集-14"></p><p>并查集能够很好地帮助我们解决网络中两个结点是否连接的问题。但是，对于网络中的两个结点的路径，最短路径的问题，我们就要使用图来解决。</p><h3 id="关于路径压缩的思考"><a href="#关于路径压缩的思考" class="headerlink" title="关于路径压缩的思考"></a>关于路径压缩的思考</h3><p>写到这里，我们发现在路径压缩的过程中，我们之前引入的辅助合并的数组，不管是 <code>rank</code> 还是 <code>size</code>，它们的定义都不准确了，因为我们在路径压缩的过程中没有对它们的定义进行维护。这一点其实并不影响我们的算法的正确性，我们不去维护 <code>rank</code> 数组和 <code>size</code> 数组的定义，是因为第 1 点：难于实现，第 2 点： <code>rank</code> 数组还是 <code>size</code> 数组的当前实现仍然可以作为一个参考值，比起随机的做法要更有意义一些。</p><p>其实写到这里，数组 <code>rank</code> 还是数组 <code>size</code> 的意义都不太重要了，我们只须要在 <code>find</code> 的时候，做好路径压缩，把孩子结点指向父亲结点即可。 </p>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并查集」专题 6：quick-union 基于路径压缩的非递归实现</title>
      <link href="/leetcode-algo/2017/10/21/leetcode-algo/union-find-set-06/"/>
      <url>/leetcode-algo/2017/10/21/leetcode-algo/union-find-set-06/</url>
      
        <content type="html"><![CDATA[<h2 id="「并查集」专题-6：quick-union-基于路径压缩的非递归实现"><a href="#「并查集」专题-6：quick-union-基于路径压缩的非递归实现" class="headerlink" title="「并查集」专题 6：quick-union 基于路径压缩的非递归实现"></a>「并查集」专题 6：quick-union 基于路径压缩的非递归实现</h2><blockquote><p>重点提示：这一版代码用得最多。因为好理解，且代码量较少。</p><p>只用理解这一句即可 <code>parent[p] = parent[parent[p]];</code>，可以称之为「隔代压缩」。</p><p>虽然压缩不彻底，但是多压缩几次也就能够达到完全压缩的效果，且不使用递归，占用「递归栈」空间。</p></blockquote><p>什么是路径压缩 path Compression？以上我们都是针对于 <code>union</code> 操作的优化，其实我们在 <code>find</code> 的时候，就可以对一棵树进行整理，让它的高度变低，这一点是基于并查集的一个特性：只要它们是连在一起的，其实谁指向谁，并不重要，所以我们在接下来的讨论中看到的并查集的表示图，它们是等价的，即它们表示的都是同一个并查集。</p><p>路径压缩 path Compression 的思路：在 find 的时候一次又一次的整理，将并查集构造（整理）成一个与之等价的并查集，使得后续的每一次 find 这样的操作路径最短。</p><p>假设一个最极端的并查集的图表示如下：</p><img src="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/路径压缩-1.jpg" alt="高级数据结构：并查集-9" style="zoom:50%;" /><p>我们开始找 $4$ 的父亲结点，$4$ 的父亲结点不是 $4$ ，说明不是根结点，此时，我们尝试 $2$ 步一跳，将 $4$ 的父亲结点“改成”父亲结点的父亲结点，于是得到一个等价的并查集：</p><img src="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/路径压缩-2.jpg" alt="高级数据结构：并查集-10" style="zoom:50%;" /><p>下面我们该考察元素 $2$ 了，$2$ 的父亲结点是 $1$，$2$ 不是根结点，所以我们继续两步一跳，把 $2$ 的父亲结点设置成它的父亲结点的父亲结点，于是又得到一个等价的并查集：</p><img src="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/路径压缩-3.jpg" alt="高级数据结构：并查集-11" style="zoom:50%;" /><p>此时，整棵树的高度就在一次 <code>find</code> 的过程中被压缩了。这里有一个疑问：即使我们在最后只差一步的情况下，我们跳两步，也不会出现无效的索引。其实，一步一跳，两步一跳，甚至三步一跳都没有关系。</p><p>画图画了这么多，代码实现只有一行：<code>parent[p] = parent[parent[p]];</code> 编写的时候要注意这行代码添加的位置，画一个示意图，想想这个路径压缩的过程，就不难写出。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 在 find 的时候执行路径压缩</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 编写这句代码的时候可能会觉得有点绕，</span>        <span class="token comment" spellcheck="true">// 画一个示意图，就能很直观地写出正确的逻辑</span>        <span class="token comment" spellcheck="true">// 两步一跳完成路径压缩</span>        parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据上面的图，我们通过  <code>find</code> 操作执行路径压缩，最终形成的并查集如下：</p><img src="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/路径压缩-4.jpg" alt="高级数据结构：并查集-12" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并查集」专题 5：并查集第 4 版（quick-union 基于 rank 的优化）</title>
      <link href="/leetcode-algo/2017/10/20/leetcode-algo/union-find-set-05/"/>
      <url>/leetcode-algo/2017/10/20/leetcode-algo/union-find-set-05/</url>
      
        <content type="html"><![CDATA[<h2 id="「并查集」专题-5：并查集第-4-版（quick-union-基于-rank-的优化）"><a href="#「并查集」专题-5：并查集第-4-版（quick-union-基于-rank-的优化）" class="headerlink" title="「并查集」专题 5：并查集第 4 版（quick-union 基于 rank 的优化）"></a>「并查集」专题 5：并查集第 4 版（quick-union 基于 rank 的优化）</h2><blockquote><p>重点提示：基于 rank 的优化是使用得更多的，因为这样做更合理一些。</p><p>但是维护数组 <code>rank</code> 的定义是相对麻烦的，通常的做法就是不维护，只是把数组 <code>rank</code> 作为两个集合合并的参考，即使是错的，也比随机合并的结果好。</p></blockquote><p>使用 <code>size</code> 来决定将哪个结点的根指向另一个结点的根，其实并不太合理，但并不能说不正确，因为谁的根指向谁的根，其实都没有错，下面就是一个特殊的情况。</p><p>![高级数据结构：并查集-8](<a href="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/基于">https://liweiwei1419.gitee.io/images/algorithms/union-find-set/基于</a> size 合并不合理的地方.jpg)</p><p>因为我们总是期望这棵树的高度比较低，在这种情况下，我们在 <code>find</code> 的时候，就能通过很少的步数来找到根结点，进而提高 <code>find</code> 的效率。为此，我们引入 <code>rank</code> 数组，其定义是： <code>rank[i]</code> 表示以第 <code>i</code> 个元素为根的树的高度。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind4</span> <span class="token keyword">implements</span> <span class="token class-name">IUnionFind</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以索引为 i 的元素为根结点的树的深度（最深的那个深度）</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rank<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">UnionFind4</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> n<span class="token punctuation">;</span>        parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        rank <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 初始化时，所有的元素只包含它自己，只有一个元素，所以 rank[i] = 1</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">versionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"并查集的第 4 个版本，基于 parent 数组，quick-union，基于 rank"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回索引为 p 的元素的根结点</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 跟随链接找到根结点</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> qRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pRoot <span class="token operator">==</span> qRoot<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> qRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot <span class="token operator">==</span> qRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这一步是与第 3 版不同的地方</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span> <span class="token operator">=</span> pRoot<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">=</span> qRoot<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span> <span class="token operator">=</span> pRoot<span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 每次 union 以后，连通分量减 1</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并查集」专题 4：并查集第 3 版（quick-union 基于 size 的优化）</title>
      <link href="/leetcode-algo/2017/10/19/leetcode-algo/union-find-set-04/"/>
      <url>/leetcode-algo/2017/10/19/leetcode-algo/union-find-set-04/</url>
      
        <content type="html"><![CDATA[<h2 id="「并查集」专题-4：并查集第-3-版（quick-union-基于-size-的优化）"><a href="#「并查集」专题-4：并查集第-3-版（quick-union-基于-size-的优化）" class="headerlink" title="「并查集」专题 4：并查集第 3 版（quick-union 基于 size 的优化）"></a>「并查集」专题 4：并查集第 3 版（quick-union 基于 size 的优化）</h2><blockquote><p>重点提示：这一版「并查集」代码是最基本的「并查集」，我们需要学习思想，核心思想是「代表元法」，以「树」的「根结点」作为代表元。</p><p>后续我们介绍这一版代码的两个优化：</p><p>1、按秩合并（有 2 个版本）</p><p>2、路径压缩（有 2 个版本）</p><p>介绍得多，只是为了方便大家建立知识结构，真正我们只会使用一个版本的「并查集」。我们放在介绍完了以后再说。</p></blockquote><p>我们发现 <code>union 4,9</code> 与 <code>union 9,4</code> 其实是一样的，也就是把谁的根指向谁的根，这一点从正确性上来说是无关紧要的，但是对于 <code>find</code> 的时间复杂度就会有影响。为此，我们做如下优化。</p><p>在合并之前做判断，具体做法是，计算每一个结点有多少个元素直接或者间接地以它为根，我们应该将集合元素少的那结点的根指向集合元素多的那个结点的根。这样，形成的树就会更高概率地形成一棵层数较低的树。</p><p>为此，我们再引入一个 <code>size</code> 数组，<code>size[i]</code> 的定义是：以第 <code>i</code> 个结点为根的集合的元素的个数。</p><p>在初始化的时候 <code>size[i] = 1</code>，<code>find</code> 和 <code>isConnected</code> 操作中我们都不须要去维护 <code>size</code> 这个数组，唯独在 <code>unionElements</code> 的时候，我们才要维护 <code>size</code> 数组的定义。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// union-find 算法的实现（加权 quick-union 算法）</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind3</span> <span class="token keyword">implements</span> <span class="token class-name">IUnionFind</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第 i 个元素存放它的父元素的索引</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 连通分量的数量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 以当前索引为根的树所包含的元素的总数</span>    <span class="token keyword">public</span> <span class="token function">UnionFind3</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> n<span class="token punctuation">;</span>        parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 初始化时，所有的元素只包含它自己，只有一个元素，所以 size[i] = 1</span>            size<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">versionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"并查集的第 3 个版本，基于 parent 数组，quick-union，基于 size"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回索引为 p 的元素的根结点的索引</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 跟随链接找到根结点</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> qRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> pRoot <span class="token operator">==</span> qRoot<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> qRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot <span class="token operator">==</span> qRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这一步是与第 2 版不同的地方，我们不是没有根据地把一个结点的根结点的父结点指向另一个结点的根结点</span>        <span class="token comment" spellcheck="true">// 而是将小树的根结点连接到大树的根结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">></span> size<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span> <span class="token operator">=</span> pRoot<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">=</span> qRoot<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 每次 union 以后，连通分量减 1</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并查集」专题 3：基于 parent 的并查集（了解思想，非最终版本）</title>
      <link href="/leetcode-algo/2017/10/18/leetcode-algo/union-find-set-03/"/>
      <url>/leetcode-algo/2017/10/18/leetcode-algo/union-find-set-03/</url>
      
        <content type="html"><![CDATA[<h2 id="「并查集」专题-3：基于-parent-的并查集（了解思想，非最终版本）"><a href="#「并查集」专题-3：基于-parent-的并查集（了解思想，非最终版本）" class="headerlink" title="「并查集」专题 3：基于 parent 的并查集（了解思想，非最终版本）"></a>「并查集」专题 3：基于 parent 的并查集（了解思想，非最终版本）</h2><blockquote><p>重点提示：这一版「并查集」代码是最基本的「并查集」，我们需要学习思想，核心思想是「代表元法」，以「树」的「根结点」作为代表元。</p><p>后续我们介绍这一版代码的两个优化：</p><p>1、按秩合并（有 2 个版本）</p><p>2、路径压缩（有 2 个版本）</p><p>介绍得多，只是为了方便大家建立知识结构，真正我们只会使用一个版本的「并查集」。我们放在介绍完了以后再说。</p></blockquote><h3 id="并查集第-2-版：quick-union"><a href="#并查集第-2-版：quick-union" class="headerlink" title="并查集第 2 版：quick-union"></a>并查集第 2 版：quick-union</h3><p>我们不再使用 <code>id</code> 数组，而使用 <code>parent</code> 数组，parent 数组的定义是：<code>parent[i]</code> 表示索引为 <code>i</code> 的结点的父亲结点的索引，在这个定义下，<strong>根结点的父亲结点是自己</strong>。</p><img src="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/根结点的父亲结点是自己.jpg" alt="高级数据结构：并查集-5" style="zoom:35%;" /><p>此时查询结点 <code>p</code> 和结点 <code>q</code> 相连这件事情，就是我们分别追溯 <code>parent[p]</code> 和 <code>parent[q]</code> （可以看到这样的过程很像在一棵树中的操作），查询到 <code>parent[p]</code> 和 <code>parent[q]</code> 的根结点，如果根结点相同，那么它们就同属于一个集合。</p><p>这样看来，<code>find(int p)</code> 好像费点劲，这也是我们接来下的几个并查集优化的方向，都是在 <code>find(int p)</code> 上做文章，但这保证了 <code>union(int p, int q)</code> 很快，我们只需把<strong>其中一个结点的父结点指向另一个结点的根结点</strong>（而谁的父结点指向谁的根结点，也是我们后几版并查集优化的方向），就完成了 <code>union(int p, int q)</code> 的操作。此时 <code>union(int p, int q)</code> 的操作只须要一行代码：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java">parent<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">=</span> qRoot<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化的时候，我们将每个元素都指向自己，此时表示这 $10$ 个结点互相之间没有连接关系。如下表所示：</p><p><img src="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/%E5%BC%80%E5%A7%8B%E6%97%B6%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E9%83%BD%E6%8C%87%E5%90%91%E8%87%AA%E5%B7%B1.jpg" alt="高级数据结构：并查集-6"></p><p>上面的数组表示的并查集如下。</p><p><img src="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/%E5%BC%80%E5%A7%8B%E6%97%B6%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E9%83%BD%E6%8C%87%E5%90%91%E8%87%AA%E5%B7%B1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="高级数据结构：并查集-7"><br>从正确性上来说，谁的根指向谁的根都是可以的。但是在实际运行的时候，我们发现，我们应该将层级较少的根指向层级较多的根，这样做是为了保证我们的并查集形成的树的高度不会增加，这样在 <code>find</code> 的时候，追溯的层数不会增加。我们在查找根的时候，应该使得查找的层数最少。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind2</span> <span class="token keyword">implements</span> <span class="token class-name">IUnionFind</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第 i 个元素存放它的父元素的索引</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 连通分量的数量</span>    <span class="token keyword">public</span> <span class="token function">UnionFind2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> n<span class="token punctuation">;</span>        parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">versionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"并查集的第 2 个版本，基于 parent 数组，quick-union"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 跟随链接找到根结点</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 只要不是根结点</span>            p <span class="token operator">=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 p 归并与之相同的分量中</span>        <span class="token keyword">int</span> qRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 q 归并与之相同的分量中</span>        <span class="token comment" spellcheck="true">// 如果 p 和 q 已经在相同的分量之中，则什么都不做</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot <span class="token operator">==</span> qRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果 parent[qRoot] = pRoot; 也是可以的，即将其中一个结点指向另一个结点</span>        parent<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">=</span> qRoot<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 每次 union 以后，连通分量减 1</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并查集」专题 2：并查集第 1 版（quick-find）</title>
      <link href="/leetcode-algo/2017/10/17/leetcode-algo/union-find-set-01/"/>
      <url>/leetcode-algo/2017/10/17/leetcode-algo/union-find-set-01/</url>
      
        <content type="html"><![CDATA[<h2 id="「并查集」专题-2：并查集第-1-版（quick-find）"><a href="#「并查集」专题-2：并查集第-1-版（quick-find）" class="headerlink" title="「并查集」专题 2：并查集第 1 版（quick-find）"></a>「并查集」专题 2：并查集第 1 版（quick-find）</h2><h3 id="重点提示"><a href="#重点提示" class="headerlink" title="重点提示"></a>重点提示</h3><p>基于 <code>id</code> 的思想类似于：给每个元素改名字，名字一样，就表示在同一个集合中。</p><ul><li><p>优点：查询两个元素是否在一个集合中很快。</p></li><li><p>缺点：把两个集合合并成一个集合较慢。</p></li></ul><p>这一版「并查集」并不常用，仅作为了解。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>并查集可以使用数组表示。这个数组我们命名为 <code>id</code> 。初始化的时候每一个元素的值都是不一样的。如果值一样的，表示是属于同一个集合内的元素。</p><p>基于 <code>id</code> 的 quick-find 的思路：设置 <code>id</code> 数组，数组的每个元素是分量标识。</p><p>从 quick-find 这个名字上看，我们这一版的实现，对于 <code>find(int p)</code> 这个操作来说是高效的，但对于 <code>union(int p, int q)</code> 这个操作是低效的，因为需要遍历整个并查集。<code>find(int p)</code> 这个操作的时间复杂度是 $O(1)$，而 <code>union(int p, int q)</code> 这个操作的时间复杂度是 $O(n)$，要全部遍历并查集中的元素，把其中一个分量标识的所有结点的编号更改为另一个一个分量标识。</p><p>![高级数据结构：并查集-4](<a href="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/基于">https://liweiwei1419.gitee.io/images/algorithms/union-find-set/基于</a> id 并查集算法的例子.jpg)</p><p>例如上面的表格中，如果我们要将第 $1$ 行的 <code>0</code> 和 <code>1</code> 执行 <code>union(int p, int q)</code> 操作，有两种方式：</p><p>第 1 种方式：把第 1 行的 <code>0</code>，<code>2</code>，<code>4</code>，<code>6</code>，<code>8</code> 的值全改成 <code>1</code>；</p><p>第 2 种方式：把第 1 行的 <code>1</code>，<code>3</code>，<code>5</code>，<code>7</code>，<code>9</code> 的值全改成 0。</p><p>可以看到，<code>union(int p, int q)</code> 的操作和问题的规模成正比，所以 quick-find 思想（基于 <code>id</code>）的 <code>union(int p, int q)</code> 操作时间复杂度是 $O(n)$。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind1</span> <span class="token keyword">implements</span> <span class="token class-name">IUnionFind</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> id<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分量 id</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 连通分量的数量</span>    <span class="token keyword">public</span> <span class="token function">UnionFind1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化分量 id 数组</span>        id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">versionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"并查集的第 1 个版本，基于 id 数组，quick-find"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 以常数时间复杂度，返回分量的标识符，与并查集的规模是无关的，这一步很快</span>    <span class="token comment" spellcheck="true">// 因此我们称这个版本的并查集是 quick-find</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 因为需要遍历数组中的全部元素，所以这个版本其实效率并不高</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> qid <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果 p 和 q 已经在相同的分量之中，则什么都不做</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> qid<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将 p 的分量重新命名为 q 的名称</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> id<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> pid<span class="token punctuation">)</span> <span class="token punctuation">{</span>                id<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> qid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 每次 union 以后，连通分量减 1</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用数组 <code>id</code> 在进行 <code>union(int p, int q)</code> 的时候，要遍历整个数组中的结点，这种方式效率不高，因此，我们换一种思路：由于 <code>union(int p, int q)</code> 慢，所以我们就想办法让 <code>union(int p, int q)</code> 快起来。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并查集」专题 1：并查集简介</title>
      <link href="/leetcode-algo/2017/10/16/leetcode-algo/union-find-set-01/"/>
      <url>/leetcode-algo/2017/10/16/leetcode-algo/union-find-set-01/</url>
      
        <content type="html"><![CDATA[<h2 id="「并查集」专题-1：并查集简介"><a href="#「并查集」专题-1：并查集简介" class="headerlink" title="「并查集」专题 1：并查集简介"></a>「并查集」专题 1：并查集简介</h2><h3 id="重点提示"><a href="#重点提示" class="headerlink" title="重点提示"></a>重点提示</h3><blockquote><ul><li>「并查集」是一种建立在「数组」上的树形结构，并且这棵树是<strong>孩子结点指向父亲结点的</strong>；</li><li>「并查集」主要用于解决「连通性」问题，重点关注的是我和你是不是朋友，但是我们是几层朋友关系，并不重要；</li><li>「并查集」是树，所以优化的策略依然是和树的高度较劲，优化思路有「按秩合并」与「路径压缩」。</li></ul></blockquote><p>「并查集」主要知识点如下：</p><p><img src="http://liweiwei1419.gitee.io/visualgo/union-find/union-find.png" alt=""></p><p>「并查集」这部分知识点讲得最清楚的是《算法》（第 4 版），本篇「并查集」的介绍是我看这本书第 1.5 节的学习笔记。</p><p><img src="https://liweiwei1419.gitee.io/images/algorithms/union-find-set/union-find-set.png" alt="高级数据结构：并查集-1"></p><p><img src="http://upload-images.jianshu.io/upload_images/414598-bf471f68f451da98.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="高级数据结构：并查集-2"></p><p><img src="http://upload-images.jianshu.io/upload_images/414598-fa371f5257341bd1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="高级数据结构：并查集-3"></p><h3 id="什么是「并查集」"><a href="#什么是「并查集」" class="headerlink" title="什么是「并查集」"></a>什么是「并查集」</h3><p>我们知道，「堆」是一种建立在数组上的「树结构」，在这一章，我们向大家介绍的数据结构同样也是建立在数组上的树结构，这个数据结构叫做「并查集」（Union-Find），「并查集」也叫做「不相交集合」（Disjion-Sets）。</p><p>「并查集」的设计思想很简单，易于理解，且代码编写容易，难点在于如何应用并查集的思想解决问题。能够使用并查集解决的问题一般来说都比较生活化，还比较有趣。</p><p>在这里需要和大家说明的是：并查集的问题在面试中的占比较少，并且由于并查集问题通常不以并查集为背景，故「力扣」上「并查集」的问题一般被标记为「中等」和「困难」。</p><blockquote><p>建议：完成「力扣」上的一些经典和常见问题即可。在时间比较充裕的情况下，才考虑完成一些你所感兴趣的，较难的问题。</p></blockquote><h3 id="什么是「并」和「查」"><a href="#什么是「并」和「查」" class="headerlink" title="什么是「并」和「查」"></a>什么是「并」和「查」</h3><p>并查集主要提供了以下两个操作，并别就是「并查集」这个名字中的前两个字：</p><p>1、我们先说「并」：并是把两个集合合并成一个集合，表示这两个集合之间产生连接；</p><p>2、再说「查」：查询元素属于哪个集合，但我们更经常用于查询两个元素是不是连接在一起</p><p>这两个操作其实在我们的生活中都能看到影子。我们和人见面，最先问的几句话可能就是“你是哪里人”、“你在哪上班”、“你是做什么工作的”。根据询问到的结果，判断我们是不是适合做同事、做朋友。</p><p>因此，如果我们在一些场景下，只需要查询两个事物之间是否有联系，「并查集」就是一个不错的选择。例如：查询两个人是不是好友关系（「力扣」第 547 题：「朋友圈」），查询从一个地方到另一个地方是否能走通（「力扣」第 130 题：被包围的区域）。</p><h3 id="「并查集」与「路径问题」"><a href="#「并查集」与「路径问题」" class="headerlink" title="「并查集」与「路径问题」"></a>「并查集」与「路径问题」</h3><p>并查集主要用于解决连通问题，即抽象概念中结点和结点是否连接。</p><p>路径问题，不仅仅要考虑连通问题，我们还要往往还需要求出最短路径，这不是并查集做的事情。因此<strong>并查集问题能做的事情比路径问题少，它更专注于</strong></p><ul><li>判断连接状态（查）；</li><li>改变连接状态（并）。</li></ul><p>具体说来，并查集的代码需要实现以下的 3 个功能：</p><p>1、 <code>find(p)</code>：查找元素 <code>p</code> 所对应的集合，</p><p>说明：这个函数有些时候仅作为私有函数被下面两个函数调用。</p><p>2、 <code>union(p, q)</code>：合并元素 <code>p</code> 和元素 <code>q</code> 所在的集合。</p><p>3、 <code>connected(p, q)</code>：查询元素 <code>p</code> 和元素 <code>q</code> 是不是在同一个集合中。</p><p>因此，我们要实现的并查集其实就是要实现下面的这个接口：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IUnionFind</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 并查集的版本名称，由开发者指定</span>    String <span class="token function">versionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// p (0 到 N-1)所在的分量的标识符</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 p 和 q 存在于同一分量中则返回 true</span>    <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在 p 与 q 之间添加一条连接</span>    <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>特别注意：马上我们将会看到，其实「并查集」是一棵树，这棵树与以往我们构建树的方式大不相同，「并查集」构建的树从「孩子结点」指向「父亲结点」。这一点是「并查集」的特色。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 11： 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 199 题： 二叉树的右视图</title>
      <link href="/leetcode-algo/2017/10/05/leetcode-solution/0199-binary-tree-right-side-view/"/>
      <url>/leetcode-algo/2017/10/05/leetcode-solution/0199-binary-tree-right-side-view/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-199-题：-二叉树的右视图"><a href="#「力扣」第-199-题：-二叉树的右视图" class="headerlink" title="「力扣」第 199 题： 二叉树的右视图"></a>「力扣」第 199 题： 二叉树的右视图</h2><p>传送门：<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a>。</p><blockquote><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例:</strong></p><pre><code>输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释:1            &lt;---/   \2     3         &lt;---\     \5     4       &lt;---</code></pre></blockquote><p>分析：1、深度优先遍历；2、层序遍历（2种写法，本质上其实一样）。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 199. 二叉树的右视图</span><span class="token comment" spellcheck="true"># 给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> res<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> node <span class="token keyword">is</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> depth<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> res<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> res<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 9：队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 295 题：数据流的中位数（中等）</title>
      <link href="/leetcode-algo/2017/10/05/algorithms-and-data-structures/0295-find-median-from-data-stream/"/>
      <url>/leetcode-algo/2017/10/05/algorithms-and-data-structures/0295-find-median-from-data-stream/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-295-题：数据流的中位数（中等）"><a href="#「力扣」第-295-题：数据流的中位数（中等）" class="headerlink" title="「力扣」第 295 题：数据流的中位数（中等）"></a>「力扣」第 295 题：数据流的中位数（中等）</h2><p>传送门：<a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a>。</p><p>题解地址：<a href="https://leetcode-cn.com/problems/find-median-from-data-stream/solution/you-xian-dui-lie-python-dai-ma-java-dai-ma-by-liwe/" target="_blank" rel="noopener">优先队列（Python 代码、Java 代码）</a>。</p><blockquote><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p><code>[2, 3, 4]</code> 的中位数是 3</p><p><code>[2, 3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code></p><p>设计一个支持以下两种操作的数据结构：</p><ul><li><code>void addNum(int num)</code> - 从数据流中添加一个整数到数据结构中。</li><li><code>double findMedian()</code> - 返回目前所有元素的中位数。<br>示例：</li></ul><pre><code>addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2</code></pre><p>进阶：</p><ol><li>如果数据流中所有整数都在 $0$ 到 $100$ 范围内，你将如何优化你的算法？</li><li>如果数据流中 $99%$ 的整数都在 $0$ 到 $100$ 范围内，你将如何优化你的算法？</li></ol></blockquote><p><strong>思路分析</strong>：</p><p>一种最容易想到的思路是，数据流新进来一个数，都把它与已经读出来的数进行一次排序，这样中位数就可以很容易得到。这样做“不好”的地方是：</p><blockquote><p>排序的时间复杂度为 $O(N\log N)$，但事实上，我对除了中位数以外的其它位置的元素并不关心。</p></blockquote><p>事实上，我们只关心在中间的那两个数（或者一个数），其它数没有必要进行 “比较” 和 “交换” 的操作。</p><p>在我们学习过的数据结构里，堆就有类似的性质，每次都从堆里得到一个 “最值” 而其它元素无需排序，这样就可以以 $O(\log N)$ 的复杂度每次都从堆中取出最值。</p><p><img src="https://pic.leetcode-cn.com/2cf3d6ff9a0cdb4c59bf147484f72b00171258b479ea67bf52eab21a98951a60-295-1.png" alt="295-1.png">),<img src="https://pic.leetcode-cn.com/097aa5c741baf38904d2caacf69df2d74a6c1a0cd8cb77015c7d255fc966f854-295-2.png" alt="295-2.png">),<img src="https://pic.leetcode-cn.com/cea320b4ada8684abc2db0ef24fec4d539a923ffcd8c756f4b2851cabf07e588-295-3.png" alt="295-3.png">),<img src="https://pic.leetcode-cn.com/94d648b40f1a72ed7984e6fc0828f52d8947761582071a2c1268d4e750006664-295-4.png" alt="295-4.png"></p><p><strong>请读者在看完以上思路之后思考</strong>：</p><p>1、数据是如何在两个堆之间流动的，<strong>脑子里要建立如下动态的过程：为了找到添加新数据以后，数据流的中位数，我们让这个新数据在大顶堆和小顶堆中都走了一遍。而为了让大顶堆的元素多 $1$ 个，我们让从小顶堆中又拿出一个元素“送回”给大顶堆</strong>；</p><p>2、将元素放入优先队列以后，优先队列会以对数时间复杂度自行调整，把“最优值”放入堆顶，这是使用优先队列解决这个问题的原因。如果不太熟悉优先队列的朋友们，请复习一下优先队列的相关知识，包括基本操作，理解上浮和下沉。</p><p><strong>说明：</strong> 这道题使用 Java 编码看起来思路更清晰一些，在 Python 中的堆只有小顶堆，在构造大顶堆的时候，要绕一个弯子，具体请看如下参考代码。</p><p><strong>参考代码</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.PriorityQueue;public class MedianFinder {    /**     * 当前大顶堆和小顶堆的元素个数之和     */    private int count;    private PriorityQueue<Integer> maxheap;    private PriorityQueue<Integer> minheap;    /**     * initialize your data structure here.     */    public MedianFinder() {        count = 0;        maxheap = new PriorityQueue<>((x, y) -> y - x);        minheap = new PriorityQueue<>();    }    public void addNum(int num) {        count += 1;        maxheap.offer(num);        minheap.add(maxheap.poll());        // 如果两个堆合起来的元素个数是奇数，小顶堆要拿出堆顶元素给大顶堆        if ((count & 1) != 0) {            maxheap.add(minheap.poll());        }    }    public double findMedian() {        if ((count & 1) == 0) {            // 如果两个堆合起来的元素个数是偶数，数据流的中位数就是各自堆顶元素的平均值            return (double) (maxheap.peek() + minheap.peek()) / 2;        } else {            // 如果两个堆合起来的元素个数是奇数，数据流的中位数大顶堆的堆顶元素            return (double) maxheap.peek();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">import heapqclass MedianFinder:    def __init__(self):        # 当前大顶堆和小顶堆的元素个数之和        self.count = 0        self.max_heap = []        self.min_heap = []    def addNum(self, num: int) -> None:        self.count += 1        # 因为 Python 中的堆默认是小顶堆，所以要传入一个 tuple，用于比较的元素需是相反数，        # 才能模拟出大顶堆的效果        heapq.heappush(self.max_heap, (-num, num))        _, max_heap_top = heapq.heappop(self.max_heap)        heapq.heappush(self.min_heap, max_heap_top)        if self.count & 1:            min_heap_top = heapq.heappop(self.min_heap)            heapq.heappush(self.max_heap, (-min_heap_top, min_heap_top))    def findMedian(self) -> float:        if self.count & 1:            # 如果两个堆合起来的元素个数是奇数，数据流的中位数大顶堆的堆顶元素            return self.max_heap[0][1]        else:            # 如果两个堆合起来的元素个数是偶数，数据流的中位数就是各自堆顶元素的平均值            return (self.min_heap[0] + self.max_heap[0][1]) / 2# Your MedianFinder object will be instantiated and called as such:# obj = MedianFinder()# obj.addNum(num)# param_2 = obj.findMedian()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：$O(\log N)$，优先队列的出队入队操作都是对数级别的，数据在两个堆中间来回操作是常数级别的，综上时间复杂度是 $O(\log N)$ 级别的。</p></li><li><p>空间复杂度：$O(N)$，使用了三个辅助空间，其中两个堆的空间复杂度是 $O(\cfrac{N}{2})$，一个表示数据流元素个数的计数器 <code>count</code>，占用空间 $O(1)$，综上空间复杂度为 $O(N)$。</p></li></ul><hr><h3 id="使用自己实现的“大顶堆”-和-“小顶堆”"><a href="#使用自己实现的“大顶堆”-和-“小顶堆”" class="headerlink" title="使用自己实现的“大顶堆” 和 “小顶堆”"></a>使用自己实现的“大顶堆” 和 “小顶堆”</h3><p>以下内容仅供参考。</p><p>下面给出一个使用 Python 从“上浮”和“下沉”底层操作，“大顶堆” 和 “小顶堆” 的实现的示例代码，目的是为了验证自己写的 “大顶堆” 和 “小顶堆” 是否正确。</p><p>从底层编写“优先队列”的步骤，可以参考我的笔记 <a href="https://www.liwei.party/2019/01/10/algorithms-and-data-structures/priority-queue/" target="_blank" rel="noopener">《【算法日积月累】9-堆与优先队列》</a>，特别欢迎您给出意见和建议。</p><blockquote><p><strong>为了验证自己写的底层代码是否正确，把自己写的底层数据结构用于完成 LeetCode 的问题，让自己的数据结构经过 LeetCode 测试用例的检测，是一个很不错的办法。</strong></p></blockquote><p><strong>参考代码 2</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class MaxHeap:    def __init__(self, capacity):        # 我们这个版本的实现中，0 号索引是不存数据的，这一点一定要注意        # 因为数组从索引 1 开始存放数值        # 所以开辟 capacity + 1 这么多大小的空间        self.data = [None for _ in range(capacity + 1)]        # 当前堆中存储的元素的个数        self.count = 0        # 堆中能够存储的元素的最大数量（为简化问题，不考虑动态扩展）        self.capacity = capacity    def size(self):        """        返回最大堆中的元素的个数        :return:        """        return self.count    def is_empty(self):        """        返回最大堆中的元素是否为空        :return:        """        return self.count == 0    def insert(self, item):        if self.count + 1 > self.capacity:            raise Exception('堆的容量不够了')        self.count += 1        self.data[self.count] = item        # 考虑将它上移        self.__swim(self.count)    def __shift_up(self, k):        # 有索引就要考虑索引越界的情况，已经在索引 1 的位置，就没有必要上移了        while k > 1 and self.data[k // 2] < self.data[k]:            self.data[k // 2], self.data[k] = self.data[k], self.data[k // 2]            k //= 2    def __swim(self, k):        # 上浮，与父结点进行比较        temp = self.data[k]        # 有索引就要考虑索引越界的情况，已经在索引 1 的位置，就没有必要上移了        while k > 1 and self.data[k // 2] < temp:            self.data[k] = self.data[k // 2]            k //= 2        self.data[k] = temp    def extract_max(self):        if self.count == 0:            raise Exception('堆里没有可以取出的元素')        ret = self.data[1]        self.data[1], self.data[self.count] = self.data[self.count], self.data[1]        self.count -= 1        self.__sink(1)        return ret    def __shift_down(self, k):        # 只要有左右孩子，左右孩子只要比自己大，就交换        while 2 * k <= self.count:            # 如果这个元素有左边的孩子            j = 2 * k            # 如果有右边的孩子，大于左边的孩子，就好像左边的孩子不存在一样            if j + 1 <= self.count and self.data[j + 1] > self.data[j]:                j = j + 1            if self.data[k] >= self.data[j]:                break            self.data[k], self.data[j] = self.data[j], self.data[k]            k = j    def __sink(self, k):        # 下沉        temp = self.data[k]        # 只要它有孩子，注意，这里的等于号是十分关键的        while 2 * k <= self.count:            j = 2 * k            # 如果它有右边的孩子，并且右边的孩子大于左边的孩子            if j + 1 <= self.count and self.data[j + 1] > self.data[j]:                # 右边的孩子胜出，此时可以认为没有左孩子                j += 1            # 如果当前的元素的值，比右边的孩子节点要大，则逐渐下落的过程到此结束            if temp >= self.data[j]:                break            # 否则，交换位置，继续循环            self.data[k] = self.data[j]            k = j        self.data[k] = tempclass MinHeap:    # 把最大堆实现中不等号的方向反向就可以了    def __init__(self, capacity):        # 因为数组从索引 1 开始存放数值        # 所以开辟 capacity + 1 这么多大小的空间        self.data = [0 for _ in range(capacity + 1)]        self.count = 0        self.capacity = capacity    def size(self):        return self.count    def is_empty(self):        return self.count == 0    def insert(self, item):        if self.count + 1 > self.capacity:            raise Exception('堆的容量不够了')        self.count += 1        self.data[self.count] = item        self.__swim(self.count)    def __swim(self, k):        # 上浮，与父节点进行比较        temp = self.data[k]        while k > 1 and self.data[k // 2] > temp:            self.data[k] = self.data[k // 2]            k //= 2        self.data[k] = temp    def extract_min(self):        if self.count == 0:            raise Exception('堆里没有可以取出的元素')        ret = self.data[1]        self.data[1] = self.data[self.count]        self.count -= 1        self.__sink(1)        return ret    def __sink(self, k):        # 下沉        temp = self.data[k]        while 2 * k <= self.count:            j = 2 * k            if j + 1 <= self.count and self.data[j + 1] < self.data[j]:                j += 1            if temp <= self.data[j]:                break            self.data[k] = self.data[j]            k = j        self.data[k] = tempclass MedianFinder:    def __init__(self):        """        initialize your data structure here.        """        # 如果测试用例的容量增加，下面 10000 这个数值请大家自行调整        self.max_heap = MaxHeap(10000)        self.min_heap = MinHeap(10000)    def addNum(self, num: 'int') -> 'None':        # 大顶堆先进一个元素        self.max_heap.insert(num);        # 然后从大顶堆里出一个元素到小顶堆        self.min_heap.insert(self.max_heap.extract_max())        if self.max_heap.size() < self.min_heap.size():            # 如果大顶堆的元素少于小顶堆            # 就要从小顶堆出一个元素到大顶堆            self.max_heap.insert(self.min_heap.extract_min())    def findMedian(self) -> 'float':        if self.max_heap.size() == self.min_heap.size():            return (self.max_heap.data[1] + self.min_heap.data[1]) / 2        else:            return self.max_heap.data[1]# Your MedianFinder object will be instantiated and called as such:# obj = MedianFinder()# obj.addNum(num)# param_2 = obj.findMedian()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><Vssue title="find-median-from-data-stream"/>]]></content>
      
      
      <categories>
          
          <category> 专题 10：优先队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 107 题：二叉树的层次遍历 II</title>
      <link href="/leetcode-algo/2017/10/04/leetcode-solution/0107-binary-tree-level-order-traversal-ii/"/>
      <url>/leetcode-algo/2017/10/04/leetcode-solution/0107-binary-tree-level-order-traversal-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-107-题：二叉树的层次遍历-II"><a href="#「力扣」第-107-题：二叉树的层次遍历-II" class="headerlink" title="「力扣」第 107 题：二叉树的层次遍历 II"></a>「力扣」第 107 题：二叉树的层次遍历 II</h2><p>传送门：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. 二叉树的层次遍历 II</a>。</p><blockquote><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><pre><code> 3/ \9  20 /  \15   7</code></pre><p>返回其自底向上的层次遍历为：</p><pre><code>[[15,7],[9,20],[3]]</code></pre></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrderBottom</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[List[int]]        """</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> res        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            size <span class="token operator">=</span> len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            cur <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>                top <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                cur<span class="token punctuation">.</span>append<span class="token punctuation">(</span>top<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> top<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>top<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> top<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>top<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cur<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrderBottom</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> curLevel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                curLevel<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> curLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 9：队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「优先队列」专题 4：典型问题</title>
      <link href="/leetcode-algo/2017/10/04/leetcode-solution/priority-queue/"/>
      <url>/leetcode-algo/2017/10/04/leetcode-solution/priority-queue/</url>
      
        <content type="html"><![CDATA[<h2 id="「优先队列」专题-4：典型问题"><a href="#「优先队列」专题-4：典型问题" class="headerlink" title="「优先队列」专题 4：典型问题"></a>「优先队列」专题 4：典型问题</h2><h3 id="例题：LeetCode-第-347-题：前K个高频元素"><a href="#例题：LeetCode-第-347-题：前K个高频元素" class="headerlink" title="例题：LeetCode 第 347 题：前K个高频元素"></a>例题：LeetCode 第 347 题：前K个高频元素</h3><p>传送门：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前K个高频元素</a>。</p><blockquote><p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong> 高的元素。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [1], k = 1输出: [1]</code></pre><p><strong>说明：</strong></p><ul><li>你可以假设给定的 <em>k</em> 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度<strong>必须</strong>优于 O(<em>n</em> log <em>n</em>) , <em>n</em> 是数组的大小。</li></ul></blockquote><p>分析：“<strong>你的算法的时间复杂度必须优于</strong> <strong>O(n log n) , n 是数组的大小</strong>”。这是题目对我们的要求，我们很容易想到的一种思路是将 counter 以后的数据对 value 进行排序，但即使是最好的排序算法，时间复杂度也是 $O(n \log n)$，换言之，题目限制了我们不能使用排序算法。那么，对于前 k 这样的问题，一个很自然的思路就是使用优先队列，想到这一点，这道问题就是一个常规问题了。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">topKFrequent</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: List[int]        """</span>        <span class="token keyword">import</span> heapq        <span class="token keyword">import</span> collections        <span class="token comment" spellcheck="true"># 堆有序数组</span>        l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        wordcount <span class="token operator">=</span> collections<span class="token punctuation">.</span>defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            wordcount<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> key<span class="token punctuation">,</span> val <span class="token keyword">in</span> wordcount<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span>val<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            _<span class="token punctuation">,</span> key <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>l<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习：LeetCode-第-23-题：合并K个排序链表"><a href="#练习：LeetCode-第-23-题：合并K个排序链表" class="headerlink" title="练习：LeetCode 第 23 题：合并K个排序链表"></a>练习：LeetCode 第 23 题：合并K个排序链表</h3><p>传送门：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a>。</p><blockquote><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><pre><code>输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre></blockquote><p>思路1：使用优先队列。这是一道类似于教科书上例题的问题。这里我们举生活中的例子来理解求解思路，其实一点都不难。</p><p>假设有如下生活情境：假设你是一名体育老师，<strong>有</strong> <strong>3</strong> <strong>个班的学生，他们已经按照身高从矮到高排好成了</strong> <strong>3</strong> <strong>列纵队</strong>，现在要把这 3 个班的学生也按照身高从矮到高排列一列纵队。</p><p>我们可以这么做：</p><p>1、让 3 个班的学生按列站在你的面前，这时你能看到站在队首的学生的全身，其余同学只能看到比前面同学脑袋高出的那部分；</p><p>2、每一次队首的 3 名同学，请出最矮的同学出列到“队伍4”（即我们最终认为排好序的队列），出列的这一列的后一名同学向前走一步；</p><p>3、重复第 2 步，直到 3 个班的同学全部出列完毕。</p><p>Python2 代码：注意：以下代码在 Python2 中可以通过，Python3 中的 heapq 不支持传入自定义对象，不过可以绕一个弯子，把索引号传进去就可以了</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lists<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type lists: List[ListNode]        :rtype: ListNode        """</span>        <span class="token keyword">import</span> heapq        l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> head <span class="token keyword">in</span> lists<span class="token punctuation">:</span>            <span class="token keyword">if</span> head<span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">)</span>        dummy_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cur <span class="token operator">=</span> dummy_node        <span class="token keyword">while</span> l<span class="token punctuation">:</span>            _<span class="token punctuation">,</span> head <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>l<span class="token punctuation">)</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            <span class="token keyword">if</span> head<span class="token punctuation">.</span>next<span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">,</span> head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dummy_node<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python3 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lists<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type lists: List[ListNode]        :rtype: ListNode        """</span>        <span class="token keyword">import</span> heapq        l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>lists<span class="token punctuation">)</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> lists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token punctuation">(</span>lists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span>        dummy_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cur <span class="token operator">=</span> dummy_node        <span class="token keyword">while</span> l<span class="token punctuation">:</span>            _<span class="token punctuation">,</span> index <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>l<span class="token punctuation">)</span>            head <span class="token operator">=</span> lists<span class="token punctuation">[</span>index<span class="token punctuation">]</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            <span class="token keyword">if</span> head<span class="token punctuation">.</span>next<span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span>                lists<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">.</span>next                head<span class="token punctuation">.</span>next <span class="token operator">=</span> None        <span class="token keyword">return</span> dummy_node<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：分治。<strong>还可以采用归并排序的分治思想来解决，代码结构和归并排序可以说是同出一辙。</strong></p><p>1、先一分为二地解决了这个问题；</p><p>2、再考虑如何合并，这个合并的过程也是一个递归方法。 </p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lists<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type lists: List[ListNode]        :rtype: ListNode        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>lists<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__merge_k_lists<span class="token punctuation">(</span>lists<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__merge_k_lists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lists<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> left <span class="token operator">>=</span> right<span class="token punctuation">:</span>            <span class="token keyword">return</span> lists<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        listnode1 <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_k_lists<span class="token punctuation">(</span>lists<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>        listnode2 <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_k_lists<span class="token punctuation">(</span>lists<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__merge_two_sorted_list_node<span class="token punctuation">(</span>listnode1<span class="token punctuation">,</span> listnode2<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__merge_two_sorted_list_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> list1<span class="token punctuation">,</span> list2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> list1 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> list2        <span class="token keyword">if</span> list2 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> list1        <span class="token keyword">if</span> list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            list1<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list_node<span class="token punctuation">(</span>list1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> list2<span class="token punctuation">)</span>            <span class="token keyword">return</span> list1        <span class="token keyword">else</span><span class="token punctuation">:</span>            list2<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list_node<span class="token punctuation">(</span>list1<span class="token punctuation">,</span> list2<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            <span class="token keyword">return</span> list2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 10：优先队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 103 题：二叉树的锯齿形层次遍历</title>
      <link href="/leetcode-algo/2017/10/03/leetcode-solution/0103-binary-tree-zigzag-level-order-traversal/"/>
      <url>/leetcode-algo/2017/10/03/leetcode-solution/0103-binary-tree-zigzag-level-order-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-103-题：二叉树的锯齿形层次遍历"><a href="#「力扣」第-103-题：二叉树的锯齿形层次遍历" class="headerlink" title="「力扣」第 103 题：二叉树的锯齿形层次遍历"></a>「力扣」第 103 题：二叉树的锯齿形层次遍历</h2><p>传送门：<a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层次遍历</a>。</p><blockquote><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><pre><code> 3/ \9  20 /  \15   7</code></pre><p>返回锯齿形层次遍历如下：</p><pre><code>[[3],[20,9],[15,7]]</code></pre></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[List[int]]        """</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        turn_left <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            cur_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            size <span class="token operator">=</span> len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>                top <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> turn_left<span class="token punctuation">:</span>                    cur_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>top<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    cur_list<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> top<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> top<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>top<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> top<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>top<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_list<span class="token punctuation">)</span>            turn_left <span class="token operator">=</span> <span class="token operator">not</span> turn_left        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 9：队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「优先队列」专题 3：索引堆</title>
      <link href="/leetcode-algo/2017/10/03/algorithms-and-data-structures/index-heap/"/>
      <url>/leetcode-algo/2017/10/03/algorithms-and-data-structures/index-heap/</url>
      
        <content type="html"><![CDATA[<h2 id="「队列」专题-3：索引堆"><a href="#「队列」专题-3：索引堆" class="headerlink" title="「队列」专题 3：索引堆"></a>「队列」专题 3：索引堆</h2><p>索引堆是一个相对于普通堆更加高级的数据结构。</p><h3 id="为什么要引入索引堆这个数据结构？"><a href="#为什么要引入索引堆这个数据结构？" class="headerlink" title="为什么要引入索引堆这个数据结构？"></a>为什么要引入索引堆这个数据结构？</h3><p>在一些场景下，堆这个数据结构不高效，或者说功能不够用：</p><p>1、如果元素是非常复杂的结构（例如是长字符串），交换这件事情会产生大量的性能消耗；</p><p>我们之前在堆中的操作有大量地交换操作，这种直接交换内存的操作，在元素占用内存比较小的时候，并没有多少性能的消耗，但是当须交换位置的元素占用内存很大的时候，此时交换两个元素的内存就不可以被忽视，于是，我们就想通过给堆中的每个元素映射一个标识，也就是我们这一节提到的索引。通过索引的操作来实现元素的操作。</p><p>通过索引可以找到我们真正存放在数组中的元素，而索引所代表数据构成一个最大堆。</p><p>举一个可能不是很恰当的生活中的例子，我们要给一组学生按照身高进行排序，我们不用把他们全部喊出来让他们从矮到高排好，我们只要让他们报上自己的身高，在纸上做他们身高的比较就可以了。</p><p>2、元素位置发生改变以后，很难再次索引到它，例如：我们想要将原来索引是 $6$ 的元素的优先级提升或者下降一下，但是我们不知道原来索引是 $6$ 的元素到底是谁了。</p><p>想一想为什么没有索引就不能支持 <code>change</code>，因为索引不到原来的数据，因此我就不知道要 <code>change</code> 哪个数据，除非遍历一遍整个数组元素。</p><p>在实际应用中，我们除了有 <code>insert</code> 和 <code>extract</code> 这两个操作以外，我们数组中的元素很可能是动态变化的，在变化的过程中，如何保持最大堆的性质，这就是我们要讨论的问题。在以后章节的学习中，我们将会看到 <code>change</code> 操作的实际应用。</p><blockquote><p>我们不交换数据，而给每个数据一个索引，索引代表的数据是堆有序的。即：我们比较的是数据，交换的是索引。</p></blockquote><h3 id="最大索引堆"><a href="#最大索引堆" class="headerlink" title="最大索引堆"></a>最大索引堆</h3><p>索引堆的思想类似于在医院看病使用的“叫号排队”机制，想想我们去医院挂号排队的时候：我们不用真的站在那里排成一队，每个人领一个号坐在大厅里，轮到你了，你才进去看病。</p><p>最大索引堆的内部维护了一个索引数组，这个索引数组所代表的数据构成了一个最大堆；由于索引和堆中数据存在一一对应的关系，我们通过索引可以很快地定位到数据，而索引的操作又是十分方便的。</p><p>下面以最大索引堆为例，阐述相关的技巧和思想：</p><p>最大索引堆中的 <code>data</code> 数组是由用户定义的，用户的 <code>insert</code>、<code>extract</code>、和 <code>change</code> 操作只会插入、取出和修改 <code>data</code> 数组中的元素，由程序员来维护内部的索引数组，索引数组堆有序。</p><p>1、比较的时候使用 <code>data</code> 数组进行比较，交换的时候交换的是 <code>indexes</code> 数组的元素；</p><p>2、<strong>比较的是 <code>data</code> 的数据，交换的是 <code>indexes</code> 的位置</strong>。</p><p>下面，我们看一个例子，我们浪费一个元素的位置。下面这张表是数组原始的样子：</p><table><thead><tr><th></th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">10</th></tr></thead><tbody><tr><td><code>indexes</code></td><td align="left">（空着）</td><td align="left">1</td><td align="left">2</td><td align="left">3</td><td align="left">4</td><td align="left">5</td><td align="left">6</td><td align="left">7</td><td align="left">8</td><td align="left">9</td><td align="left">10</td></tr><tr><td><code>data</code></td><td align="left">（空着）</td><td align="left">15</td><td align="left">17</td><td align="left">19</td><td align="left">13</td><td align="left">22</td><td align="left">16</td><td align="left">28</td><td align="left">30</td><td align="left">41</td><td align="left">62</td></tr></tbody></table><p><code>heapify</code> 以后，<code>data</code> 元素不动，<strong>将 <code>indexes</code> 替换成它们代表的元素的值以后，就是一个最大堆</strong>：</p><table><thead><tr><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">10</th></tr></thead><tbody><tr><td align="left"><code>indexes</code></td><td align="left">10</td><td align="left">9</td><td align="left">5</td><td align="left">7</td><td align="left">8</td><td align="left">6</td><td align="left">2</td><td align="left">4</td><td align="left">3</td><td align="left">1</td></tr><tr><td align="left"><code>data</code></td><td align="left">15</td><td align="left">17</td><td align="left">19</td><td align="left">13</td><td align="left">22</td><td align="left">16</td><td align="left">28</td><td align="left">30</td><td align="left">41</td><td align="left">62</td></tr></tbody></table><p>说明：<code>indexes[1] = 10</code> ，表示 <code>data[10]</code> 在最大堆中的位置是 <code>1</code> ，抽象成一般情况就是：<code>indexes[x] = i</code> ，表示 <code>data[i]</code> 在最大堆中的位置是 <code>x</code> 。紧扣<strong>索引数组是堆有序</strong>这一点就不难理解了。</p><p><img src="http://upload-images.jianshu.io/upload_images/414598-3b1da05ed2133045.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="索引堆-1"></p><p>我们可以通过对之前最大堆的数据结构的改造，修改成一个最大索引堆。首先修改构造函数，引入索引数组。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">IndexMaxHeap</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>None <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 初值设置为 0 ，表示该位置还没有放置元素</span>        self<span class="token punctuation">.</span>indexes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其次修改  <code>insert</code> 方法：这里的 <code>insert</code> 虽然指定了索引，但是一定是在 <code>data</code> 数组的最后添加数据。我们插入一个元素的时候，同时要指定这个元素的索引 <code>i</code> ，这里要注意：传入的 <code>i</code> 对用户而言是从 $0$ 开始的，因此在底层发生操作之前，得先加 $1$。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 此时 insert 要给一个索引位置</span><span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> i<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>        <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'堆的容量不够了'</span><span class="token punctuation">)</span>        i <span class="token operator">+=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> item        <span class="token comment" spellcheck="true"># 这一步很关键，在内部索引数组的最后设置索引数组的索引</span>        self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>__shift_up<span class="token punctuation">(</span>self<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>shift_up</code> 方法也要修改：这里就是我们上面说的那一点：<strong>比较的是 <code>data</code> 的数据，交换的是 <code>indexes</code> 的位置</strong>。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__shift_up</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 比较的时候，上面套一层 indexes，交换的是 indexes</span>    <span class="token keyword">while</span> k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span>        k <span class="token operator">//=</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后修改 <code>extract_max</code> 方法：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">extract_max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'堆里没有可以取出的元素'</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 里面套一层 indexes</span>        ret <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 交换的是索引</span>        self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>count <span class="token operator">-=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>__shift_down<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__shift_down</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">:</span>        j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k        <span class="token comment" spellcheck="true"># 比较的是 data ，交换的是 indexes</span>        <span class="token keyword">if</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>count <span class="token operator">and</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>                self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>k<span class="token punctuation">]</span>                k <span class="token operator">=</span> j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后实现 <code>change</code> 方法：为了维持堆的性质，我们应当尝试向上挪一下 <code>shift up</code>，向下挪一下 <code>shift down</code>。关键在于找到用户认为的那个数据，在索引数组中是第几位，针对这个位置进行下沉和上移，即找到一个 <code>j</code> 满足：<code>indexes[j] = i</code>，<code>j</code> 表示 <code>data[i]</code> 在堆中的位置，之后 <code>shift up(j)</code>，然后 <code>shift down(j)</code>。还是紧扣那一点：比较的是 <code>data</code> ，交换的是  <code>indexes</code>。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">change</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> i<span class="token punctuation">,</span> new_item<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 把用户视角改成内部索引</span>    i <span class="token operator">+=</span> <span class="token number">1</span>    self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> new_item    <span class="token comment" spellcheck="true"># 重点：下面这一步是找原来数组中索引是 i 的元素</span>    <span class="token comment" spellcheck="true"># 在索引数组中的索引是几，这是一个唯一值，找到即返回</span>    <span class="token comment" spellcheck="true"># 优化：可以引入反向查找技术优化</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>__shift_down<span class="token punctuation">(</span>j<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>__shift_up<span class="token punctuation">(</span>j<span class="token punctuation">)</span>            <span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明： <code>change</code> 这个函数是可以进行优化的，通过引入反向查找数组来进行优化。反向查找的作用，就是帮助我们寻找原来索引的位置，在最大堆中是几。这个操作也叫“反向查找”，是一个基础且常见的技巧。</p><h2 id="索引堆的优化：反向查找"><a href="#索引堆的优化：反向查找" class="headerlink" title="索引堆的优化：反向查找"></a>索引堆的优化：反向查找</h2><p>我们引入了反向查找表。这一节的内容和思想很重要，要多看。<code>reverse[i]</code> 表示索引 <code>i</code> 在 <code>indexes</code>（堆）中的位置。引入 <code>reveres</code> 数组的意义是，可以在执行 <code>change</code> 这个方法的时候，可以通过 $O(1)$ 时间复杂度查询到用户认为索引是 <code>i</code> 的元素，在索引数组组成的堆中的索引是几。</p><p>注意：为 <code>reverse</code> 数组赋初始值，$0$ 有特殊的含义：<code>reverse[i] = 0</code> 表示 <code>data[i]</code> 未赋值。</p><p>我们在捋一遍：引入反向查找是为了“找到 <code>indexes</code> 数组中原来索引是 <code>i</code> 的元素的位置”，即 <code>reverse[i] = j</code> 表示 <code>data[i]</code> 在索引堆中的位置是 <code>j</code>。</p><p>通过引入反向查找数组，实现反向查找 <code>indexes</code> 数组中，原来为第 <code>i</code> 号的那个元素排在了 <code>indexes</code> 数组的第几位，通过对 <code>reverse</code> 数组的维护，使得 <code>change</code> 操作时间复杂度降到了 $O(1)$。</p><p><code>reverse[i]</code> 表示原来第 <code>i</code> 个数在 <code>indexes</code> 数组中的位置。</p><p>根据 <code>reverse</code> 数组反向查找的意义，我们很容易得到：如果 <code>indexes[i] = j</code>，那么 <code>reveres[j] = i</code>，可以看出来，“反向查找”有点“反函数”的意思。</p><p>把  <code>indexes[i] = j</code> 代入  <code>reveres[j] = i</code> ，得 <code>reveres[index[i]] = i</code>；</p><p>把  <code>reveres[j] = i</code> 代入  <code>indexes[i] = j</code> ，得 <code>indexes[reveres[j]] = j</code>。</p><p>这也就是“反函数的反函数是自己”。利用上述两个性质可以实现反向查找。</p><p>注意： <code>reveres</code> 数组的概念其实并不难理解，大家只要把 <code>reveres</code> 这个数组自己填一下就会非常清楚了。</p><table><thead><tr><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">10</th></tr></thead><tbody><tr><td align="left"><code>data</code></td><td align="left">15</td><td align="left">17</td><td align="left">19</td><td align="left">13</td><td align="left">22</td><td align="left">16</td><td align="left">28</td><td align="left">30</td><td align="left">41</td><td align="left">62</td></tr><tr><td align="left"><code>indexes</code></td><td align="left">10</td><td align="left">9</td><td align="left">5</td><td align="left">7</td><td align="left">8</td><td align="left">6</td><td align="left">2</td><td align="left">4</td><td align="left">3</td><td align="left">1</td></tr><tr><td align="left"><code>reverse</code></td><td align="left">10</td><td align="left">7</td><td align="left">9</td><td align="left">8</td><td align="left">3</td><td align="left">6</td><td align="left">4</td><td align="left">5</td><td align="left">2</td><td align="left">1</td></tr></tbody></table><p>说明：<code>indexes[1] = 10</code>，表示使用者认为的第 $10$ 号数据，在 <code>indexes</code> 数组中的索引是 $1$，故 <code>reverse[10] = 1</code>；</p><p><code>indexes[2] = 9</code>，表示使用者认为的第 $9$ 号数据，在 <code>indexes</code> 数组中的索引是 $2$，故 <code>reverse[9] = 2</code>；</p><p><code>indexes[3] = 5</code>，表示使用者认为的第 $5$ 号数据，在 <code>indexes</code> 数组中的索引是 $2$，故 <code>reverse[5] = 3</code>；</p><p>因此，<code>reverse</code> 数组的作用就是：<strong>通过使用者认为的索引编号，快速找到它在 <code>indexes</code> 数组形成的堆中的位置</strong>。</p><p>维护<code>reverse</code> 数组要注意的事项：在 <code>indexes</code> 数组交换位置的时候，<code>reverse</code> 数组也要同步交换。</p><p>下面我们来分析一下 <code>indexes</code> 数组如果交换了位置，<code>reverse</code> 数组要如何交换。</p><p>假如要交换 <code>indexes</code> 数组 <code>3</code> 和 <code>4</code> 的位置，由于此时 <code>indexes[3] = 7</code> ，<code>indexes[4] = 5</code> ，为了保证 <code>reverse</code> 数组的正确性，（我们暂时不去看表），就应该使得 <code>reverse[7] = 3</code>，<code>reverse[5] = 4</code>。</p><p>此时再去看表， <code>reverse[7] = 4</code>，<code>reverse[5] = 3</code>。怎么交换的，就很清楚了。<code>reverse</code> 数组是 <code>indexes</code> 数组映射以后的两个值交换。</p><h3 id="索引堆的应用"><a href="#索引堆的应用" class="headerlink" title="索引堆的应用"></a>索引堆的应用</h3><p>实现<strong>多路归并排序</strong></p><p>这部分的知识我是在参考资料1（《算法》（第4版）P204）中看到的。在这里做一个笔记。索引堆只存了 3 个元素，<strong>索引堆不仅仅把我们要的那个数据拿出来了，并且还给出了这个数据在使用者眼里的索引的位置</strong>。</p><p>图论中使用索引堆找到最小生成树</p><h3 id="本文源代码"><a href="#本文源代码" class="headerlink" title="本文源代码"></a>本文源代码</h3><p>Python：<a href="https://github.com/liweiwei1419/Algorithms-Learning-Python/tree/master/heap" target="_blank" rel="noopener">代码文件夹</a>，Java：<a href="https://github.com/liweiwei1419/Algorithms-Learning-Java/tree/master/06-Heap/src" target="_blank" rel="noopener">代码文件夹</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、图书《算法》(第4版)， Algorithms Fourth Edition，作者：[美] Robert Sedgewick，[美] Kevin Wayne 著，谢路云 译，<a href="https://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">图书配套网站</a></p><p>2、<a href="https://coding.imooc.com/class/71.html" target="_blank" rel="noopener">慕课网 liuyubobobo 老师《算法与数据结构》课程</a>以及对应的 <a href="https://github.com/liuyubobobo/Play-with-Algorithms" target="_blank" rel="noopener">GitHub 代码仓库</a></p><p>3、<a href="http://coding.imooc.com/class/138.html" target="_blank" rel="noopener">慕课网 liuyubobobo 老师《看得见的算法》课程</a>以及对应的 <a href="https://github.com/liuyubobobo/Play-with-Algorithm-Visualization" target="_blank" rel="noopener">GitHub 代码仓库</a>。</p><p>4、【多说两句】关于索引堆中的索引和数据</p><p><a href="https://coding.imooc.com/learn/questiondetail/4945.html。" target="_blank" rel="noopener">https://coding.imooc.com/learn/questiondetail/4945.html。</a></p><p>（本节完）</p><hr><blockquote><p>索引堆是一个比较有意思的数据结构。索引技术其实还是满常见的，听起来比较高大上，其实就是做了一个对应关系。</p></blockquote><h2 id="堆排序和-Heapify"><a href="#堆排序和-Heapify" class="headerlink" title="堆排序和 Heapify"></a>堆排序和 Heapify</h2><h3 id="什么是基础堆排序"><a href="#什么是基础堆排序" class="headerlink" title="什么是基础堆排序"></a>什么是基础堆排序</h3><p>我们的排序工作就描述如下：把待排序数组<strong>按顺序</strong>放入一个堆（入队），全部放入以后，然后再从堆中出队，每次出队的元素就是当前数组中最大的元素，于是我们可以倒着赋值回去，直到堆中没有元素（此时原始数组也被赋值“满”了）时，就能得到一个升序的数组。</p><p>Java 代码：</p><p>全部放入优先队列，再一个一个取出，倒着放即可：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 我们之前实现的 MaxHeap 这个数据结构，把它作为成员变量，利用它来完成排序</span>    <span class="token keyword">private</span> MaxHeap maxHeap<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 把数组中的元素先全部挨个 insert 到最大堆中</span>    <span class="token comment" spellcheck="true">// 然后在依次取出，因为每次取出的都是剩下的元素中的最大者</span>    <span class="token comment" spellcheck="true">// 因此应该倒着覆盖到原待排序数组</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer item <span class="token operator">:</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxHeap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>maxHeap<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> maxHeap<span class="token punctuation">.</span><span class="token function">extractMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        HeapSort heapSort <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HeapSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        heapSort<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大堆的第-3-个重要操作：heapify"><a href="#最大堆的第-3-个重要操作：heapify" class="headerlink" title="最大堆的第 3 个重要操作：heapify"></a>最大堆的第 3 个重要操作：heapify</h3><h4 id="什么是-heapify"><a href="#什么是-heapify" class="headerlink" title="什么是 heapify"></a>什么是 heapify</h4><p>在上一步“堆排序”中，我们注意到，有这样一个操作“把待排序数组<strong>按顺序</strong>放入一个堆（入队）”，这一步得一个接着一个按照顺序放入堆中，那么我们有没有一个神一样的操作，直接把一个数组丢给一个“堆”（此时还不能称为“堆”，只能说是把一个数组丢给一个堆的构造方法），让这个数组自行调整成一个最大堆，那么这个操作就叫 heapify。</p><p>因此 heapify 就是尝试将一整个数组构建成一个堆的更好的方式，因为此时无需借助额外的空间就完成了最大堆的构建，并且我们只需对数组中一半的元素执行 shift down 就可以了。</p><p>首先，我们直接把一个数组传到 MaxHeap 的<strong>构造方法</strong>里，<strong>通过从 length / 2 索引到索引 1 ，逐个执行 shift down 操作就使得了此时的数组成为了最大堆</strong>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">MaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        data<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    count <span class="token operator">=</span> length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// heapify：通过从 length / 2 索引到索引 1 ，逐个执行 shift down 操作就使得了此时的数组成为了最大堆</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">shiftDown</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：heapify 的操作只有 shift down。</p><p>那么为什么没有 shift up 呢？我是这样认为的：shift up 是认为”上面”的元素可能不对，所以要将当前考虑的元素尝试上移。shift down 是认为”下面”的元素可能不对，所以要将当前考虑的元素直至根节点逐个尝试下移。</p><p>heapify 后挨个取出来，倒着放回待排序数组就可以了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort2</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> MaxHeap maxHeap<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HeapSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>maxHeap<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> maxHeap<span class="token punctuation">.</span><span class="token function">extractMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        HeapSort2 heapSort2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HeapSort2</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        heapSort2<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原地堆排序"><a href="#原地堆排序" class="headerlink" title="原地堆排序"></a>原地堆排序</h3><h4 id="原地堆排序的基本思路"><a href="#原地堆排序的基本思路" class="headerlink" title="原地堆排序的基本思路"></a>原地堆排序的基本思路</h4><p>注意：在这一小节中，我们要转换一下脑筋，我们要使用原地堆排序，就是不想借助额外的空间，那么拿到的数组一定 0 号位置是有数值的，所以，我们要实现的算法必须基于 0 号位置存放元素来实现。</p><p>我们在上一节也可以看到，我们将一个数组通过 heapify 即 shift down 的方式逐渐地整理成一个最大堆。</p><p><strong>其实，原地堆排序这个想法是非常直观的，从 shift down 的操作我们就可以得到启发，堆中最大的那个元素在数组的 0 号索引位置，我们把它与此时数组中的最后一个元素交换，那么数组中最大的元素就放在了数组的末尾，此时再对数组的第一个元素执行 shift down，那么 shift down 操作都执行完以后，数组的第 1 个元素就存放了当前数组中的第 2 大的元素。</strong></p><p>可能以上这样说，并不是很严谨，但我想思路已经说得很清楚了。</p><p><img src="https://liweiwei1419.gitee.io/images/algorithms/%E5%8E%9F%E5%9C%B0%E5%A0%86%E6%8E%92%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt=""></p><h4 id="代码实现的注意事项"><a href="#代码实现的注意事项" class="headerlink" title="代码实现的注意事项"></a>代码实现的注意事项</h4><ul><li><p>此时最大堆中数组的索引从 $0$ 开始计算。与之前索引从 $1$ 开始的最大堆实现比较，性质就发生了变化，但并不会不好找，我们可以自己在纸上画一个完全二叉树就可以很清晰地发现规律：${\rm parent}(i)=\cfrac{i-1}{2}$，${\rm left \quad child}(i) = 2 \times i +1$，${\rm right \quad child}(i) = 2 \times i +2$，最后一个非叶子结点的索引是：$\cfrac{count-1}{2}$；</p></li><li><p>原地堆排序，因为索引从 0 号开始，相应的一些性质在索引上都发生变化了，为此，需要重新实现一下，但并不需要重新实现 MaxHeap 里所有的方法；</p></li><li><p>注意到我们只有 shift down 的操作，对于 shift down 的实现，一些细节就要很小心，shift down 是在一个区间内进行的，这个区间的端点，应该成为我们新设计的 shift down 方法的实现。</p></li></ul><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort3</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 原地堆排序的目标就是，不再借助 MaxHeap 这个数据结构进行排序，减少了空间复杂度     * 注意：此时我们的数组索引从 0 开始定义(自己在纸上画一下图，就能清晰地明白算法实现的含义)     *     * @param arr 待排序数组     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 首先 heapify：将一个无序的数组组成了一个最大堆，第 1 个元素就是最大值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">shiftDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> length<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">shiftDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 注意 shiftDown 不能复用我们上面写的，而设计成</span>    <span class="token comment" spellcheck="true">// 对 0 开始，end 为止，即将 arr 中 [0,end] 部分的数组元素视为"最大堆"</span>    <span class="token comment" spellcheck="true">// 对索引为 i 的元素进行 shift down 的操作</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">shiftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果有右孩子的节点，并且右孩子节点比左孩子节点的值要大</span>        <span class="token comment" spellcheck="true">// 此时可以忽略左孩子节点的存在，拿右孩子节点的数值和自己比较</span>        <span class="token comment" spellcheck="true">// 只要它有左孩子，就不是叶子节点，就可能 shift down，注意：这里是小于号</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                k <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 留意</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index1 <span class="token operator">==</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        HeapSort3 heapSort3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HeapSort3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        heapSort3<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="索引堆"><a href="#索引堆" class="headerlink" title="索引堆"></a>索引堆</h3><h4 id="为什么要引入索引堆这个数据结构？-1"><a href="#为什么要引入索引堆这个数据结构？-1" class="headerlink" title="为什么要引入索引堆这个数据结构？"></a>为什么要引入索引堆这个数据结构？</h4><p>在堆的一些操作过程中，不论是 insert 还是 extractMax 方法，都涉及了一些元素的交换操作，<strong>交换数组中的元素的位置，在一些场景下性能消耗很大</strong>。因此，我们可以在堆的内部实现一个索引数组，通过索引可以找到我们真正存放在数组中的元素，而索引所代表数据构成一个最大堆。这就是我们要引入索引堆的原因。</p><p>我们举一个可能不是很贴切的生活中的例子，我们要给一组学生按照身高进行排序，我们不用把他们全部喊出来让他们从矮到高排好，我们只要让他们报上自己的身高，在纸上做他们身高的比较就可以了。</p><p>我还想到一点：现在我们都进入了移动支付时代，我们购买物品不需要把真真实实的钱给商家，这种操作就很像我们引入索引堆的操作，我们通过1、自己账户上的钱减少2、商家用户账上的钱增多，这种方式实现了转账，给我们的生活带来了巨大的方便。一手交钱一首交货的时代已经不存在了，我们只会看到快递小哥把货送到你家，而不会有快递小哥把你的钱寄给卖家。相信很多人像我一样，出门带的现金已经很少很少了，甚至有些时候，我们出门根本可以不带钱。</p><ul><li>实现要点：</li></ul><p>1、引入一个 indexes 数组；</p><p>2、比较的时候，使用 indexs 所对应的 data 来进行比较，交换的是 index 的位置，我们内部的实现仍然从 1 号索引开始存放数据，但这一点对外部用户来说是不可知的；</p><p><strong>对于我们索引堆的使用者来说，他们只需要知道，这是一个数据结构，可以往里面存入数据，而每一次那出来的数据，都是当前已经存放在这个数据结构中最大的那个元素。</strong></p><p>3、我们完全可以直接使用我们之前实现的 MaxHeap 来实现最大堆。</p><ul><li>索引堆要支持的操作： 在实现的时候，<strong>要注意 insert(i,item) 的实现，不是任意位置的 i都可以 insert 的，一般有两种情况：1、insert 到使用者所认为的优先队列的尾部；2、insert 到刚刚出队的那个元素的位置，因为那个位置的数据“已经没有了”，这一点要好好体会</strong>。</li></ul><table><thead><tr><th>shiftUp(int k)</th><th>将位于 indexes 数组中的索引为 k 的元素逐个上移。</th></tr></thead><tbody><tr><td>shiftDown(int k)</td><td>将位于 indexes 数组中的索引为 k 的元素逐个下。</td></tr><tr><td>insert(i,item)</td><td><strong>特别注意：这里的 i 是由使用者保证的，是业务相关的，不能完全从程序和语法的角度来判断  i 的合理性。</strong></td></tr><tr><td>extractMax()</td><td>将此时二叉堆中的最大的那个数据返回。</td></tr><tr><td>extractMaxIndex()</td><td>将此时二叉堆中的最大的那个数据对应的索引返回。</td></tr><tr><td>getItem(int i)</td><td>获得索引为 i 的数据，通常这个数据是刚刚出队的索引，是由 extractMaxIndex() 方法来的。</td></tr><tr><td>change(int i,int item)</td><td>修改索引为 i 的数据的“优先级”。</td></tr></tbody></table><p>【多说两句】关于索引堆中的索引和数据</p><p><a href="https://coding.imooc.com/learn/questiondetail/4945.html" target="_blank" rel="noopener">https://coding.imooc.com/learn/questiondetail/4945.html</a></p><h3 id="索引堆的优化"><a href="#索引堆的优化" class="headerlink" title="索引堆的优化"></a>索引堆的优化</h3><h4 id="索引堆的优化方法"><a href="#索引堆的优化方法" class="headerlink" title="索引堆的优化方法"></a>索引堆的优化方法</h4><p>我们想找一找在使用者认为的优先队列中指定索引的数据，在我们的 indexes 数组中，排在第几位，我们使用了遍历，这种做法效率是不高的。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>indexes<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 找到了 j</span>        <span class="token function">shiftDown</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">shiftUp</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以通过引入一个反向查找数组，实现反向查找 indexes 数组中，值为 i 的那个元素排在了 indexes 的第几位，通过对 reverse 数组的维护，就使得我们对反向查找这件事情的时间复杂度降到了 $O(1)$。</p><ul><li><code>reverse[i]</code> 表示索引 i 在 indexes（堆）中的位置。引入 reveres 数组的意义是，可以在执行 change 这个方法的时候，使用 <code>O(1)</code> 这个时间复杂度，直接找到。</li><li>reverse 数组的性质：</li></ul><p>性质1：如果 <code>indexes[i] = j</code>，那么 <code>reveres[j] = i</code>；</p><p>性质2：<code>indexes[reveres[i]] = i</code>，<code>reveres[index[i]] = i</code>。</p><ul><li>reveres 数组的概念其实并不难理解，大家只要把 reveres 这个数组自己填一下就会非常清楚了。</li></ul><table><thead><tr><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">10</th></tr></thead><tbody><tr><td align="left">data</td><td align="left">15</td><td align="left">17</td><td align="left">19</td><td align="left">13</td><td align="left">22</td><td align="left">16</td><td align="left">28</td><td align="left">30</td><td align="left">41</td><td align="left">62</td></tr><tr><td align="left">indexes</td><td align="left">10</td><td align="left">9</td><td align="left">5</td><td align="left">7</td><td align="left">8</td><td align="left">6</td><td align="left">2</td><td align="left">4</td><td align="left">3</td><td align="left">1</td></tr><tr><td align="left">reverse</td><td align="left">10</td><td align="left">7</td><td align="left">9</td><td align="left">8</td><td align="left">3</td><td align="left">6</td><td align="left">4</td><td align="left">5</td><td align="left">2</td><td align="left">1</td></tr></tbody></table><p>怎么看这张表：</p><p>indexes[1] = 10，表示使用者认为的第 10 号数据，排在了优先队列的第 1 位，即 10 这个数字在 indexes 数组中的索引是 1，故 revers[10] = 1；</p><p>indexes[2] = 9，表示使用者认为的第 9 号数据，排在了优先队列的第 9 位，即 9 这个数字在 indexes 数组中的索引是 2，故 revers[9] = 2；</p><p>indexes[5] = 8，表示使用者认为的第 8 号数据，排在了优先队列的第 5 位，即 8 这个数字在 indexes 数组中的索引是 5，故 revers[8] = 5；</p><p>所以，revers 数组的作用就是：<strong>通过使用者认为的索引数据，它在 indexes 数组形成的堆中的位置</strong>。</p><ul><li>reverse 数组在 indexes 数组交换位置的时候，应该如何维护</li></ul><p>下面我们来分析一下 indexes 数组如果交换了位置，reverse 数组要如何交换位置。</p><p>假如要交换 indexes 数组 3 和 4 的位置，那么此时 indexes[3] = 7 ，indexes[4] = 5 ，为了保证 reverse 数组的正确性，（我们暂时不去看表），就应该使得 reverse[7] = 3，reverse[5] = 4。</p><p>此时再去看表， reverse[7] = 4，reverse[5] = 3。怎么交换的，就很清楚了。reverse 数组是 indexes 数组映射以后的两个值交换。</p><h3 id="索引堆的应用-1"><a href="#索引堆的应用-1" class="headerlink" title="索引堆的应用"></a>索引堆的应用</h3><ul><li>实现<strong>多路归并排序</strong></li></ul><p>这部分的知识我是在参考资料1（《算法》（第4版）P204）中看到的。在这里做一个笔记。索引堆只存了 3 个元素，<strong>索引堆不仅仅把我们要的那个数据拿出来了，并且还给出了这个数据在使用者眼里的索引的位置</strong>。</p><ul><li>图论中使用索引堆找到最小生成树</li></ul><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>图书《算法》(第4版)， Algorithms Fourth Edition，作者：[美] Robert Sedgewick，[美] Kevin Wayne 著，谢路云 译，<a href="https://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">图书配套网站</a></li><li><a href="https://coding.imooc.com/class/71.html" target="_blank" rel="noopener">慕课网 liuyubobobo 老师《算法与数据结构》课程</a>以及对应的 <a href="https://github.com/liuyubobobo/Play-with-Algorithms" target="_blank" rel="noopener">GitHub 代码仓库</a></li><li><a href="http://coding.imooc.com/class/138.html" target="_blank" rel="noopener">慕课网 liuyubobobo 老师《看得见的算法》课程</a>以及对应的 <a href="https://github.com/liuyubobobo/Play-with-Algorithm-Visualization" target="_blank" rel="noopener">GitHub 代码仓库</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 专题 10：优先队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 102 题：二叉树的层次遍历</title>
      <link href="/leetcode-algo/2017/10/02/leetcode-solution/0102-binary-tree-level-order-traversal/"/>
      <url>/leetcode-algo/2017/10/02/leetcode-solution/0102-binary-tree-level-order-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-102-题：二叉树的层次遍历"><a href="#「力扣」第-102-题：二叉树的层次遍历" class="headerlink" title="「力扣」第 102 题：二叉树的层次遍历"></a>「力扣」第 102 题：二叉树的层次遍历</h2><p>传送门：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层次遍历</a>。</p><blockquote><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><pre><code>3/ \9  20/  \15   7</code></pre><p>返回其层次遍历结果：</p><pre><code>[[3],[9,20],[15,7]]</code></pre></blockquote><p>分析：非常标准的层序遍历的做法，使用队列作为辅助的数据结构。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[List[int]]        """</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> root <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> res        queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            size <span class="token operator">=</span> len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            cur <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>                top <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                cur<span class="token punctuation">.</span>append<span class="token punctuation">(</span>top<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> top<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>top<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> top<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>top<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> curSize <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> curLevel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> curSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                curLevel<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 9：队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「优先队列」专题 2：堆排序、heapify、原地堆排序</title>
      <link href="/leetcode-algo/2017/10/02/algorithms-and-data-structures/heapify-and-heap-sort/"/>
      <url>/leetcode-algo/2017/10/02/algorithms-and-data-structures/heapify-and-heap-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="「队列」专题-2：堆排序、heapify、原地堆排序"><a href="#「队列」专题-2：堆排序、heapify、原地堆排序" class="headerlink" title="「队列」专题 2：堆排序、heapify、原地堆排序"></a>「队列」专题 2：堆排序、heapify、原地堆排序</h2><h3 id="基础堆排序和-Heapify"><a href="#基础堆排序和-Heapify" class="headerlink" title="基础堆排序和 Heapify"></a>基础堆排序和 Heapify</h3><p>这一节我们介绍两个使用堆或者说基于堆的思想进行排序的算法。</p><p>思路1：一个一个地往最大堆里面放元素，然后再一个一个地取出，倒序放置于一个空数组中，就完成了元素的排序；</p><p>思路2：一次性把整个数组复制到一个新数组，通过新数组 heapify 操作，使得新数组成为一个最大堆，然后再一个一个地取出，倒序放置于一个空数组中，就完成了元素的排序。</p><h3 id="思路1：一个一个放进最大堆，再一个一个地取出完成排序"><a href="#思路1：一个一个放进最大堆，再一个一个地取出完成排序" class="headerlink" title="思路1：一个一个放进最大堆，再一个一个地取出完成排序"></a>思路1：一个一个放进最大堆，再一个一个地取出完成排序</h3><p>我们首先要明确的是，堆排序的时间复杂度是 $O(n \log n)$。</p><p>我们可以从以下几个维度进行不同算法性能的比较，对数量级是 100 万个元素的数组进行排序。</p><p>使用的排序算法维度：归并排序，快速排序，三路快速排序，堆排序（借助额外空间的堆排序）。</p><p>元素特点维度：1、随机；2、近乎有序；3、含有大量相同元素的数组。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 第 1 个版本的堆排序算法 * Created by liwei on 17/5/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort1</span> <span class="token keyword">implements</span> <span class="token class-name">ISortAlgorithm</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"第 1 个版本的堆排序算法"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        MaxHeap maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxHeap<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxHeap<span class="token punctuation">.</span><span class="token function">extractMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在上一小节，介绍了将一个元素 insert 到最大堆中，和从最大堆中取出一个元素，仅仅通过这两个操作，就可以完成排序任务。方法很简单，把待排序数组中的元素全部 insert 到最大堆里，然后再一个一个取出来，因为我们要按照升序排序，因此从后向前放置从最大堆中拿出的元素。</p><p>这个方法有一个缺点，那就是要使用和数组元素个数相等的最大堆空间，即空间复杂度是 $O(n)$。</p><p>而这一节我们要介绍的是一种直接使用堆排序的 <code>sink</code> 方法完成排序任务的方法，这种方法仅使用 $O(1)$ 的空间复杂度，用于一个临时表变量的存储。</p><p>首先，我们介绍一个操作，名为 heapify 。</p><h2 id="思路2：一次性复制数组元素到新的数组，新数组自我调整成最大堆"><a href="#思路2：一次性复制数组元素到新的数组，新数组自我调整成最大堆" class="headerlink" title="思路2：一次性复制数组元素到新的数组，新数组自我调整成最大堆"></a>思路2：一次性复制数组元素到新的数组，新数组自我调整成最大堆</h2><h3 id="什么是-Heapify"><a href="#什么是-Heapify" class="headerlink" title="什么是 Heapify"></a>什么是 Heapify</h3><p>Heapify 是尝试将一整个数组构建成一个堆的方式，即通过调整自己，交换数组中的元素，就可以把自己整理成一个最大堆。</p><h3 id="理解-Heapify-关键的部分"><a href="#理解-Heapify-关键的部分" class="headerlink" title="理解 Heapify 关键的部分"></a>理解 Heapify 关键的部分</h3><p>1、所有的叶子结点就是一个最大堆，此时每个堆中的元素只有1个；</p><p>2、当我们的索引从 1 开始计数的前提下，第 1 个非叶子的结点的索引是 index/2（自己画一个图，就可以看清楚这个规律，我们可以使用数学归纳法来证明），如何让它满足堆的性质呢？ Shift Down 就可以了。<br>思考：我们为什么不用 Shift Up？<br>我的思考如下：如果使用 Shift Up 的话，那就得将数组中所有的元素都 Shift Up，相比于只用一半的元素 Shift Down 而言，工作量会少很多。</p><p>3、从 index/2 递减到根（index==1的时候）依次去完成 Shift Down，一开始就排除了 length/2 这么多元素。</p><h3 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h3><p>使得一个数组是堆有序的操作就叫做“heapify”。具体的做法是：从最后一个非叶子结点开始到索引为 $0$ 的位置，逐个 <code>sink</code>。</p><p>在上一步“堆排序”中，我们注意到，有这样一个操作“把待排序数组<strong>按顺序</strong>放入一个堆（入队）”，这一步得一个接着一个按照顺序放入堆中，实际上，可以通过一个称之为 heapify 的操作，让这个数组自行调整成一个最大堆，即使之“堆有序”，而此时无需借助 $O(n)$ 空间就完成了最大堆的构建。事实上，只需对数组中一半的元素执行 shift down 就可以了。</p><p>以下代码还是使用了  $O(n)$ 空间，主要是为了说明 heapify。</p><p>heapify 如下所示：从索引的 <code>self.count // 2</code> 位置开始，直到索引为 $0$ 的元素结束，逐个下沉，就可以让一个数组堆有序。</p><p>说明：索引的 <code>self.count // 2</code> 位置是从下到上第 1 个非叶子结点的索引</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>__heapify<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__heapify</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 挨个赋值</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>capacity<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>count <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>__sink<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 传递一个数组，形成一个最大堆 * 理解 heapify 是关键 * * @param arr 待排序的数组元素 */</span><span class="token keyword">public</span> <span class="token function">MaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        data<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 添加一个元素，就要把 count 加 1 ，因为我们是一次性添加，所以就直接将 count 赋值为 length 就可以了</span>    <span class="token comment" spellcheck="true">// 这一步赋值千万别忘了</span>    count <span class="token operator">=</span> length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 理解这一步是关键 heapify</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">shiftDown</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，我们就可以写出我们的第 2 个使用堆排序的算法了，直接把数组传到最大堆这个数据结构里面。</p><p>heapify 以后挨个取出来，倒着放回去，也可以完成排序，就不用一个一个放进去，做上浮的操作了。整体上排序会比一个一个放进去快一些。</p><p>Java 代码：通过 heapify 将数组重组成最大堆实现的排序</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 第 2 个版本的堆排序算法 * Created by liwei on 17/5/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort2</span> <span class="token keyword">implements</span> <span class="token class-name">ISortAlgorithm</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"第 2 个版本的堆排序算法"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MaxHeap maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxHeap<span class="token punctuation">.</span><span class="token function">extractMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重要结论：堆排序在整体上的性能不如归并排序和快速排序。但是，堆这种数据结构更多的时候用于动态数据的维护。</p><p>一个数学结论：将 $n$ 个元素逐一插入到一个空堆中，时间复杂度是 $O(n \log n)$。Heapify 的过程，时间复杂度是 $O(n)$。</p><p>HeapSort2 会快一点的原因是：一上来我们从 n/2 这个地方开始，逐一操作，排除了 n/2 个元素，所以效率肯定比第 1 种好。</p><p>可是这两种基于堆的排序算法，我们在堆排序的过程中，使用了额外的空间（即 MaxHeap 中的数组），使用了 $O(n)$ 的空间复杂度。那么不借助额外的空间是不是也可以完成堆排序呢？这就是我们下一节要介绍的内容——原地堆排序。</p><p>##原地堆排序 </p><p>通过上一节的学习，我们知道一个数组通过 heapify 操作，即通过一半的元素执行 Shift Down 的操作可以逐渐地整理成一个最大堆。</p><p>我们把“原地堆排序”拆解为以下 3 个部分：</p><p>1、首先，转换思维，堆从索引 $0$ 开始编号；</p><p>代码很多地方都要改，好在并不复杂，正好可以帮助我们复习堆的 <code>sink</code> 操作，如果只是用于排序任务，不需要 <code>swim</code> 操作；</p><p>2、 <code>sink</code> 操作要设计成如下的样子，设计一个表示 end 的变量，表示待排序数组的 <code>[0, end]</code>（注意是闭区间）范围是堆有序的。</p><p>上一节我们将一个数组通过 heapify 的方式逐渐地整理成一个最大堆。而原地堆排序的思想是非常直观的，从 shift down 的操作我们就可以得到启发，堆中最大的那个元素在数组的 0 号索引位置，我们把它与此时数组中的最后一个元素交换，那么数组中最大的元素就放在了数组的末尾，此时再对数组的第一个元素执行 shift down，那么 shift down 操作都执行完以后，数组的第 1 个元素就存放了当前数组中的第 2 大的元素。依次这样做下去，就可以将一个数组进行排序。</p><p>理解这个原理的关键之处：对堆顶元素执行了 <code>Shift Down</code> 操作以后，就会把这个堆中的最大的元素挪到堆顶。</p><p>此时，因为用到了索引，并且须要用到索引为 $0$ 的数组元素，因此我们就要将最大堆中数组的索引从 $0$ 开始计算，重新写一套堆的 API。</p><p>我们整理一下，其实这个思想跟“选择排序”是一样的，只不过我们每一轮选出一个当前未排定的数中最大的那个，即“选择排序”+“堆”就是“堆排序”。</p><p><img src="https://liweiwei1419.github.io/images/algorithms/%E5%8E%9F%E5%9C%B0%E5%A0%86%E6%8E%92%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="堆排序、heapify、原地堆排序-1"></p><p>“堆排序”代码实现的注意事项：</p><p>1、此时最大堆中数组的索引从 $0$ 开始计算。与之前索引从 $1$ 开始的最大堆实现比较，性质就发生了变化，但并不会不好找，我们可以自己在纸上画一个完全二叉树就可以很清晰地发现规律：${\rm parent}(i)=\cfrac{i-1}{2}$，${\rm left \quad child}(i) = 2 \times i +1$，${\rm right \quad child}(i) = 2 \times i +2$，最后一个非叶子结点的索引是：$\cfrac{count-1}{2}$；</p><p>2、原地堆排序，因为索引从 $0$ 号开始，相应的一些性质在索引上都发生变化了；</p><p>3、注意到我们只有 shift down 的操作，对于 shift down 的实现，一些细节就要很小心，shift down 是在一个区间内进行的，我们在设计新的 shift down 方法的实现的时候，应该设计待排序数组区间的右端点。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__sink</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> end<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># end ：数组 nums 的尾索引，</span>    <span class="token comment" spellcheck="true"># __sink 方法维持 nums[0:end]，包括 nums[end] 在内堆有序</span>    <span class="token keyword">assert</span> k <span class="token operator">&lt;=</span> end    temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token keyword">while</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> end<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 只要有孩子结点：有左孩子，就要孩子结点</span>        t <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">if</span> t <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> end <span class="token operator">and</span> nums<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 如果有右边的结点，并且右结点还比左结点大</span>            t <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">:</span>            <span class="token keyword">break</span>        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>t<span class="token punctuation">]</span>        k <span class="token operator">=</span> t    nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token keyword">def</span> <span class="token function">__heapy</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token punctuation">(</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        __sink<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">heap_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    __heapy<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        __sink<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 原地堆排序 * Created by liwei on 17/5/15. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort3</span> <span class="token keyword">implements</span> <span class="token class-name">ISortAlgorithm</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"原地堆排序"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 原地堆排序的目标就是，不再借助 MaxHeap 这个数据结构进行排序，减少了空间复杂度     * 注意：此时我们的数组索引从 0 开始定义(自己在纸上画一下图，就能清晰地明白算法实现的含义)     *     * @param arr 待排序数组     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将一个无序的数组组成了一个最大堆，第 1 个元素就是最大值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">shiftDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> length<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 代码逻辑非常简单明确，完全可以自己写出来</span>        <span class="token comment" spellcheck="true">// </span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">shiftDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从索引为 0 开始，up 为止 [0,up] 的数组元素进行 shift down 的操作     *     * @param arr      * @param up 这里的 up 定义为形成堆这个数据结构的最大下标（从索引 0 就放元素），     *           即在区间 [0,up] 范围内 Shift Down     * @param index 对索引是 index 的元素执行 Shift Down 操作     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">shiftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> up<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果有右孩子的结点，并且右孩子结点比左孩子结点的值要大</span>        <span class="token comment" spellcheck="true">// 此时可以忽略左孩子结点的存在，拿右孩子结点的数值和自己比较</span>        <span class="token comment" spellcheck="true">// 只要它有左孩子，就不是叶子结点，就可能 shift down，注意：这里是小于号</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> index <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> up<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> up <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                index <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 留意</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：首先进行一次 <code>heapify</code> 的过程：从索引为 $\cfrac{count-1}{2}$ 的结点开始执行 <code>Shift Down</code>。<code>heapify</code> 过程的代码框架几乎是套路，一定要熟悉，只不过我们要弄清楚，我们的最大堆是从索引为 $0$ 的位置开始存放元素，还是从索引为 $1$ 的地方开始存放元素。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 将一个无序的数组组成了一个最大堆，第 1 个元素就是最大值</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">shiftDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> length<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>到此为止，堆的排序算法就已经介绍完了，下面我们对之前学习过的排序算法作一个总结。</p><h2 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h2><h3 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h3><p>时间复杂度分为平均时间复杂度、最好时间复杂度和最坏时间复杂度。对于一个算法来说，往往有很多特殊情况，一般而言，我们所说的时间复杂度都指最坏时间复杂度。</p><h3 id="对我们学习过的各种排序算法的总结和对比"><a href="#对我们学习过的各种排序算法的总结和对比" class="headerlink" title="对我们学习过的各种排序算法的总结和对比"></a>对我们学习过的各种排序算法的总结和对比</h3><p>快速排序相对会更快一些。一般系统级别的排序，是用快速实现的。如果有大量重复键值，可以使用三路快排。</p><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>查资料了解什么是排序算法的稳定性。可以通过自定义比较函数，让排序算法不存在稳定性问题。系统级别的排序算法，如果要求稳定性的话，一般使用归并排序。</p><h3 id="对未来的探索"><a href="#对未来的探索" class="headerlink" title="对未来的探索"></a>对未来的探索</h3><p>是不是存在一种神秘的排序算法？让所有指标达到最优呢。liuyubobobo 老师告诉我们，目前还没有。</p><h3 id="本文源代码"><a href="#本文源代码" class="headerlink" title="本文源代码"></a>本文源代码</h3><p>Python：<a href="https://github.com/liweiwei1419/Algorithms-Learning-Python/tree/master/heap" target="_blank" rel="noopener">代码文件夹</a>，Java：<a href="https://github.com/liweiwei1419/Algorithms-Learning-Java/tree/master/06-Heap/src" target="_blank" rel="noopener">代码文件夹</a>。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 10：优先队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「队列」专题：队列与广度优先遍历</title>
      <link href="/leetcode-algo/2017/10/01/leetcode-solution/queue-1/"/>
      <url>/leetcode-algo/2017/10/01/leetcode-solution/queue-1/</url>
      
        <content type="html"><![CDATA[<h2 id="「队列」专题：队列与广度优先遍历"><a href="#「队列」专题：队列与广度优先遍历" class="headerlink" title="「队列」专题：队列与广度优先遍历"></a>「队列」专题：队列与广度优先遍历</h2><p>队列 Queue 主要处理的问题是广度优先遍历（不论是针对树还是图，可以把树理解为图的特殊形式）。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 9：队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「优先队列」专题 1：优先队列与堆</title>
      <link href="/leetcode-algo/2017/10/01/algorithms-and-data-structures/priority-queue/"/>
      <url>/leetcode-algo/2017/10/01/algorithms-and-data-structures/priority-queue/</url>
      
        <content type="html"><![CDATA[<h2 id="「队列」专题-1：优先队列与堆"><a href="#「队列」专题-1：优先队列与堆" class="headerlink" title="「队列」专题 1：优先队列与堆"></a>「队列」专题 1：优先队列与堆</h2><p>这部分我们介绍一种新的数据结构堆（Heap），“堆”是实现“优先队列”的一个高效的数据结构。首先，我们来认识“优先队列”。</p><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><ul><li>优先队列（Priority Queue）是一种数据结构；</li><li>堆（Heap）是具体的实现。</li></ul><p>知识结构：</p><p><img src="https://liweiwei1419.gitee.io/images/algorithms/heap-sort.png" alt=""></p><h2 id="优先队列（priority-queue）"><a href="#优先队列（priority-queue）" class="headerlink" title="优先队列（priority queue）"></a>优先队列（<strong>priority</strong> queue）</h2><p>“优先队列”是从下面的这种场景中抽象出来的数据结构。</p><blockquote><p>例：班级里要选一名同学代表全班参加程序编程竞赛，此时我们只会关心第 1 名是谁，第 1 名本人不想参赛了，或者说第 1 名因为其它因素不符合参考资格，我们才考虑第 2 名，但也是从剩下的那些同学中挑出第 1 名。即当前我们只关心当前“最优”的那个元素，第 2 名及其以后的同学都不考虑了。</p></blockquote><p>“优先队列”相对于“普通队列”而言。“普通队列”的性质是“先进先出，后进后出”。“优先队列”由元素的<strong>优先级</strong>决定出队的顺序。</p><table><thead><tr><th align="left">普通队列</th><th align="left">优先队列</th></tr></thead><tbody><tr><td align="left">先进先出，后进后出。由进入队列的时间顺序决定。</td><td align="left">出队顺序与入队顺序无关，只与队列中元素的优先级有关，优先级最高的元素最先出队。</td></tr></tbody></table><h3 id="更多优先队列在生活中的例子"><a href="#更多优先队列在生活中的例子" class="headerlink" title="更多优先队列在生活中的例子"></a>更多优先队列在生活中的例子</h3><p>“优先队列”更多地应用于动态的情况，即数据不是一开始就定好的，而是随时都有可能来新的数据，此时新数据与旧数据在一起选出“优先级”最高的那个元素。比如以下场景，重点理解“动态执行”这个概念：</p><p>1、医院看病：重症患者往往优先治疗，即使他是后来者；</p><p>2、操作系统：选择优先级最高的任务执行；</p><p>3、上网：服务端依次回应客户端的请求：通常也是使用优先队列，优先级高的客户端优先响应；</p><p>下面是一个静态的例子。</p><blockquote><p>例：从 $1000000$ 个数中选出最大的 $100$ 个数。</p></blockquote><p>这个问题我们抽象成数学表达就是：在 $N$ 个元素中选出前 $M$ 个元素。</p><p>1、如果我们使用之前学习的排序算法，时间复杂度为：$O(N \log N)$，即先排序，再取出前 $M$ 个元素。此时，这个问题的时间复杂度完全由使用的排序算法决定。</p><p>2、如果我们使用优先队列，那么解决该问题的时间复杂度为：$O(N \log M)$。与使用排序算法不同之处在于，我们只要维护有 $M$ 个元素的数据结构就可以了。在这一章的末尾我们将要解决这样的问题。</p><h2 id="优先队列的主要操作"><a href="#优先队列的主要操作" class="headerlink" title="优先队列的主要操作"></a>优先队列的主要操作</h2><p>“优先队列”是一种抽象的数据结构，有两种“优先队列”。一种“优先队列”每次可以从中拿到我们定义下优先级“最高”的元素，即“最大堆”、“大顶堆”、“大根堆”，另一种“优先队列”每次可以从中拿到我们定义下优先级“最低”的元素，即“最小堆”、“小顶堆”、“小根堆”。如果没有特别说明，我们下文所指的“优先队列”都是指每次可以拿到优先级“最高”元素的优先队列。</p><p>“优先队列”的主要操作有：</p><p>1、入队</p><p>2、出队：优先队列的一个重要特点是：出队的时候总是取出优先级最高的那个元素。</p><p>如果不考虑时间复杂度，“优先队列”可以有以下两种实现方式：“无序数组”和“有序数组”。</p><p>实现1：无序数组。放入的时候，直接放在数组的末尾，时间复杂度：$O(1)$。每次拿出元素之前，我们都排个序，或者像“选择排序”那样，把最大的那个拿出去就好了，时间复杂度是：$O(n)$。</p><p>实现2：有序数组。每次放入元素的时候，我们都排个序，像插入排序内层循环那样，保持数组的有序性，时间复杂度 $O(n)$，把最大的那个拿出去 $O(1)$。</p><p>伟大的计算机科学家平衡了入队和出队这两个操作的时间复杂度，这种数据结构就是堆。</p><h3 id="三种数据结构对于实现优先队列的时间复杂度的比较"><a href="#三种数据结构对于实现优先队列的时间复杂度的比较" class="headerlink" title="三种数据结构对于实现优先队列的时间复杂度的比较"></a>三种数据结构对于实现优先队列的时间复杂度的比较</h3><table><thead><tr><th align="left">实现优先队列的数据结构</th><th align="left">入队操作</th><th align="left">出队操作</th></tr></thead><tbody><tr><td align="left">普通数组</td><td align="left">$O(1)$</td><td align="left">$O(n)$</td></tr><tr><td align="left">顺序数组</td><td align="left">$O(n)$</td><td align="left">$O(1)$</td></tr><tr><td align="left">堆</td><td align="left">$O(\log n)$</td><td align="left">$O(\log n)$</td></tr></tbody></table><p>说明：$\log n$ 表示以 $2$ 为底的 $n$ 的对数。</p><p>在 $N$ 个元素中选出前 $M$ 个元素。使用普通数组或者顺序数组，最差的情况是 $O(N^2)$，使用堆可以将时间复杂度降到：$O(N\log M)$。事实上，时间复杂度是 $O(N^2)$ 与 $O(N\log M)$ 的差异巨大的。理解这个事实是我们掌握堆以及相关算法的基础，正是因为使用堆这种数据结构，提高了我们算法的执行效率，我们才有必要来研究堆，使用堆。</p><p>我们发现，不管是“入队”还是“出队”，总有一个操作得把“优先队列”中的元素都看一遍。而“堆”就是这样一个数据结构，能把 $O(n)$ 降到 $O(\log n)$。</p><p>综上所述，<strong>“堆”是实现“优先队列”的高效的数据结构</strong>。“堆”有“最小堆”和“最大堆”，和上面一样，如果没有特别说明，我们下文所指的“堆”都是指“最大堆”。</p><h2 id="什么是“堆”"><a href="#什么是“堆”" class="headerlink" title="什么是“堆”"></a>什么是“堆”</h2><p>通过上一小节的介绍，我们可以看到堆的入队和出队的时间复杂度都是 $O(\log n)$ ，因此我们可以猜测它的形状看起来像是一棵树一样。</p><p>形如下面形状的一个结构就是“最大堆”。</p><p><img src="http://upload-images.jianshu.io/upload_images/414598-d59ab650f181c4f1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="堆与优先队列-1"></p><h3 id="“最大堆”的性质："><a href="#“最大堆”的性质：" class="headerlink" title="“最大堆”的性质："></a>“最大堆”的性质：</h3><p>首先，<strong>“最大堆”是一棵“完全二叉树”</strong>。</p><blockquote><p><strong>完全二叉树：从形状上看，除了最后一层之外，其它层结点的数量达到最大值，并且最后一层的结点全部集中在左侧。</strong></p></blockquote><p>“完全二叉树”的特点是，可以使用一个数组保存“完全二叉树”，而不必引入树形结构。这样既可以利用数组元素可以快速访问的特点，又让结点和结点之间形成了“父”与“子”的结构关系。</p><p>其次，任意一个结点，如果有孩子结点的话，孩子结点的值一定不会大于父亲结点的值。</p><p>如果一个数组中的元素，有如上特点，我们称之为堆有序。堆有序不是我们通常理解意义上的“升序”或者“降序”。如果把数组排成“完全二叉树”的样子，且满足第 2 条，这个数组就是“堆有序”。这里要注意的是，通常我们数组的 $0$ 号索引不使用，从 $1$ 号索引开始使用，这只是一种习惯，因为这么做父子结点的索引关系更“好看”一些，仅此而已。到从 $0$ 号索引开始使用的堆也是可以的。</p><p>下面我们从索引从 1 号开始，自上到下、自左到右，标记，即显示成结点的旁边黑色的数字，我们不难发现这些数字的排列形成的规律。<strong>正是因为“堆”是一棵“完全二叉树”，有如下的规律，我们才可以很方便地索引数组中的位置，这就是我们为什么使用数组而不是使用树来实现堆。</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/414598-605117ff63eb6c84.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="堆与优先队列-2"></p><p>规律1：一个结点的左结点（如果有的话）的索引是这个结点的编号的 $2$ 倍；</p><p>规律2：一个结点的右结点（如果有的话）的索引是这个结点的编号的 $2$ 倍 $+ 1$。</p><p>从子结点索引找到父结点索引：${\rm parent(i)}=\cfrac{i}{2}$，注意这里不能整除的时候需要向下取整。</p><p>从父节点索引找到两个子结点索引：${\rm left\ child = 2 \times i}$，${\rm right\ child} = 2 \times i+1$。</p><p>这个两条性质不用记，我们只要拿一张纸，画一个像上面一样图，就非常清楚了。到这里为止，我们可以先写出“最大堆”的框架。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 我们这个版本的实现中，0 号索引是不存数据的，这一点一定要注意</span>        <span class="token comment" spellcheck="true"># 因为数组从索引 1 开始存放数值</span>        <span class="token comment" spellcheck="true"># 所以开辟 capacity + 1 这么多大小的空间</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>None <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 当前堆中存储的元素的个数</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 堆中能够存储的元素的最大数量（为简化问题，不考虑动态扩展）</span>        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        返回最大堆中的元素的个数        :return:        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count    <span class="token keyword">def</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        返回最大堆中的元素是否为空        :return:        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MaxHeap</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 堆中真实元素的个数</span>    <span class="token keyword">public</span> <span class="token function">MaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 开辟数组空间（整个数组存储从索引 1 开始）</span>        data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当前堆中的元素个数是否为 0</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们介绍如何保持“最大堆”数组的堆有序的性质。</p><h2 id="最大堆的第-1-个重要操作：向一个“最大堆”中添加元素"><a href="#最大堆的第-1-个重要操作：向一个“最大堆”中添加元素" class="headerlink" title="最大堆的第 1 个重要操作：向一个“最大堆”中添加元素"></a>最大堆的第 1 个重要操作：向一个“最大堆”中添加元素</h2><p>向“最大堆”中添加一个元素，对应优先队列中“入队”这个操作，同时还要保持“最大堆”的性质，即根元素是“最大堆”中最大的元素，并且除了根结点以外任意一个结点不大于它的父亲结点。这个操作叫做 <code>shift up</code> 。</p><p>向“最大堆”中的添加元素的时候，首先添加在数组的末尾，这是因为移动次数最少，然后进行调整，使得调整后的数组仍然满足最大堆的性质。</p><p>具体步骤如下：</p><p>1、新加的元素放在数组的末尾；</p><p>2、新加入的元素调整元素的位置：只与父结点比较（不必与兄弟孩子比较），如果比父结点大，就交换位置，否则，可以停止了，这个元素就放在当前位置。</p><p>为什么我们要在数组的末尾添加一个元素呢？可不可以在开头、中间？既然我们使用数组来实现堆，对数组添加一个元素来说，实现复杂度最低的操作就是在数组的末尾添加元素，如若不然，要让数组中一部分的元素逐个后移，<strong>因此在数组的末尾加入元素是最自然的想法</strong>。但是在数组的末尾添加了一个元素，此时的数组就不满足堆的定义（性质），我们需要进行一系列的操作，去维护堆的定义（性质）。</p><h3 id="如何维护堆的定义和性质：通过-shift-up-把新添加的元素放置到合适的位置"><a href="#如何维护堆的定义和性质：通过-shift-up-把新添加的元素放置到合适的位置" class="headerlink" title="如何维护堆的定义和性质：通过 shift up 把新添加的元素放置到合适的位置"></a>如何维护堆的定义和性质：通过 <code>shift up</code> 把新添加的元素放置到合适的位置</h3><p>在数组的最后位置添加一个元素，新加入的元素只和父结点比较大小（无须和它的兄弟结点比较），只要比父结点大（严格大于），就往上走，<strong>否则停止，这个新添加的元素就放置在合适的位置，同时也调整了部分元素的位置</strong>。循环这样做，这样的过程叫做 <code>shift up</code>，<code>shift up</code> 也叫 <code>swim</code>，是“上浮”的意思。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__shift_up</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 有索引就要考虑索引越界的情况，已经在索引 1 的位置，就没有必要上移了</span>    <span class="token keyword">while</span> k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span>        k <span class="token operator">//=</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有索引就必须要考虑索引的边界问题，就是这里说的 <code>h &gt; 1</code>，因为当 <code>h = 1</code> 的时候，元素已经在堆顶， <code>Shift Up</code> 操作没有意义。</p><p>另外和“插入排序”的优化一样，先存一下这个可能会上移的元素，通过逐层赋值，实现与逐层交换上移等价的操作。</p><p>Python 代码：<code>shift up</code> 的过程可以转化为多次赋值</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__swim</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 上浮，与父结点进行比较</span>    temp <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 有索引就要考虑索引越界的情况，已经在索引 1 的位置，就没有必要上移了</span>    <span class="token keyword">while</span> k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span>        k <span class="token operator">//=</span> <span class="token number">2</span>    self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>shift up</code> 是 <code>insert</code> 的一个子过程，有了 <code>shift up</code> ，<code>insert</code> 函数就可以很快写出来 ：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>        <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'堆的容量不够了'</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>    self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> item    <span class="token comment" spellcheck="true"># 考虑将它上移</span>    self<span class="token punctuation">.</span>__swim<span class="token punctuation">(</span>self<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最大堆的第-2-个重要操作：向从一个最大堆中取出元素"><a href="#最大堆的第-2-个重要操作：向从一个最大堆中取出元素" class="headerlink" title="最大堆的第 2 个重要操作：向从一个最大堆中取出元素"></a>最大堆的第 2 个重要操作：向从一个最大堆中取出元素</h2><p>根据堆有序的性质，根结点是堆（数组）中最大的元素，即索引为 $1$ 的元素。从最大堆中取出一个元素，即是取出根结点元素，同时还要保持最大堆的性质。</p><p>根结点取出以后，$1$ 号索引位置为空，于是我们将当前数组的最后一个元素放到 $1$ 号索引的位置，这样做是<strong>因为交换和移动的次数最少</strong>，这种想法也应该是十分自然的，并且保持了完全二叉树的性质，但是此时数组并不满足最大堆的性质，我们就要进行 <code>shift down</code> 的操作使这个数组保持最大堆的性质。</p><p><code>shift down</code> 的具体操作步骤：从 $1$ 号索引开始，如果存在右孩子，就把右孩子和左孩子比较，比出最大的那个，再和自己比较，如果比自己大，就交换位置，这样的过程直到“不小于两个孩子结点中的最大者”。</p><p>同理，我们可以写出 <code>shift down</code> 的两个版本：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__shift_down</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 只要有左右孩子，左右孩子只要比自己大，就交换</span>    <span class="token keyword">while</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 如果这个元素有左边的孩子</span>        j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k        <span class="token comment" spellcheck="true"># 如果有右边的孩子，大于左边的孩子，就好像左边的孩子不存在一样</span>        <span class="token keyword">if</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>count <span class="token operator">and</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">>=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        k <span class="token operator">=</span> j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：当我们从 1 开始存放最大堆的元素的时候，最大堆的最后一个元素是 <code>data[count]</code>。</p><p>在完全二叉树中，如何表示有孩子？其实有左孩子就够了。这里的循环条件是 <code>2 * k &lt;= count</code> ，等于号不能漏掉，自己手画一个完全二叉树就清楚了。</p><p>在结点存在子结点的情况下，先判断是否存在右孩子，如果存在右孩子，就一定有左孩子，然后把右孩子和左孩子比较，比出最大的那个，再和自己比较，如果比自己大，就交换位置，这样的过程直到“自己比左右两个孩子都大”为止。</p><p>和上一节 shift up 的优化的思路一样：逐渐下移的过程可以不用逐层交换，借用插入排序优化的思路，多次赋值，一次交换。于是，我们有了版本 2 。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__sink</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 下沉</span>    temp <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 只要它有孩子，注意，这里的等于号是十分关键的</span>    <span class="token keyword">while</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">:</span>        j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k        <span class="token comment" spellcheck="true"># 如果它有右边的孩子，并且右边的孩子大于左边的孩子</span>        <span class="token keyword">if</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>count <span class="token operator">and</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 右边的孩子胜出，此时可以认为没有左孩子</span>            j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 如果当前的元素的值，比右边的孩子节点要大，则逐渐下落的过程到此结束</span>        <span class="token keyword">if</span> temp <span class="token operator">>=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token comment" spellcheck="true"># 否则，交换位置，继续循环</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        k <span class="token operator">=</span> j    self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>shift down</code> 是 <code>extract_max</code> 的一个子过程，有了 <code>shift down</code>，<code>extract_max</code> 函数就可以很快写出来。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">extract_max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'堆里没有可以取出的元素'</span><span class="token punctuation">)</span>    ret <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    self<span class="token punctuation">.</span>count <span class="token operator">-=</span> <span class="token number">1</span>    self<span class="token punctuation">.</span>__sink<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整代码：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 通过 LeetCode 第 215 题、第 295 题测试</span><span class="token keyword">class</span> <span class="token class-name">MaxHeap</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 我们这个版本的实现中，0 号索引是不存数据的，这一点一定要注意</span>        <span class="token comment" spellcheck="true"># 因为数组从索引 1 开始存放数值</span>        <span class="token comment" spellcheck="true"># 所以开辟 capacity + 1 这么多大小的空间</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>None <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 当前堆中存储的元素的个数</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 堆中能够存储的元素的最大数量（为简化问题，不考虑动态扩展）</span>        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        返回最大堆中的元素的个数        :return:        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count    <span class="token keyword">def</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        返回最大堆中的元素是否为空        :return:        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'堆的容量不够了'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> item        <span class="token comment" spellcheck="true"># 考虑将它上移</span>        self<span class="token punctuation">.</span>__swim<span class="token punctuation">(</span>self<span class="token punctuation">.</span>count<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__shift_up</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 有索引就要考虑索引越界的情况，已经在索引 1 的位置，就没有必要上移了</span>        <span class="token keyword">while</span> k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span>            k <span class="token operator">//=</span> <span class="token number">2</span>    <span class="token keyword">def</span> <span class="token function">__swim</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 上浮，与父结点进行比较</span>        temp <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 有索引就要考虑索引越界的情况，已经在索引 1 的位置，就没有必要上移了</span>        <span class="token keyword">while</span> k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span>            k <span class="token operator">//=</span> <span class="token number">2</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp    <span class="token keyword">def</span> <span class="token function">extract_max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'堆里没有可以取出的元素'</span><span class="token punctuation">)</span>        ret <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>count <span class="token operator">-=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>__sink<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> ret    <span class="token keyword">def</span> <span class="token function">__shift_down</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 只要有左右孩子，左右孩子只要比自己大，就交换</span>        <span class="token keyword">while</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 如果这个元素有左边的孩子</span>            j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k            <span class="token comment" spellcheck="true"># 如果有右边的孩子，大于左边的孩子，就好像左边的孩子不存在一样</span>            <span class="token keyword">if</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>count <span class="token operator">and</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">>=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span>            k <span class="token operator">=</span> j    <span class="token keyword">def</span> <span class="token function">__sink</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 下沉</span>        temp <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 只要它有孩子，注意，这里的等于号是十分关键的</span>        <span class="token keyword">while</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>count<span class="token punctuation">:</span>            j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k            <span class="token comment" spellcheck="true"># 如果它有右边的孩子，并且右边的孩子大于左边的孩子</span>            <span class="token keyword">if</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>count <span class="token operator">and</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 右边的孩子胜出，此时可以认为没有左孩子</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 如果当前的元素的值，比右边的孩子节点要大，则逐渐下落的过程到此结束</span>            <span class="token keyword">if</span> temp <span class="token operator">>=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            <span class="token comment" spellcheck="true"># 否则，交换位置，继续循环</span>            self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            k <span class="token operator">=</span> j        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    max_heap <span class="token operator">=</span> MaxHeap<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    max_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>max_heap<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    max_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>max_heap<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    max_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>max_heap<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    max_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>max_heap<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    max_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>max_heap<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    max_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token operator">not</span> max_heap<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'取出'</span><span class="token punctuation">,</span> max_heap<span class="token punctuation">.</span>extract_max<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，我们就可以通过“最大堆”实现排序功能了。“最小堆”可以如法炮制。</p><p>我们已经实现了最大堆的<strong>入队</strong>和<strong>出队</strong>两个基本操作，我们完全通过直接输出元素来检验一下，自己写出的最大堆是否符合最大堆的性质。因为每一次从最大堆取出的总是数组中最大的元素，所以可以将最大堆用于排序。</p><h2 id="优先队列的应用"><a href="#优先队列的应用" class="headerlink" title="优先队列的应用"></a>优先队列的应用</h2><p>1、多路归并排序</p><p>LeetCode 第 23 题：<a href="https://leetcode.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="noopener">23. Merge k Sorted Lists</a>；</p><p>传送门：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="noopener">23. 合并K个排序链表</a>；</p><p>题解：<a href="https://liweiwei1419.github.io/leetcode-solution/leetcode-0023-merge-k-sorted-lists/。" target="_blank" rel="noopener">https://liweiwei1419.github.io/leetcode-solution/leetcode-0023-merge-k-sorted-lists/。</a></p><p>2、图论中的最小生成树算法；</p><p>3、图论中的最短路径算法；</p><p>4、哈夫曼树与哈夫曼编码；</p><p>另外，在 LeetCode 上使用堆解决的问题有：</p><p>LeetCode 第 451 题：<a href="https://leetcode-cn.com/problems/sort-characters-by-frequency" target="_blank" rel="noopener">根据字符出现频率排序</a></p><p>LeetCode 第 703 题：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream" target="_blank" rel="noopener">数据流中的第K大元素</a></p><p>LeetCode 第 295 题：<a href="https://leetcode-cn.com/problems/find-median-from-data-stream" target="_blank" rel="noopener">数据流的中位数</a></p><h3 id="本文源代码"><a href="#本文源代码" class="headerlink" title="本文源代码"></a>本文源代码</h3><p>Python：<a href="https://github.com/liweiwei1419/Algorithms-Learning-Python/tree/master/heap" target="_blank" rel="noopener">代码文件夹</a>，Java：<a href="https://github.com/liweiwei1419/Algorithms-Learning-Java/tree/master/06-Heap/src" target="_blank" rel="noopener">代码文件夹</a>。</p><p>（本节完）</p><blockquote><p>堆是一种定义在数组上的「树」结构，设计很巧妙。是我刚开始喜欢上的「数据结构」。</p></blockquote><h2 id="认识优先队列（Priority-Queue）与堆（Heap）"><a href="#认识优先队列（Priority-Queue）与堆（Heap）" class="headerlink" title="认识优先队列（Priority Queue）与堆（Heap）"></a>认识优先队列（Priority Queue）与堆（Heap）</h2><p>首先我们要弄清楚的两个概念是“优先队列”与“堆”。</p><ul><li>什么是“队列”？<br>我们知道“队列”是一种先进先出（FIFO）的数据结构，出队顺序谁先来谁先出去，有点先到先得的意思，日常生活中，随处可见的排队现象，抽象出来，就是“队列”这种数据结构。</li><li>什么是“优先队列”？<br>但同时，在我们的生活中，有些情况下，并不是按照谁先来，谁先处理的原则来处理事情，例如，我们自己的时间管理，我们会先处理最重要或者是最紧急的事情。又或者是我们非常看不惯的一种现象是，有些服务会针对 VIP 用户优先处理。“优先队列”的思想就类似与我们处理这一类问题的思路，我们按照问题或者任务的重要程度（有的时候称之为优先级），处理觉得更重要，优先级更高的事情，而不是来一个问题就马上处理解决这个问题。</li><li>普通队列与优先队列的比较：</li></ul><table><thead><tr><th>普通队列</th><th>优先队列</th></tr></thead><tbody><tr><td>先进先出，后进后出。时间顺序决定了出队顺序。</td><td>出队顺序与入队顺序无关，只与队列中元素的优先级有关，优先级最高的元素最先出队。</td></tr></tbody></table><ul><li>以下“优先队列”的两个重要操作：1、入队；2、<strong>出队</strong>。优先队列的一个重要特点是：出队的时候总是取出优先级最高的那个元素。</li><li>那么，什么是“堆”呢？“堆”是“优先队列”的一种实现，除了“堆”以外，我们还可以使用“普通的数组”和“顺序排放的数组”来实现“优先队列”，“优先队列”是更抽象的数据结构。这里我们所说的“堆”，通常是指“二叉堆”。</li></ul><h3 id="三种数据结构对于实现优先队列的时间复杂度的比较-1"><a href="#三种数据结构对于实现优先队列的时间复杂度的比较-1" class="headerlink" title="三种数据结构对于实现优先队列的时间复杂度的比较"></a>三种数据结构对于实现优先队列的时间复杂度的比较</h3><table><thead><tr><th>使用什么数据结构来实现优先队列</th><th>入队操作</th><th>出队操作</th></tr></thead><tbody><tr><td>普通数组</td><td>$O(1)$</td><td>$O(n)$</td></tr><tr><td>顺序数组</td><td>$O(n)$</td><td>$O(1)$</td></tr><tr><td>堆（就是优先队列）</td><td>$O(\log n)$</td><td>$O(\log n)$</td></tr></tbody></table><p>其中，$logn$ 表示以 $2$ 为底的 $n$ 的对数。于是，我们伟大的计算机科学家平衡了入队和出队这两个操作的时间复杂度，这种数据结构就是堆。</p><p>综上所述，<strong>堆是一种实现优先队列的高效的数据结构</strong>。</p><blockquote><p>优先队列是数据结构，堆是优先队列的一种高效实现。</p></blockquote><h2 id="堆的基本实现：二叉堆"><a href="#堆的基本实现：二叉堆" class="headerlink" title="堆的基本实现：二叉堆"></a>堆的基本实现：二叉堆</h2><p>通过上一小节的介绍，我们可以看到堆的入队和出队的时间复杂度都是 $O(\log n)$ ，因此我们可以猜测它的形状一定看起来像是一棵树一样。根据我们希望出队的元素是整个队中最大的那个元素或者是最小的那个元素来划分堆，我们可以将堆分为最大堆和最小堆。</p><p>在这里说一个说明，对于一般教科书上已经有的，或者给出名词就很好理解的概念，我们在这里就不重复描述了，因为那样做就只是在抄书而已，虽然那样做会让我的描述变得很严谨，但会显得这篇文章很长，不方便阅读和复习，我们写出来的，都只是一些必要的，关键的，在我的学习中觉得难以理解的地方。</p><p>我们完全可以通过对一个例子的描述，来认识堆。以下就是一个最大堆的例子。</p><p><img src="https://liweiwei1419.gitee.io/images/algorithms/%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E4%BE%8B%E5%AD%90.jpg" alt=""></p><h3 id="二叉堆-Binary-Heap-的特点"><a href="#二叉堆-Binary-Heap-的特点" class="headerlink" title="二叉堆 Binary Heap 的特点"></a>二叉堆 Binary Heap 的特点</h3><p>1、这是一棵树；</p><p>2、最大的元素在树根，这个元素就是我们上面所说的优先级最高，最重要的那个元素，我们出队就应该把它出队列出拿出来（这种操作有的时候又叫做“删除”，这并不难理解，我们处理完一个任务，就应该把它从我们的任务清单中划去）；</p><p>3、把每一棵子树单独拿出来看，孩子结点小于父结点，换句话说，父亲结点一定比孩子结点大（为了避免问题复杂化，我们假设进入堆中的元素互不相同）；</p><p>4、<strong>堆是一棵完全二叉树</strong>。</p><p><strong>完全二叉树的性质：从形状上看，除了最后一层之外，其它层结点的数量应该是最大值，并且最后一层的结点应该集中在左侧。</strong></p><p>马上我们就可以看到，<strong>完全二叉树这个性质为我们定位这棵树上的结点位置提供了方便</strong>。</p><p>看到这里，或许我们在脑子里有个疑问，那么既然堆是一棵树，我们是不是要把堆实现成一个一个结点和指针组成的树呢？其实是可以的，但是我们还注意到<strong>堆是一棵完全二叉树</strong>，因此把堆用数组存起来会更加方便，因为在一般意义上，操作数组的下标，比操作结点和指针要方便一些，这一点我们马上就会看到。</p><h3 id="使用数组实现二叉堆"><a href="#使用数组实现二叉堆" class="headerlink" title="使用数组实现二叉堆"></a>使用数组实现二叉堆</h3><p>因为最大堆是一颗完全二叉树，我们可以使用“树”这个数据结构来实现。但是，最大堆的一个经典的实现是：使用数组存储二叉堆。使用数组实现二叉堆的方式是：自上到下、自左到右对下标进行标记，0 号下标不使用，从 1 号下标开始使用（这是一种经典的做法）。</p><p>之所以，0 号下标不使用，是因为从 1 开始下标，对于二叉堆来说，有比较简单的性质。不过根据我们应用的场景，我们也会使用从 0  号下标 开始的最大堆。</p><h3 id="从下标为-1-开始的数组实现的二叉堆的性质"><a href="#从下标为-1-开始的数组实现的二叉堆的性质" class="headerlink" title="从下标为 1 开始的数组实现的二叉堆的性质"></a>从下标为 1 开始的数组实现的二叉堆的性质</h3><p>我们自己画一个二叉堆（如下图），把下标标注在二叉堆上，自上到下、自左到右对下标从 1 号下标开始标记，即显示成结点的旁边黑色的数字，我们不难发现这些数字的排列形成的规律。<strong>正是因为堆是一棵完全二叉树，有如下的规律，我们才可以很方便地下标数组中的位置，这就是我们为什么使用数组而不是使用树来实现堆。</strong></p><ul><li>重要性质1：一个结点的左结点的下标是这个结点的编号的 2 倍；</li><li>重要性质2：一个结点的右结点的下标是这个结点的编号的 2 倍 + 1。</li></ul><p>因此，要想找到父结点：${\rm parent(i)}=\cfrac{i}{2}$，注意这里不能整除的时候需要向下取整。</p><p>要想找到两个子结点：${\rm left\ child = 2 \times i}$，${\rm right\ child} = 2 \times i+1$。</p><p>这个两条性质不用记，我们只要拿一张纸，画一个草图，这个性质就一目了然了。</p><h3 id="体会使用数组来表示一个完全二叉树的好处"><a href="#体会使用数组来表示一个完全二叉树的好处" class="headerlink" title="体会使用数组来表示一个完全二叉树的好处"></a>体会使用数组来表示一个完全二叉树的好处</h3><p>上面这张图用数组表示出来，就是一个最大堆。它在我们的程序中是这样表示的：</p><table><thead><tr><th>下标号</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>10</th><th>9</th></tr></thead><tbody><tr><td>元素值</td><td>null</td><td>62</td><td>41</td><td>30</td><td>28</td><td>16</td><td>22</td><td>13</td><td>19</td><td>15</td><td>17</td></tr></tbody></table><p>是不是很酷，在这里我们<strong>使用数组来表示了一个树结构</strong>，借助了完全二叉树的性质，这一点刚刚接触的时候可能会比较陌生，在以后，接触线段树的时候，我们还会体会这种处理问题的方法。</p><p>在这里啰嗦一句，如果我们使用树结构来保存上面那张图的数据，我们要创建 10 个结点，并且还要指明它们之间的引用关系，那样做显然就太复杂了。下面给出了使用数组实现最大堆的一个基本实现框架。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 我们这个版本的实现中，0 号下标是不存数据的，这一点一定要注意</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MaxHeap</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前堆中存储的元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 堆中能够存储的元素的最大数量（为简化问题，不考虑动态扩展）</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化最大堆</span>    <span class="token keyword">public</span> <span class="token function">MaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化底层数组元素（ 0 号下标位置不存数据，这是为了使得通过父结点获得左右孩子有更好的表达式）</span>        data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回堆中的元素个数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回一个布尔值，返回堆中是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大堆的第-1-个重要操作：向一个最大堆中添加元素"><a href="#最大堆的第-1-个重要操作：向一个最大堆中添加元素" class="headerlink" title="最大堆的第 1 个重要操作：向一个最大堆中添加元素"></a>最大堆的第 1 个重要操作：向一个最大堆中添加元素</h3><h4 id="什么是-shift-up？"><a href="#什么是-shift-up？" class="headerlink" title="什么是 shift up？"></a>什么是 shift up？</h4><ul><li>向一个最大堆中的添加元素的时候，是在数组的末尾添加元素，然后进行调整，使得调整后的数组仍然满足最大堆的性质，这个调整的操作就叫做 <strong>shift up</strong>。具体步骤如下：</li></ul><ol><li><strong>新加的元素，放在数组的末尾</strong>，我们马上解释为什么要把新加入的元素放在数组的末尾；</li><li>新加入的元素调整元素的位置：只与父结点比较（不必与兄弟结点比较），如果比父结点大，就交换位置，否则，可以停止了，这个元素就放在当前位置。</li></ol><ul><li><strong>为什么我们要在数组的末尾添加一个元素呢？可不可以在开头、中间？</strong></li></ul><p>在这里还是说几句废话，既然我们使用数组来实现堆，对数组添加一个元素来说，实现复杂度最低的操作就是在数组的末尾添加元素，如若不然，要让数组中一部分的元素逐个后移，产生性能消耗，<strong>因此在数组的末尾加入元素是最自然的想法</strong>。但是在数组的末尾添加了一个元素，此时的数组就不满足堆的定义（性质），我们须要进行一系列的操作，去维护堆的定义（性质）。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> count <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> capacity<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把新添加的元素放在数组的最后一位，对应于最大堆最后一个叶子结点</span>    data<span class="token punctuation">[</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 考虑将它上移</span>    <span class="token function">shiftUp</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里还是强调一点，以下代码所有的实现，下标都从 1 开始。shift up 就是把指定下标的元素与父结点进行比较，如果父结点大，就与父结点进行交换，依次进行下去。</p><p>版本 1 ：思路和插入排序的优化一样，先存一下这个可能会上移的元素，通过逐层赋值，实现与逐层交换上移等价的操作。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">shiftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 有下标就要考虑下标越界的情况，已经在下标 1 的位置，就没有必要上移了</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        k <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index1 <span class="token operator">==</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>    data<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>    data<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：没有交换操作。</p><p>版本 2 ：基本实现，即逐层交换上移的实现。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">shiftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 有下标就要考虑下标越界的情况，已经在下标 1 的位置，就没有必要上移了</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// swap(int[] data, int index1, int index2) 代码实现与上同。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：有交换操作。</p><p>版本 3 ：for 循环实现（与版本 2 相同，只是写法不一样）。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">shiftUp</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> count<span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> k <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> k<span class="token punctuation">,</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：有交换操作。</p><h3 id="最大堆的第-2-个重要操作：向一个最大堆中取出元素"><a href="#最大堆的第-2-个重要操作：向一个最大堆中取出元素" class="headerlink" title="最大堆的第 2 个重要操作：向一个最大堆中取出元素"></a>最大堆的第 2 个重要操作：向一个最大堆中取出元素</h3><p>Java 代码：</p><p>这一小节，我们解决这样一个问题，从最大堆中取出一个元素，同时还要保持最大堆的性质，即根元素是堆（数组）中最大的元素。</p><p>从最大堆中取出元素，<strong>一定是取出根结点处的元素</strong>，即位于 1 号下标的那个元素。</p><p>取出以后，1 号下标位置为空，于是我们将最后一个元素放到 1 号下标的位置，这样做是<strong>因为交换和移动的次数最少</strong>，这种想法也应该是十分自然的，并且保持了完全二叉树的性质，但是此时数组并不满足最大堆的性质，我们就要进行 shift down 的操作来使这个数组保持最大堆的性质。</p><h4 id="什么是-shift-down？"><a href="#什么是-shift-down？" class="headerlink" title="什么是 shift down？"></a>什么是 shift down？</h4><p>shift down 的具体操作步骤：从 1 号下标开始，如果存在右孩子，就把右孩子和左孩子比较，比出最大的那个，再和自己比较，如果比自己大，就交换位置，这样的过程直到“自己比左右两个孩子都大”为止。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 取出最大堆中的根结点 * 1、把最后一个元素和下标是 1 的元素进行交换 * 2、从根结点开始逐层下移：下移的过程中将与左右孩子结点进行比较，把最大的那个跟自己交换 * * @return 根结点的元素 */</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">extractMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token function">shiftDown</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>版本 1 ：基本实现：逐层交换下移。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 只要有左右孩子，左右孩子只要比自己大，就交换** @param h*/</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">shiftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> h <span class="token operator">&lt;=</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果这个元素有左边的孩子</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> h<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> count <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果有右边的孩子，大于左边的孩子，就好像左边的孩子不存在一样</span>            k <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> h<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        h <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些说明：</p><ul><li>最大堆的最后一个元素是 data[count]。</li><li>在完全二叉树中，如何表示有孩子？结论：有左孩子就够了。这里的循环条件是 <code>2*k &lt;= count</code> ，等于号不能漏掉，自己手画一个完全二叉树就清楚了。<br>和上一节 shift up 的优化的思路一样：逐渐下移的过程可以不用逐层交换，借用插入排序优化的思路，多次赋值，一次交换。于是，我们有了版本 2 。</li></ul><p>版本 2 ：思路和插入排序的优化一样，先存一下这个可能会下移的元素，通过逐层赋值，实现与逐层交换下移等价的操作。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">shiftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 只要它有孩子，注意，这里的等于号是十分关键的</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果它有右边的孩子，并且右边的孩子大于左边的孩子</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> count <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 右边的孩子胜出，此时可以认为没有左孩子，</span>            j <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果当前的元素的值，比右边的孩子结点要大，则逐渐下落的过程到此结束</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">>=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 否则，交换位置，继续循环</span>        data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写到这里，我们已经实现了最大堆的<strong>入队</strong>和<strong>出队</strong>两个基本操作，我们完全可以借助最大堆的这个性质来帮助我们完成排序工作了。借助堆这个数据结构，我们能很轻松地想出利用堆进行排序的步骤。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 10：优先队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 739 题：每日温度（单调栈）（单调栈）</title>
      <link href="/leetcode-algo/2017/09/23/leetcode-algo/0739-daily-temperatures/"/>
      <url>/leetcode-algo/2017/09/23/leetcode-algo/0739-daily-temperatures/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-739-题：每日温度（单调栈）"><a href="#「力扣」第-739-题：每日温度（单调栈）" class="headerlink" title="「力扣」第 739 题：每日温度（单调栈）"></a>「力扣」第 739 题：每日温度（单调栈）</h2><p>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures</a></p><p>题解链接：<a href="https://leetcode-cn.com/problems/daily-temperatures/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419/</a></p><p>难易程度：中等。</p><blockquote><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p>提示：气温 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p></blockquote><h3 id="方法一：暴力解法（Brute-Force）"><a href="#方法一：暴力解法（Brute-Force）" class="headerlink" title="方法一：暴力解法（Brute Force）"></a>方法一：暴力解法（Brute Force）</h3><p>关键是：<strong>找出右边第 1 个严格大于自己的元素的索引</strong>。</p><p>问题是：就像选择排序一样，上一轮的操作并没有为下一轮的操作留下什么有用的信息。</p><blockquote><p>这件事情就是<strong>单调栈</strong>能做的事情，记住这个结论。</p></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        res<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> curVal <span class="token operator">=</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> curVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9jd8e10k2j30sk06ogmg.jpg" alt="image-20191203111906535"></p><h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h3><blockquote><p>要点：</p><p>1、单调栈里面存的是索引；</p><p>2、比较的是元素的值。</p></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 时间复杂度：O(N)</span>    <span class="token comment" spellcheck="true">// 空间复杂度：O(N)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1、存的是索引</span>        <span class="token comment" spellcheck="true">// 2、对应的值的特点，单调不减</span>        <span class="token comment" spellcheck="true">// 3、出栈的时候，记录 res</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 注意 1：根据题意，这里要写等于号</span>            <span class="token comment" spellcheck="true">// 注意 2：不能把 while 写成 if</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> T<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> index <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> index<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 8：单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 503 题：下一个更大元素 II（单调栈）</title>
      <link href="/leetcode-algo/2017/09/22/leetcode-algo/0503-next-greater-element-ii/"/>
      <url>/leetcode-algo/2017/09/22/leetcode-algo/0503-next-greater-element-ii/</url>
      
        <content type="html"><![CDATA[<h3 id="「力扣」第-503-题：下一个更大元素-II"><a href="#「力扣」第-503-题：下一个更大元素-II" class="headerlink" title="「力扣」第 503 题：下一个更大元素 II"></a>「力扣」第 503 题：下一个更大元素 II</h3><ul><li>链接：<a href="https://leetcode-cn.com/problems/next-greater-element-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-ii</a></li></ul><blockquote><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 <code>x</code> 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p>示例 1：</p><pre><code>输入: [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</code></pre><p>注意：输入数组的长度不会超过 10000。</p></blockquote><p>思路：接着第 496 题做。</p><p>技巧：</p><p>1、处理循环问题的套路是在后面再拼上一个相同的数组；</p><p>2、因为得建议弹出元素和当前看到的元素对应关系，因此栈中存的是索引；</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 存的应该是索引</span>        <span class="token comment" spellcheck="true">// 如果新来的数小于等于栈顶，就添加，如果严格大于，就弹栈</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> len <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 不能直接对 i 取模，否则会影响遍历，进入死循环</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">%</span> len<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> index <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 栈中元素为空的时候，后面的元素就没有必要看了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 拼接循环数组，这是常用技巧</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> len1 <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numsCirculate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> numsCirculate<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> numsCirculate<span class="token punctuation">,</span> len1<span class="token punctuation">,</span> len1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化为 -1 的原因：在遍历终止的时候，栈中还存在的那些元素表示它们的右边没有比它大的元素</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len2<span class="token punctuation">]</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 存的应该是索引</span>        <span class="token comment" spellcheck="true">// 如果新来的数小于等于栈顶，就添加，如果严格大于，就弹栈</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> numsCirculate<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> numsCirculate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> index <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> numsCirculate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 只要前一半即可</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newRes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newRes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> newRes<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextGreaterElements</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化为 -1 的原因：在遍历终止的时候，栈中还存在的那些元素表示它们的右边没有比它大的元素</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 存的应该是索引</span>        <span class="token comment" spellcheck="true">// 如果新来的数小于等于栈顶，就添加，如果严格大于，就弹栈</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> len <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 不能直接对 i 取模，否则会影响遍历，进入死循环</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">%</span> len<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> index <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 超出 len 的那部分，是虚拟的，因此没有比较计算结果</span>            <span class="token comment" spellcheck="true">// 遍历第 2 遍，是为了让栈弹出为空</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 栈中元素为空的时候，后面的元素就没有必要看了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">nextGreaterElements</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 8：单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 496 题：下一个更大元素 I（简单）</title>
      <link href="/leetcode-algo/2017/09/21/leetcode-algo/0496-next-greater-element-i/"/>
      <url>/leetcode-algo/2017/09/21/leetcode-algo/0496-next-greater-element-i/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-496-题：下一个更大元素-I（简单）"><a href="#「力扣」第-496-题：下一个更大元素-I（简单）" class="headerlink" title="「力扣」第 496 题：下一个更大元素 I（简单）"></a>「力扣」第 496 题：下一个更大元素 I（简单）</h2><p>题解：<a href="https://leetcode-cn.com/problems/next-greater-element-i/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-i/solution/bao-li-jie-fa-dan-diao-zhan-by-liweiwei1419-2/</a></p><blockquote><p>给定两个 没有重复元素 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。找到 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p><p><code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code> 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><pre><code>输入: nums1 = [4, 1, 2], nums2 = [1, 3, 4, 2].输出: [-1, 3, -1]解释: 对于 num1 中的数字 4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。 对于 num1 中的数字 1，第二个数组中数字 1 右边的下一个较大数字是 3。 对于 num1 中的数字 2，第二个数组中没有下一个更大的数字，因此输出 -1。</code></pre><p>示例 2:</p><pre><code>输入: nums1 = [2, 4], nums2 = [1, 2, 3, 4].输出: [3, -1]解释: 对于 num1 中的数字 2，第二个数组中的下一个较大数字是 3。 对于 num1 中的数字 4，第二个数组中没有下一个更大的数字，因此输出 -1。</code></pre><p>注意:</p><p>1、<code>nums1</code> 和 <code>nums2</code> 中所有元素是唯一的。<br>2、<code>nums1</code> 和 <code>nums2</code>  的数组大小都不超过1000。 </p></blockquote><p>单调栈技巧：画图。</p><h3 id="方法一：暴力解法（Brute-Force）"><a href="#方法一：暴力解法（Brute-Force）" class="headerlink" title="方法一：暴力解法（Brute Force）"></a>方法一：暴力解法（Brute Force）</h3><p>就根据题目意思来写。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len1 <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> curVal <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> len2 <span class="token operator">&amp;&amp;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> curVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 此时 nums[j] = nums[i]</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> len2 <span class="token operator">&amp;&amp;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> curVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> len2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(NM)$，这里 $N$ 是数组 <code>nums1</code> 的长度， $M$ 是数组 <code>nums2</code> 的长度</li><li>空间复杂度：$O(N)$。</li></ul><h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h3><p>1、找右边第 1 个大于自己的元素，这种问题的套路就是使用栈，并且这个栈的特点是：从栈底到栈顶是单调不增的；</p><p>2、编码技巧：画图模拟栈是如何工作的，帮助编码和思考细节。</p><p>（1）这里要预处理数组 <code>nums2</code> ，每一次弹栈的操作，弹出的那个元素是较小的元素，入栈的那个元素是第 1 个比弹出的那个元素大的元素，于是我们可以建立对应关系：</p><pre><code>key：弹出元素，value：入栈元素。</code></pre><p>放置在一个哈希表中。</p><p>（2）最后遍历一次数组 <code>nums1</code> 从哈希表中获得结果。</p><p>![image-20191203165042581](/Users/liwei/Library/Application Support/typora-user-images/image-20191203165042581.png)</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">nextGreaterElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len1 <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> len2 <span class="token operator">=</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对 nums2 先预处理</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 遍历 nums1 得到结果集</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len1<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(N + M)$，分别遍历数组 <code>nums1</code> 和数组 <code>nums2</code> 各一次即可。</li><li>空间复杂度：$O(N)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 专题 8：单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 475 题：供暖器（简单）</title>
      <link href="/leetcode-algo/2017/09/20/leetcode-algo/0475-heaters/"/>
      <url>/leetcode-algo/2017/09/20/leetcode-algo/0475-heaters/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-475-题：供暖器（简单）"><a href="#「力扣」第-475-题：供暖器（简单）" class="headerlink" title="「力扣」第 475 题：供暖器（简单）"></a>「力扣」第 475 题：供暖器（简单）</h2><p>链接：<a href="https://leetcode-cn.com/problems/heaters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/heaters</a></p><blockquote><p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p><p>现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。</p><p>所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。</p><p>说明:</p><p>1、给出的房屋和供暖器的数目是非负数且不会超过 25000。<br>2、给出的房屋和供暖器的位置均是非负数且不会超过10^9。<br>3、只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。<br>4、所有供暖器都遵循你的半径标准，加热的半径也一样。</p><p>示例 1：</p><pre><code>输入: [1,2,3],[2]输出: 1解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。</code></pre><p>示例 2：</p><pre><code>输入: [1,2,3,4],[1,4]输出: 1解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。</code></pre></blockquote><p>哨兵技巧。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 8：单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 456 题：132 模式（中等）</title>
      <link href="/leetcode-algo/2017/09/19/leetcode-algo/0456-132-pattern/"/>
      <url>/leetcode-algo/2017/09/19/leetcode-algo/0456-132-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-456-题：132-模式（中等）"><a href="#「力扣」第-456-题：132-模式（中等）" class="headerlink" title="「力扣」第 456 题：132 模式（中等）"></a>「力扣」第 456 题：132 模式（中等）</h2><p>链接：<a href="https://leetcode-cn.com/problems/132-pattern/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/132-pattern/</a></p><blockquote><p>给定一个整数序列：a1, a2, …, an，一个132模式的子序列 ai, aj, ak 被定义为：当 i &lt; j &lt; k 时，ai &lt; ak &lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。</p><p>注意：n 的值小于15000。</p><p>示例 1：</p><pre><code>输入: [1, 2, 3, 4]输出: False解释: 序列中不存在132模式的子序列。</code></pre><p>示例 2：</p><pre><code>输入: [3, 1, 4, 2]输出: True解释: 序列中有 1 个132模式的子序列： [1, 4, 2].</code></pre><p>示例 3：</p><pre><code>输入: [-1, 3, 2, 0]输出: True解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].</code></pre></blockquote><p>思路：从后向前枚举，记录当前记录之后的最大值是多少。单调栈。秘诀就是画图。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 8：单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 85 题：最大矩形（困难）</title>
      <link href="/leetcode-algo/2017/09/18/leetcode-algo/0085-maximal-rectangle/"/>
      <url>/leetcode-algo/2017/09/18/leetcode-algo/0085-maximal-rectangle/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://leetcode-cn.com/problems/maximal-rectangle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-rectangle</a></p><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p>示例：</p><p>输入：</p><pre><code>[  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</code></pre><p>输出：6</p><p>思路：接着第 85 题做。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 8：单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 84 题：柱状图中最大的矩形（困难）</title>
      <link href="/leetcode-algo/2017/09/17/leetcode-algo/0084-largest-rectangle-in-histogram/"/>
      <url>/leetcode-algo/2017/09/17/leetcode-algo/0084-largest-rectangle-in-histogram/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>应该先理解暴力解法，然后画图，去理解单调栈是如何工作的。</p></blockquote><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定 <code>n</code> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 $1$ 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="img"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2, 1, 5, 6, 2, 3]</code>。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="img"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例</strong>：</p><pre><code>输入: [2,1,5,6,2,3]输出: 10</code></pre></blockquote><h3 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h3><blockquote><p>枚举矩形的上边界为整个边界，然后求最大值。</p><p>1、左边看一下，最多能延伸多长；小于等于它的，第 1 个元素的位置；</p><p>2、右边看一下，最多能延伸多长；大于等于它的，第 1 个元素的位置；</p><p>左右是对称的。</p></blockquote><blockquote><p>1、看定义，就是单调栈的经典操作。</p><p>2、和双指针的思路是一样的，首先想一下暴力怎么写。</p></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 找左边第 1 个严格小于 heights[i] 的索引</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 找右边第 1 个严格小于 heights[i] 的索引</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// System.out.println("左：" + left + "，右："+ right + "，高："+ heights[i]);</span>            <span class="token keyword">int</span> width <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> width <span class="token operator">*</span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：单调栈"><a href="#方法二：单调栈" class="headerlink" title="方法二：单调栈"></a>方法二：单调栈</h3><blockquote><p>注意事项：</p><p>1、画图，动态分析，栈是如何工作的；</p><p>2、遍历的时候，当前试图添加进栈的柱形高度<strong>严格小于</strong>栈顶的柱形的高度的时候，栈顶的柱形面积可以确定，所以弹出。</p><ul><li>因为值可以确定，所以弹出；</li><li>计算面积的时候，高度是刚刚弹出的柱形的高度，宽度是柱形的左边和右边，左边是弹出以后的栈顶索引，右边就是目前视图添加进栈的索引，因此是 <code>(i - stack.peek() - 1)</code>；如果此时栈为空，说明，刚刚弹出的是目前看到的最小元素，它所确定的面积的宽度就是 <code>i</code></li></ul><p>3、最后不要忘记把栈清空一下。</p><ul><li>这一步可以加上一个哨兵，因为这个栈的特点是单调不减栈，因此，哨兵元素设置为 $0$ 即可。</li></ul></blockquote><p>点击：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/" target="_blank" rel="noopener">题解链接</a> 有更详细的介绍。</p><ul><li>不使用哨兵的写法</li></ul><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// top 所在的柱形的最大高度可以确定</span>                <span class="token keyword">int</span> top <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> width<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    width <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    width <span class="token operator">=</span> i <span class="token operator">-</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> heights<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">*</span> width<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 注意：如果栈里有元素，需要清空</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// top 所在的柱形的最大高度可以确定</span>            <span class="token keyword">int</span> top <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> width<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                width <span class="token operator">=</span> len<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                width <span class="token operator">=</span> len <span class="token operator">-</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> heights<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">*</span> width<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用哨兵的写法</li></ul><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">largestRectangleArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heights<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> heights<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 最后一个 0 类似于哨兵，为了将栈中的元素全部清空</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newHeights <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>heights<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newHeights<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        newHeights<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意：为了避免编码出错，将 heights 指向新的 newHeights</span>        heights <span class="token operator">=</span> newHeights<span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意：for 循环里面是小于等于，即 i &lt;= len</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> heights<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">></span> heights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// top 所在的柱形的最大高度可以确定</span>                <span class="token keyword">int</span> top <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> width<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    width <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    width <span class="token operator">=</span> i <span class="token operator">-</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> heights<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">*</span> width<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 8：单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「单调栈」专题：概述与参考资料</title>
      <link href="/leetcode-algo/2017/09/16/leetcode-algo/monotonous-stack/"/>
      <url>/leetcode-algo/2017/09/16/leetcode-algo/monotonous-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>参考资料：<a href="https://www.cnblogs.com/grandyang/p/8887985.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/8887985.html</a></p><p>单调栈其实就是栈。做单调栈的问题首先应该想到的是，我们需要「后进先出」这种数据结构作为缓存。</p><p>然后才是栈内的数据性质有单调性。</p><p>典型问题有：接雨水和柱状图中最大的矩形。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 8：单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 341 题：扁平化嵌套列表迭代器</title>
      <link href="/leetcode-algo/2017/09/12/leetcode-algo/0341-flatten-nested-list-iterator/"/>
      <url>/leetcode-algo/2017/09/12/leetcode-algo/0341-flatten-nested-list-iterator/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-341-题：扁平化嵌套列表迭代器"><a href="#「力扣」第-341-题：扁平化嵌套列表迭代器" class="headerlink" title="「力扣」第 341 题：扁平化嵌套列表迭代器"></a>「力扣」第 341 题：扁平化嵌套列表迭代器</h2><p>传送门：英文网址：<a href="https://leetcode.com/problems/flatten-nested-list-iterator/description/" target="_blank" rel="noopener">341. Flatten Nested List Iterator</a> ，中文网址：<a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/description/" target="_blank" rel="noopener">341. 扁平化嵌套列表迭代器</a> 。</p><blockquote><p>给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p><p>列表中的项或者为一个整数，或者是另一个列表。</p><p><strong>示例 1:</strong></p><pre><code>输入: [[1,1],2,[1,1]]输出: [1,1,2,1,1]解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [1,[4,[6]]]输出: [1,4,6]解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。</code></pre></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># </span><span class="token triple-quoted-string string">"""# This is the interface that allows for creating nested lists.# You should not implement it, or speculate about its implementation# """</span><span class="token comment" spellcheck="true"># class NestedInteger(object):</span><span class="token comment" spellcheck="true">#    def isInteger(self):</span><span class="token comment" spellcheck="true">#        </span><span class="token triple-quoted-string string">"""#        @return True if this NestedInteger holds a single integer, rather than a nested list.#        :rtype bool#        """</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#    def getInteger(self):</span><span class="token comment" spellcheck="true">#        </span><span class="token triple-quoted-string string">"""#        @return the single integer that this NestedInteger holds, if it holds a single integer#        Return None if this NestedInteger holds a nested list#        :rtype int#        """</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#    def getList(self):</span><span class="token comment" spellcheck="true">#        </span><span class="token triple-quoted-string string">"""#        @return the nested list that this NestedInteger holds, if it holds a nested list#        Return None if this NestedInteger holds a single integer#        :rtype List[NestedInteger]#        """</span><span class="token keyword">class</span> <span class="token class-name">NestedIterator</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nestedList<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize your data structure here.        :type nestedList: List[NestedInteger]        """</span>        self<span class="token punctuation">.</span>stack <span class="token operator">=</span> nestedList<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 临时存放值的地方</span>        self<span class="token punctuation">.</span>value <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">next</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :rtype: int        """</span>        result <span class="token operator">=</span> self<span class="token punctuation">.</span>hasNext<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> result<span class="token punctuation">:</span>            ret <span class="token operator">=</span> self<span class="token punctuation">.</span>value            self<span class="token punctuation">.</span>value <span class="token operator">=</span> None            <span class="token keyword">return</span> ret    <span class="token keyword">def</span> <span class="token function">hasNext</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :rtype: bool        """</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>value <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 就不执行了，因为没有被取出来</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token comment" spellcheck="true"># 如果 self.value 为 None 的话</span>        <span class="token comment" spellcheck="true"># 就要从 stack 中弹出元素了</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">:</span>            top <span class="token operator">=</span> self<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 如果栈中有元素，看看这个元素是什么</span>            <span class="token keyword">if</span> top<span class="token punctuation">.</span>isInteger<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 是数字，就放在临时变量上</span>                self<span class="token punctuation">.</span>value <span class="token operator">=</span> top<span class="token punctuation">.</span>getInteger<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>top<span class="token punctuation">.</span>getList<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token comment" spellcheck="true"># Your NestedIterator object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># i, v = NestedIterator(nestedList), []</span><span class="token comment" spellcheck="true"># while i.hasNext(): v.append(i.next())</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 230 题：二叉搜索树中第 K 小的元素</title>
      <link href="/leetcode-algo/2017/09/11/leetcode-algo/0230-kth-smallest-element-in-a-bst/"/>
      <url>/leetcode-algo/2017/09/11/leetcode-algo/0230-kth-smallest-element-in-a-bst/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-230-题：二叉搜索树中第-K-小的元素"><a href="#「力扣」第-230-题：二叉搜索树中第-K-小的元素" class="headerlink" title="「力扣」第 230 题：二叉搜索树中第 K 小的元素"></a>「力扣」第 230 题：二叉搜索树中第 K 小的元素</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/solution/di-gui-yu-fei-di-gui-xie-fa-tong-li-wan-cheng-di-1/" target="_blank" rel="noopener">递归与非递归写法（同理完成第 144、94、145 题，Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. 二叉搜索树中第K小的元素</a>。</p><blockquote><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p>示例 1:</p><p>输入: root = [3,1,4,null,2], k = 1<br>  3<br> / <br>1   4<br> <br>  2<br>输出: 1<br>示例 2:</p><p>输入: root = [5,3,6,2,4,null,null,1], k = 3<br>      5<br>     / <br>    3   6<br>   / <br>  2   4<br> /<br>1<br>输出: 3<br>进阶：<br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</p></blockquote><h2 id="递归与非递归写法（同理完成第-144、94、145-题，Python-代码、Java-代码）"><a href="#递归与非递归写法（同理完成第-144、94、145-题，Python-代码、Java-代码）" class="headerlink" title="递归与非递归写法（同理完成第 144、94、145 题，Python 代码、Java 代码）"></a>递归与非递归写法（同理完成第 144、94、145 题，Python 代码、Java 代码）</h2><p><strong>思路分析</strong>：利用“二叉搜索树”在“中序遍历”以后，得到的是有序数组，那么我们就中序遍历好了，遍历到第 $k$ 个数即可。</p><blockquote><p>我写下来发现递归的写法比较容易写错，要设置全局变量，而非递归的写法还相对比较“通用”且好理解。</p></blockquote><p><strong>参考代码 1</strong>：使用递归“中序遍历”。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = None# 使用递归的方法，中序遍历class Solution:    def __init__(self):        self.counter = 0        self.res = 0    def kthSmallest(self, root, k):        # 递归执行左子树的逻辑        if root.left:            # 不是空，才继续遍历            self.kthSmallest(root.left, k)        # 在这里执行操作，数到第 k 个即可        self.counter += 1        # print(root.val)        if self.counter == k:            # 注意：千万不能在这里返回，后序遍历还要继续进行下去            self.res = root.val            # 注意：这里不能加 return        # 递归执行右子树的逻辑        if root.right:            self.kthSmallest(root.right, k)        return self.resif __name__ == '__main__':    node3 = TreeNode(3)    node1 = TreeNode(1)    node4 = TreeNode(4)    node2 = TreeNode(2)    node3.left = node1    node3.right = node4    node1.right = node2    solution = Solution()    result = solution.kthSmallest(node3, k=1)    print(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) {        val = x;    }}// 解题关键：中序遍历// https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/description/// 给定一个二叉搜索树，编写一个函数kthSmallest来查找其中第 k 个最小的元素。// 只要利用二分搜索树的中序遍历，就可以完成。public class Solution {    private int count = 0;    private int res = 0;    private void dfs(TreeNode node) {        if (node == null) {            // 什么都不做            return;        }        dfs(node.left);        count--;        if (count == 0) {            this.res = node.val;        }        dfs(node.right);    }    // k 如果在方法传递的过程中是值传递，所以把它设置为成员变量，这样就是引用传递    // 因为我们要用到 k 全局的值，去数出，我是第几个中序遍历到的值    public int kthSmallest(TreeNode root, int k) {        count = k;        dfs(root);        return res;    }    public static void main(String[] args) {        TreeNode treeNode1 = new TreeNode(10);        TreeNode treeNode2 = new TreeNode(15);        TreeNode treeNode3 = new TreeNode(20);        treeNode2.left = treeNode1;        treeNode2.right = treeNode3;        Solution solution = new Solution();        int kthSmallest = solution.kthSmallest(treeNode2, 2);        System.out.println(kthSmallest);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是 Python 的另一种写法：使用 <code>global</code> 关键字，仍需使用辅助函数：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def kthSmallest(self, root, k):        global counter, res        counter = 0        res = 0        def dfs(root, k):            if not root:                # 如果是空，直接退出                return            dfs(root.left, k)            global counter, res            counter += 1            if counter == k:                res = root.val            dfs(root.right, k)        dfs(root, k)        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考代码 2</strong>：模拟系统栈的方式：使用二叉树非递归遍历的通用方法。使用同样的的方法还可以解决 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">「力扣」LeetCode 第 144 题：二叉树的前序遍历</a>、<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal" target="_blank" rel="noopener">「力扣」第 94 题：二叉树的中序遍历</a>、<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal" target="_blank" rel="noopener">「力扣」第 145 题：二叉树的后序遍历</a>。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    # 模拟系统栈的方式实现，是一种比较通用的做法，    # 可以作为二叉树的三种非递归遍历    def kthSmallest(self, root, k):        # 0 表示当前遍历到它，1 表示压入栈        # 刚开始是 1 ，不要写成 0 了        stack = [(1, root)]        while stack:            command, node = stack.pop()            if node is None:                # 不能写 return ，这不是递归                continue            if command == 0:                k -= 1                if k == 0:                    return node.val            else:                # 此时 command == 1 的时候，表示递归遍历到的                # 注意：写的时候倒过来写                stack.append((1, node.right))                stack.append((0, node))                stack.append((1, node.left))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实入栈的时候，就可以判断，我们只将非空结点入栈，<strong>推荐下面这种写法</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def kthSmallest(self, root, k):        stack = [(1, root)]        while stack:            command, node = stack.pop()            if command == 0:                k -= 1                if k == 0:                    return node.val            else:                # 模拟系统栈实现中序遍历(先左边、再自己、再右边)                # 注意：写的时候倒过来写                if node.right:                    stack.append((1, node.right))                stack.append((0, node))                if node.left:                    stack.append((1, node.left))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Stack;public class Solution4 {    private enum Action {        // GO 表示递归处理        // ADDTORESULT 表示当前马上执行将结点的值添加到结果集中        GO, ADDTORESULT    }    private class Command {        private Action action;        private TreeNode node;        public Command(Action action, TreeNode node) {            this.action = action;            this.node = node;        }    }    public int kthSmallest(TreeNode root, int k) {        Stack<Command> stack = new Stack<>();        stack.add(new Command(Action.GO, root));        while (!stack.isEmpty()) {            Command cur = stack.pop();            TreeNode node = cur.node;            if (cur.action == Action.ADDTORESULT) {                k--;                if (k == 0) {                    return node.val;                }            } else {                assert cur.action == Action.GO;                if (node.right != null) {                    stack.add(new Command(Action.GO, node.right));                }                stack.add(new Command(Action.ADDTORESULT, node));                if (node.left != null) {                    stack.add(new Command(Action.GO, node.left));                }            }        }        throw new RuntimeException("参数错误");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><Vssue title="kth-smallest-element-in-a-bst"/>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 155 题：最小栈</title>
      <link href="/leetcode-algo/2017/09/10/leetcode-algo/0155-min-stack/"/>
      <url>/leetcode-algo/2017/09/10/leetcode-algo/0155-min-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-155-题：最小栈"><a href="#「力扣」第-155-题：最小栈" class="headerlink" title="「力扣」第 155 题：最小栈"></a>「力扣」第 155 题：最小栈</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/min-stack/solution/shi-yong-fu-zhu-zhan-tong-bu-he-bu-tong-bu-python-/" target="_blank" rel="noopener">使用辅助栈（同步和不同步，Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a>。</p><blockquote><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。<br>示例:</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p></blockquote><h2 id="使用辅助栈（同步和不同步，Python-代码、Java-代码）"><a href="#使用辅助栈（同步和不同步，Python-代码、Java-代码）" class="headerlink" title="使用辅助栈（同步和不同步，Python 代码、Java 代码）"></a>使用辅助栈（同步和不同步，Python 代码、Java 代码）</h2><p>这道题的思想很简单：“以空间换时间”，使用<strong>辅助栈</strong>是常见的做法。</p><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>在代码实现的时候有两种方式：</p><p>1、辅助栈和数据栈同步</p><p>特点：编码简单，不用考虑一些边界情况，就有一点不好：辅助栈可能会存一些“不必要”的元素。</p><p>2、辅助栈和数据栈不同步</p><p>特点：由“辅助栈和数据栈同步”的思想，我们知道，当数据栈进来的数越来越大的时候，我们要在辅助栈顶放置和当前辅助栈顶一样的元素，这样做有点“浪费”。基于这一点，我们做一些“优化”，但是在编码上就要注意一些边界条件。</p><p>（1）辅助栈为空的时候，必须放入新进来的数；</p><p>（2）新来的数小于或者等于辅助栈栈顶元素的时候，才放入，特别注意<strong>这里“等于”要考虑进去，因为出栈的时候，连续的、相等的并且是最小值的元素要同步出栈</strong>；</p><p>（3）出栈的时候，辅助栈的栈顶元素<strong>等于</strong>数据栈的栈顶元素，才出栈。</p><p>总结一下：<strong>出栈时，最小值出栈才同步；入栈时，最小值入栈才同步</strong>。</p><p>对比：个人觉得“同步栈”的方式更好一些，因为思路清楚，因为所有操作都同步进行，所以调试代码、定位问题也简单。“不同步栈”，虽然减少了一些空间，但是在“出栈”、“入栈”的时候还要做判断，也有性能上的消耗。</p><h3 id="方法一：辅助栈和数据栈同步"><a href="#方法一：辅助栈和数据栈同步" class="headerlink" title="方法一：辅助栈和数据栈同步"></a>方法一：辅助栈和数据栈同步</h3><p><strong>参考代码 1</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class MinStack:    # 辅助栈和数据栈同步    # 思路简单不容易出错    def __init__(self):        # 数据栈        self.data = []        # 辅助栈        self.helper = []    def push(self, x):        self.data.append(x)        if len(self.helper) == 0 or x <= self.helper[-1]:            self.helper.append(x)        else:            self.helper.append(self.helper[-1])    def pop(self):        if self.data:            self.helper.pop()            return self.data.pop()    def top(self):        if self.data:            return self.data[-1]    def getMin(self):        if self.helper:            return self.helper[-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Stack;public class MinStack {    // 数据栈    private Stack<Integer> data;    // 辅助栈    private Stack<Integer> helper;    /**     * initialize your data structure here.     */    public MinStack() {        data = new Stack<>();        helper = new Stack<>();    }    // 思路 1：数据栈和辅助栈在任何时候都同步    public void push(int x) {        // 数据栈和辅助栈一定会增加元素        data.add(x);        if (helper.isEmpty() || helper.peek() >= x) {            helper.add(x);        } else {            helper.add(helper.peek());        }    }    public void pop() {        // 两个栈都得 pop        if (!data.isEmpty()) {            helper.pop();            data.pop();        }    }    public int top() {        if(!data.isEmpty()){            return data.peek();        }        throw new RuntimeException("栈中元素为空，此操作非法");    }    public int getMin() {        if(!helper.isEmpty()){            return helper.peek();        }        throw new RuntimeException("栈中元素为空，此操作非法");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(1)$，“出栈”、“入栈”、“查看栈顶元素”的操作不论数据规模多大，都只是有限个步骤，因此时间复杂度是：$O(1)$。</li><li>空间复杂度：$O(N)$，这里 $N$ 是读出的数据的个数。</li></ul><h3 id="方法二：辅助栈和数据栈不同步"><a href="#方法二：辅助栈和数据栈不同步" class="headerlink" title="方法二：辅助栈和数据栈不同步"></a>方法二：辅助栈和数据栈不同步</h3><p><strong>参考代码 2</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class MinStack:    # 辅助栈和数据栈不同步    # 关键 1：辅助栈的元素空的时候，必须放入新进来的数    # 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）    # 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即"出栈保持同步"就可以了    def __init__(self):        # 数据栈        self.data = []        # 辅助栈        self.helper = []    def push(self, x):        self.data.append(x)        # 关键 1 和关键 2        if len(self.helper) == 0 or x <= self.helper[-1]:            self.helper.append(x)    def pop(self):        # 关键 3：【注意】不论怎么样，数据栈都要 pop 出元素        top = self.data.pop()        if self.helper and top == self.helper[-1]:            self.helper.pop()        return top    def top(self):        if self.data:            return self.data[-1]    def getMin(self):        if self.helper:            return self.helper[-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Stack;public class MinStack {    // 数据栈    private Stack<Integer> data;    // 辅助栈    private Stack<Integer> helper;    /**     * initialize your data structure here.     */    public MinStack() {        data = new Stack<>();        helper = new Stack<>();    }    // 思路 2：辅助栈和数据栈不同步    // 关键 1：辅助栈的元素空的时候，必须放入新进来的数    // 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）    // 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即"出栈保持同步"就可以了    public void push(int x) {        // 辅助栈在必要的时候才增加        data.add(x);        // 关键 1 和 关键 2        if (helper.isEmpty() || helper.peek() >= x) {            helper.add(x);        }    }    public void pop() {        // 关键 3：data 一定得 pop()        if (!data.isEmpty()) {            // 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了 int，因此下面的比较可以使用 "==" 运算符            // 参考资料：https://www.cnblogs.com/GuoYaxiang/p/6931264.html            // 如果把 top 变量声明成 Integer 类型，下面的比较就得使用 equals 方法            int top = data.pop();            if(top == helper.peek()){                helper.pop();            }        }    }    public int top() {        if(!data.isEmpty()){            return data.peek();        }        throw new RuntimeException("栈中元素为空，此操作非法");    }    public int getMin() {        if(!helper.isEmpty()){            return helper.peek();        }        throw new RuntimeException("栈中元素为空，此操作非法");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(1)$，“出栈”、“入栈”、“查看栈顶元素”的操作不论数据规模多大，都只有有限个步骤，因此时间复杂度是：$O(1)$。</li><li>空间复杂度：$O(N)$，这里 $N$ 是读出的数据的个数。</li></ul><Vssue title="min-stack"/>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 150 题： 逆波兰表达式求值</title>
      <link href="/leetcode-algo/2017/09/09/leetcode-algo/0150-evaluate-reverse-polish-notation/"/>
      <url>/leetcode-algo/2017/09/09/leetcode-algo/0150-evaluate-reverse-polish-notation/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-150-题：-逆波兰表达式求值"><a href="#「力扣」第-150-题：-逆波兰表达式求值" class="headerlink" title="「力扣」第 150 题： 逆波兰表达式求值"></a>「力扣」第 150 题： 逆波兰表达式求值</h2><p>传送门：<a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a>。</p><blockquote><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6</code></pre><p><strong>示例 3：</strong></p><pre><code>输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释:   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tokens<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String token <span class="token operator">=</span> tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            String pattern <span class="token operator">=</span> <span class="token string">"-?[0-9]+|[\\+\\-\\*/]"</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>token<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"非法的表达式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"-?[0-9]+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"[\\+\\-\\*/]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"加减乘除"</span> <span class="token operator">+</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> num1 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> num2 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">switch</span> <span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">case</span> <span class="token string">"+"</span><span class="token operator">:</span>                            result <span class="token operator">=</span> num2 <span class="token operator">+</span>num1<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">case</span> <span class="token string">"-"</span><span class="token operator">:</span>                            result <span class="token operator">=</span> num2 <span class="token operator">-</span>num1<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">case</span> <span class="token string">"*"</span><span class="token operator">:</span>                            result <span class="token operator">=</span> num2 <span class="token operator">*</span>num1<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">case</span> <span class="token string">"/"</span><span class="token operator">:</span>                            result <span class="token operator">=</span> num2 <span class="token operator">/</span>num1<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> tokens <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"-4"</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">evalRPN</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是有问题的：Time Limit Exceeded 。然后我把上面的两个 System.out.println() 语句删除就 A 过了，好神奇，所以做题还是要规范啊。</p><h3 id="LeetCode-第-150-题：-逆波兰表达式求值"><a href="#LeetCode-第-150-题：-逆波兰表达式求值" class="headerlink" title="LeetCode 第 150 题： 逆波兰表达式求值"></a>LeetCode 第 150 题： 逆波兰表达式求值</h3><p>逆波兰表达式求值。运算符放在两个数后面进行运算的表达式。</p><p>我的解答：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tokens<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String token <span class="token operator">=</span> tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            String pattern <span class="token operator">=</span> <span class="token string">"-?[0-9]+|[\\+\\-\\*/]"</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>token<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"非法的表达式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"-?[0-9]+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>token<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"[\\+\\-\\*/]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"加减乘除"</span> <span class="token operator">+</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> num1 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> num2 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">switch</span> <span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">case</span> <span class="token string">"+"</span><span class="token operator">:</span>                            result <span class="token operator">=</span> num2 <span class="token operator">+</span>num1<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">case</span> <span class="token string">"-"</span><span class="token operator">:</span>                            result <span class="token operator">=</span> num2 <span class="token operator">-</span>num1<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">case</span> <span class="token string">"*"</span><span class="token operator">:</span>                            result <span class="token operator">=</span> num2 <span class="token operator">*</span>num1<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token keyword">case</span> <span class="token string">"/"</span><span class="token operator">:</span>                            result <span class="token operator">=</span> num2 <span class="token operator">/</span>num1<span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> tokens <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"-4"</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">evalRPN</span><span class="token punctuation">(</span>tokens<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是有问题的：Time Limit Exceeded 。然后我把上面的两个 System.out.println() 语句删除就 A 过了，好神奇，所以做题还是要规范啊。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 145 题：二叉树的后序遍历</title>
      <link href="/leetcode-algo/2017/09/08/leetcode-algo/0145-binary-tree-postorder-traversal/"/>
      <url>/leetcode-algo/2017/09/08/leetcode-algo/0145-binary-tree-postorder-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-145-题：二叉树的后序遍历"><a href="#「力扣」第-145-题：二叉树的后序遍历" class="headerlink" title="「力扣」第 145 题：二叉树的后序遍历"></a>「力扣」第 145 题：二叉树的后序遍历</h2><p>传送门：英文网址：<a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">145. Binary Tree Postorder Traversal</a> ，中文网址：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a> 。</p><blockquote><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的<strong>二叉搜索树</strong>。</p><p><strong>示例:</strong></p><pre><code>输入: 3输出:[[1,null,3,2],[3,2,null,1],[3,1,null,null,2],[2,1,3],[1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树：1         3     3      2      1 \       /     /      / \      \  3     2     1      1   3      2 /     /       \                 \2     1         2                 3</code></pre></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for a binary tree node.</span><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            command<span class="token punctuation">,</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> command <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 后序遍历：先左右子树，再自己</span>                <span class="token comment" spellcheck="true"># 入栈顺序：自己、右子树、左子树</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的过程更好地体现了递归过程中系统栈的作用，按照这种方式，所有的递归的代码都可以改造成非递归的代码。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 144 题：二叉树的前序遍历</title>
      <link href="/leetcode-algo/2017/09/07/leetcode-algo/0144-binary-tree-preorder-traversal/"/>
      <url>/leetcode-algo/2017/09/07/leetcode-algo/0144-binary-tree-preorder-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-144-题：二叉树的前序遍历"><a href="#「力扣」第-144-题：二叉树的前序遍历" class="headerlink" title="「力扣」第 144 题：二叉树的前序遍历"></a>「力扣」第 144 题：二叉树的前序遍历</h2><p>传送门：英文网址：<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal</a> ，中文网址：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a> 。</p><blockquote><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p><strong>示例:</strong></p><pre><code>输入: [1,null,2,3]  1\2/3 输出: [1,2,3]</code></pre><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><p>递归的写法。下面这种写法是错的：这是我想当然，轻视问题而写出的错误程序。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 使用递归的方式实现二叉树的前序遍历 * * @param root * @return */</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为这里要求返回一个数组，而不是在遍历的时候打印这个节点的值，所以如果要使用递归来解决问题，应该在这个方法之外声明一个成员变量，作为返回值；并且另外声明一个递归函数来完成递归的任务，正确的代码如下：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution3</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 使用递归的方式实现二叉树的前序遍历     *     * @param root     * @return     */</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：在入栈的时候，就可以判断是不是空，只将非空结点入栈。顺序问题：如果我们期望代码执行的顺序是 1 2 3 ， 那么，我们应该以 3 2 1 的方式将代码入栈。即顺序执行 a b c 这件事情，须要往栈里依次推入 c b a</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 掌握前序遍历，使用栈的写法</span><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None<span class="token comment" spellcheck="true"># 教科书上的前序遍历非递归写法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type root: TreeNode        :rtype: List[int]        """</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 前序遍历：先自己，再左孩子，右孩子</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们借助“栈”完成了二叉树的非递归前序遍历，其实借助这种思路，即“模拟系统栈”，可以完成二叉树的 3 种遍历。</p><p>Python 代码2：“模拟系统栈”实现二叉树的“前序遍历”。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            command<span class="token punctuation">,</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> command <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：非递归的写法，使用模拟的系统栈，写出一个非递归的程序</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">enum</span> UseType <span class="token punctuation">{</span>    RECURSION<span class="token punctuation">,</span> ADD<span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 我们自定义的 Command 类 */</span><span class="token keyword">class</span> <span class="token class-name">MyCommand</span> <span class="token punctuation">{</span>    UseType useType<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是对这个节点进行操作，还是递归调用这个节点</span>    TreeNode treeNode<span class="token punctuation">;</span>    <span class="token function">MyCommand</span><span class="token punctuation">(</span>UseType useType<span class="token punctuation">,</span> TreeNode treeNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>useType <span class="token operator">=</span> useType<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>treeNode <span class="token operator">=</span> treeNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution4</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 非递归就是要顺序执行，所以不用自己声明一个递归函数来完成     *     * @param root     * @return     */</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>MyCommand<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCommand</span><span class="token punctuation">(</span>UseType<span class="token punctuation">.</span>RECURSION<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            MyCommand currentCommand <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>UseType<span class="token punctuation">.</span>ADD <span class="token operator">==</span> currentCommand<span class="token punctuation">.</span>useType<span class="token punctuation">)</span> <span class="token punctuation">{</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentCommand<span class="token punctuation">.</span>treeNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">assert</span> UseType<span class="token punctuation">.</span>RECURSION <span class="token operator">==</span> currentCommand<span class="token punctuation">.</span>useType<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模拟系统栈的作用，注意，应该倒过来写</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>currentCommand<span class="token punctuation">.</span>treeNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCommand</span><span class="token punctuation">(</span>UseType<span class="token punctuation">.</span>RECURSION<span class="token punctuation">,</span> currentCommand<span class="token punctuation">.</span>treeNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>currentCommand<span class="token punctuation">.</span>treeNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCommand</span><span class="token punctuation">(</span>UseType<span class="token punctuation">.</span>RECURSION<span class="token punctuation">,</span> currentCommand<span class="token punctuation">.</span>treeNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCommand</span><span class="token punctuation">(</span>UseType<span class="token punctuation">.</span>ADD<span class="token punctuation">,</span> currentCommand<span class="token punctuation">.</span>treeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 94 题：二叉树的中序遍历</title>
      <link href="/leetcode-algo/2017/09/06/leetcode-algo/0094-binary-tree-inorder-traversal/"/>
      <url>/leetcode-algo/2017/09/06/leetcode-algo/0094-binary-tree-inorder-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-94-题：二叉树的中序遍历"><a href="#「力扣」第-94-题：二叉树的中序遍历" class="headerlink" title="「力扣」第 94 题：二叉树的中序遍历"></a>「力扣」第 94 题：二叉树的中序遍历</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/mo-ni-xi-tong-zhan-wan-cheng-fei-di-gui-zhong-xu-b/" target="_blank" rel="noopener">模拟系统栈完成非递归中序遍历，同理可以完成非递归的前序遍历和后序遍历（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a>。</p><blockquote><p>给定一个二叉树，返回它的中序 遍历。</p><p>示例:</p><p>输入: [1,null,2,3]<br>  1<br>   <br>    2<br>   /<br>  3</p><p>输出: [1,3,2]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h3 id="模拟系统栈完成非递归中序遍历，同理可以完成非递归的前序遍历和后序遍历（Python-代码、Java-代码）"><a href="#模拟系统栈完成非递归中序遍历，同理可以完成非递归的前序遍历和后序遍历（Python-代码、Java-代码）" class="headerlink" title="模拟系统栈完成非递归中序遍历，同理可以完成非递归的前序遍历和后序遍历（Python 代码、Java 代码）"></a>模拟系统栈完成非递归中序遍历，同理可以完成非递归的前序遍历和后序遍历（Python 代码、Java 代码）</h3><h3 id="方法：模拟系统栈"><a href="#方法：模拟系统栈" class="headerlink" title="方法：模拟系统栈"></a>方法：模拟系统栈</h3><p>模拟系统栈的方法其实并不难理解，就是在栈中放入结点的同时，<strong>同时传入一个指令，这个指令可以有 2 个含义</strong>：</p><p>1、递归执行（就是继续放入栈里）；</p><p>2、马上执行。</p><p><strong>模拟系统栈的注意事项</strong>：因为栈是先进后出的，当递归执行的时候，代码编写的顺序应该是相应遍历种类的倒序（具体可以参考下面的代码）。</p><p><strong>模拟系统栈的好处</strong>：稍微改动一下代码，就可以完成非递归的前序遍历和后序遍历。</p><p><strong>参考代码</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    def inorderTraversal(self, root: TreeNode) -> List[int]:        if not root:            return []        # 1 表示递归处理        stack = [(1, root)]        res = []        while stack:            command, node = stack.pop()            if command == 0:                # 0 表示当前马上执行将结点的值添加到结果集中                res.append(node.val)            else:                # 关键在这里：因为是模拟系统栈，应该把中序遍历的顺序倒过来写                # 调整一下顺序就可以完成前序遍历和后序遍历                if node.right:                    stack.append((1, node.right))                stack.append((0, node))                if node.left:                    stack.append((1, node.left))        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.ArrayList;import java.util.List;import java.util.Stack;class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) {        val = x;    }}public class Solution {    private enum Action {        // GO 表示递归处理        // ADDTORESULT 表示当前马上执行将结点的值添加到结果集中        GO, ADDTORESULT    }    private class Command {        private Action action;        private TreeNode node;        public Command(Action action, TreeNode node) {            this.action = action;            this.node = node;        }    }    public List<Integer> inorderTraversal(TreeNode root) {        List<Integer> res = new ArrayList<>();        if (root == null) {            return res;        }        Stack<Command> stack = new Stack<>();        stack.add(new Command(Action.GO, root));        while (!stack.isEmpty()) {            Command command = stack.pop();            if (command.action == Action.ADDTORESULT) {                res.add(command.node.val);            } else {                assert command.action == Action.GO;                // 关键在这里：因为是模拟系统栈，应该把中序遍历的顺序倒过来写                // 调整一下顺序就可以完成前序遍历和后序遍历                if (command.node.right != null) {                    stack.add(new Command(Action.GO, command.node.right));                }                stack.add(new Command(Action.ADDTORESULT, command.node));                if (command.node.left != null) {                    stack.add(new Command(Action.GO, command.node.left));                }            }        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="LeetCode-第-94-题：94-二叉树的中序遍历"><a href="#LeetCode-第-94-题：94-二叉树的中序遍历" class="headerlink" title="LeetCode 第 94 题：94. 二叉树的中序遍历"></a>LeetCode 第 94 题：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal</a> ，中文网址：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a> 。</p><blockquote><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><pre><code>输入: [1,null,2,3]1 \  2 /3输出: [1,3,2]</code></pre><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            command<span class="token punctuation">,</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> command <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 71 题：简化路径</title>
      <link href="/leetcode-algo/2017/09/05/leetcode-algo/0071-simplify-path/"/>
      <url>/leetcode-algo/2017/09/05/leetcode-algo/0071-simplify-path/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-71-题：简化路径"><a href="#「力扣」第-71-题：简化路径" class="headerlink" title="「力扣」第 71 题：简化路径"></a>「力扣」第 71 题：简化路径</h2><p>传送门：<a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">71. 简化路径</a>。</p><blockquote><p> 以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p><p> 在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p><p> 请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code>结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p><p> <strong>示例 1：</strong></p><pre><code> 输入：&quot;/home/&quot; 输出：&quot;/home&quot; 解释：注意，最后一个目录名后面没有斜杠。</code></pre><p> <strong>示例 2：</strong></p><pre><code> 输入：&quot;/../&quot; 输出：&quot;/&quot; 解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</code></pre><p> <strong>示例 3：</strong></p><pre><code> 输入：&quot;/home//foo/&quot; 输出：&quot;/home/foo&quot; 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</code></pre><p> <strong>示例 4：</strong></p><pre><code> 输入：&quot;/a/./b/../../c/&quot; 输出：&quot;/c&quot;</code></pre><p> <strong>示例 5：</strong></p><pre><code> 输入：&quot;/a/../../b/../c//.//&quot; 输出：&quot;/c&quot;</code></pre><p> <strong>示例 6：</strong></p><pre><code> 输入：&quot;/a//b////c/d//././/..&quot; 输出：&quot;/a/b/c&quot;</code></pre></blockquote><p>参考了如下的文章：<a href="http://blog.csdn.net/u012249528/article/details/46705867" target="_blank" rel="noopener">http://blog.csdn.net/u012249528/article/details/46705867</a></p><p>Java 代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">simplifyPath</span><span class="token punctuation">(</span>String path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String result <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> pathList <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pathList<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>String<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String p <span class="token operator">:</span> pathList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">"."</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 是正常的路径字符串的时候，入栈</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 现在考虑输出字符串</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token string">"/"</span> <span class="token operator">+</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String path1 <span class="token operator">=</span> <span class="token string">"/home/"</span><span class="token punctuation">;</span>        String result1 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">simplifyPath</span><span class="token punctuation">(</span>path1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>        String path2 <span class="token operator">=</span> <span class="token string">"/a/./b/../../c/"</span><span class="token punctuation">;</span>        String result2 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">simplifyPath</span><span class="token punctuation">(</span>path2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>        String path3 <span class="token operator">=</span> <span class="token string">"/.."</span><span class="token punctuation">;</span>        String result3 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">simplifyPath</span><span class="token punctuation">(</span>path3<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result3<span class="token punctuation">)</span><span class="token punctuation">;</span>        String path4 <span class="token operator">=</span> <span class="token string">"/.."</span><span class="token punctuation">;</span>        String result4 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">simplifyPath</span><span class="token punctuation">(</span>path4<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result4<span class="token punctuation">)</span><span class="token punctuation">;</span>        String path5 <span class="token operator">=</span> <span class="token string">"/abc/def/."</span><span class="token punctuation">;</span>        String result5 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">simplifyPath</span><span class="token punctuation">(</span>path5<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="LeetCode-第-71-题：Simplify-Path"><a href="#LeetCode-第-71-题：Simplify-Path" class="headerlink" title="LeetCode 第 71 题：Simplify Path"></a>LeetCode 第 71 题：Simplify Path</h3><p>传送门：<a href="https://leetcode.com/problems/simplify-path/description/。" target="_blank" rel="noopener">https://leetcode.com/problems/simplify-path/description/。</a></p><p>第 2 种情况下，要求我们的程序能够有一定的容错处理的能力。</p><p>我的解答参考了如下的文章：<br><a href="http://blog.csdn.net/u012249528/article/details/46705867" target="_blank" rel="noopener">http://blog.csdn.net/u012249528/article/details/46705867</a></p><p>Java 代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">simplifyPath</span><span class="token punctuation">(</span>String path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String result <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> pathList <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pathList<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>String<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String p <span class="token operator">:</span> pathList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">"."</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 是正常的路径字符串的时候，入栈</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 现在考虑输出字符串</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token string">"/"</span> <span class="token operator">+</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String path1 <span class="token operator">=</span> <span class="token string">"/home/"</span><span class="token punctuation">;</span>        String result1 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">simplifyPath</span><span class="token punctuation">(</span>path1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>        String path2 <span class="token operator">=</span> <span class="token string">"/a/./b/../../c/"</span><span class="token punctuation">;</span>        String result2 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">simplifyPath</span><span class="token punctuation">(</span>path2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>        String path3 <span class="token operator">=</span> <span class="token string">"/.."</span><span class="token punctuation">;</span>        String result3 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">simplifyPath</span><span class="token punctuation">(</span>path3<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result3<span class="token punctuation">)</span><span class="token punctuation">;</span>        String path4 <span class="token operator">=</span> <span class="token string">"/.."</span><span class="token punctuation">;</span>        String result4 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">simplifyPath</span><span class="token punctuation">(</span>path4<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result4<span class="token punctuation">)</span><span class="token punctuation">;</span>        String path5 <span class="token operator">=</span> <span class="token string">"/abc/def/."</span><span class="token punctuation">;</span>        String result5 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">simplifyPath</span><span class="token punctuation">(</span>path5<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 20 题：有效的括号</title>
      <link href="/leetcode-algo/2017/09/04/leetcode-algo/0020-valid-parentheses/"/>
      <url>/leetcode-algo/2017/09/04/leetcode-algo/0020-valid-parentheses/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-20-题：有效的括号"><a href="#「力扣」第-20-题：有效的括号" class="headerlink" title="「力扣」第 20 题：有效的括号"></a>「力扣」第 20 题：有效的括号</h2><p> 传送门：英文网址：<a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">20. Valid Parentheses</a> ，中文网址：<a href="https://leetcode-cn.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">20. 有效的括号</a> 。</p><blockquote><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;()&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;()[]{}&quot;输出: true</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;(]&quot;输出: false</code></pre><p><strong>示例 4:</strong></p><pre><code>输入: &quot;([)]&quot;输出: false</code></pre><p><strong>示例 5:</strong></p><pre><code>输入: &quot;{[]}&quot;输出: true</code></pre></blockquote><p>分析：典型应用，检查括号匹配，是文本编辑器常见的功能。</p><p>注意空字符串可被认为是有效字符串。</p><p>思路：问题本身非常容易。判断字符串中的括号匹配是否合法。遍历一遍这个字符串，使用一个 Stack 作为辅助空间。</p><p>一旦遇到左方向的符号，就把这个符号推入栈。</p><p>一旦遇到右方向的符号，将栈的栈顶元素出栈，就须要判断是否对应匹配。</p><p>Stack 中只是存放左方向的符号：“{”、“[”、“(”，在整个方法返回之前，一定要判断一下 Stack 是否为空。因为 Stack 有可能出现全是左括号的情况。即：在栈中还有元素的情况下，待检测的字符串一定是不符合题意的。</p><p>我的解答（看起来有些繁琐）：</p><p>下面我按照老师的解法，写了一个不是优化了很多的解法：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> isValid <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Character<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'{'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'('</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'}'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">')'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 出栈之前，应该先检查一下栈中是否还有元素</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> isValid<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                Character popElement <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Character match <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'}'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    match <span class="token operator">=</span> <span class="token string">'{'</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    match <span class="token operator">=</span> <span class="token string">'['</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">')'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    match <span class="token operator">=</span> <span class="token string">'('</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>popElement <span class="token operator">!=</span> match<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> isValid<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            isValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> isValid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token string">"8{90[s(d)f]44}33"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：最后的这一步：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    isValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>很容易忽略，请留意。</p><p>学到栈的时候，也学习了一些经典的使用栈解决问题，我们要思考一下为什么使用栈？<br>使用栈的原因：在一个嵌套的关系中，通过栈顶元素来获得最近的那个我们须要处理的元素。</p><p>栈顶元素反映了在嵌套的层次关系中，最近的需要匹配的元素。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 20. 有效的括号</span><span class="token comment" spellcheck="true"># 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: bool        """</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"()"</span><span class="token punctuation">,</span> <span class="token string">"[]"</span><span class="token punctuation">,</span> <span class="token string">"{}"</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">and</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> d<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>stack<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「栈」专题 3：使用自己编写的模拟系统栈，写出非递归的程序</title>
      <link href="/leetcode-algo/2017/09/03/leetcode-solution/stack-3/"/>
      <url>/leetcode-algo/2017/09/03/leetcode-solution/stack-3/</url>
      
        <content type="html"><![CDATA[<h2 id="「栈」专题-3：使用自己编写的模拟系统栈，写出非递归的程序"><a href="#「栈」专题-3：使用自己编写的模拟系统栈，写出非递归的程序" class="headerlink" title="「栈」专题 3：使用自己编写的模拟系统栈，写出非递归的程序"></a>「栈」专题 3：使用自己编写的模拟系统栈，写出非递归的程序</h2><h2 id="二叉树的三种非递归遍历"><a href="#二叉树的三种非递归遍历" class="headerlink" title="二叉树的三种非递归遍历"></a>二叉树的三种非递归遍历</h2><p>栈和递归密不可分：分别可以解决二叉树的前序遍历、中序遍历、后序遍历</p><h3 id="LeetCode-第144-题：前序遍历"><a href="#LeetCode-第144-题：前序遍历" class="headerlink" title="LeetCode 第144 题：前序遍历"></a>LeetCode 第144 题：前序遍历</h3><h3 id="LeetCode-第-94-题：中序遍历"><a href="#LeetCode-第-94-题：中序遍历" class="headerlink" title="LeetCode 第 94 题：中序遍历"></a>LeetCode 第 94 题：中序遍历</h3><h3 id="LeetCode-第-145-题：后序遍历"><a href="#LeetCode-第-145-题：后序遍历" class="headerlink" title="LeetCode 第 145 题：后序遍历"></a>LeetCode 第 145 题：后序遍历</h3><h3 id="LeetCode-第-145-题：-后序遍历二叉树"><a href="#LeetCode-第-145-题：-后序遍历二叉树" class="headerlink" title="LeetCode 第 145 题： 后序遍历二叉树"></a>LeetCode 第 145 题： 后序遍历二叉树</h3><p>递归写法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 递归的方式后续遍历二叉树     * @param root     * @return     */</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">postorder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非递归写法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">enum</span> UseType <span class="token punctuation">{</span>    RECURSION<span class="token punctuation">,</span>    ADD<span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    UseType useType<span class="token punctuation">;</span>    TreeNode treeNode<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Command</span><span class="token punctuation">(</span>UseType useType<span class="token punctuation">,</span> TreeNode treeNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>useType <span class="token operator">=</span> useType<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>treeNode <span class="token operator">=</span> treeNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result  <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>Command<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Command</span><span class="token punctuation">(</span>UseType<span class="token punctuation">.</span>RECURSION<span class="token punctuation">,</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Command command <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>UseType<span class="token punctuation">.</span>ADD <span class="token operator">==</span> command<span class="token punctuation">.</span>useType<span class="token punctuation">)</span><span class="token punctuation">{</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span>treeNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">assert</span> UseType<span class="token punctuation">.</span>RECURSION <span class="token operator">==</span> command<span class="token punctuation">.</span>useType<span class="token punctuation">;</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Command</span><span class="token punctuation">(</span>UseType<span class="token punctuation">.</span>ADD<span class="token punctuation">,</span>command<span class="token punctuation">.</span>treeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span>treeNode<span class="token punctuation">.</span>right<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Command</span><span class="token punctuation">(</span>UseType<span class="token punctuation">.</span>RECURSION<span class="token punctuation">,</span>command<span class="token punctuation">.</span>treeNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span>treeNode<span class="token punctuation">.</span>left<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Command</span><span class="token punctuation">(</span>UseType<span class="token punctuation">.</span>RECURSION<span class="token punctuation">,</span>command<span class="token punctuation">.</span>treeNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LeetCode-第-341-题：类的设计问题，挺有意思的"><a href="#LeetCode-第-341-题：类的设计问题，挺有意思的" class="headerlink" title="LeetCode 第 341 题：类的设计问题，挺有意思的"></a>LeetCode 第 341 题：类的设计问题，挺有意思的</h3><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><h3 id="LeetCode-第-102-题：层序遍历"><a href="#LeetCode-第-102-题：层序遍历" class="headerlink" title="LeetCode 第 102 题：层序遍历"></a>LeetCode 第 102 题：层序遍历</h3><h3 id="LeetCode-第-107-题：自底向上的层序遍历"><a href="#LeetCode-第-107-题：自底向上的层序遍历" class="headerlink" title="LeetCode 第 107 题：自底向上的层序遍历"></a>LeetCode 第 107 题：自底向上的层序遍历</h3><h3 id="LeetCode-第-103-题：二叉树的锯齿形层次遍历"><a href="#LeetCode-第-103-题：二叉树的锯齿形层次遍历" class="headerlink" title="LeetCode 第 103 题：二叉树的锯齿形层次遍历"></a>LeetCode 第 103 题：二叉树的锯齿形层次遍历</h3><h3 id="LeetCode-第-199-题：二叉树的右视图"><a href="#LeetCode-第-199-题：二叉树的右视图" class="headerlink" title="LeetCode 第 199 题：二叉树的右视图"></a>LeetCode 第 199 题：二叉树的右视图</h3><p>分析：二叉树从右边看，得到的一个数组。</p><h3 id="（一题多解）LeetCode-第-279-题：求最小的完全平方数之和"><a href="#（一题多解）LeetCode-第-279-题：求最小的完全平方数之和" class="headerlink" title="（一题多解）LeetCode 第 279 题：求最小的完全平方数之和"></a>（一题多解）LeetCode 第 279 题：求最小的完全平方数之和</h3><p>思路1：广度优先遍历、层序遍历</p><p>思路2：动态规划</p><h3 id="（难）LeetCode-第-127-题："><a href="#（难）LeetCode-第-127-题：" class="headerlink" title="（难）LeetCode 第 127 题："></a>（难）LeetCode 第 127 题：</h3><p>要求：给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。</p><h3 id="（难，据说经常考，要注意）LeetCode-第-126-题："><a href="#（难，据说经常考，要注意）LeetCode-第-126-题：" class="headerlink" title="（难，据说经常考，要注意）LeetCode 第 126 题："></a>（难，据说经常考，要注意）LeetCode 第 126 题：</h3><h3 id="LeetCode-第-347-题：前-K-个高频元素"><a href="#LeetCode-第-347-题：前-K-个高频元素" class="headerlink" title="LeetCode 第 347 题：前 K 个高频元素"></a>LeetCode 第 347 题：前 K 个高频元素</h3><p>思路：不能用排序，那就用优先队列。</p><h3 id="LeetCode-第-23-题：合并-K-个排序链表"><a href="#LeetCode-第-23-题：合并-K-个排序链表" class="headerlink" title="LeetCode 第 23 题：合并 K 个排序链表"></a>LeetCode 第 23 题：合并 K 个排序链表</h3><p>典型问题，一定要掌握。（1、优先队列；2、<strong>分治归并</strong>）</p><h3 id="LeetCode-第-225-题：用队列实现栈"><a href="#LeetCode-第-225-题：用队列实现栈" class="headerlink" title="LeetCode 第 225 题：用队列实现栈"></a>LeetCode 第 225 题：用队列实现栈</h3><p>思想：负负得正。</p><p>方法1：干脆就 <code>push</code> 的时候麻烦一点，出栈和查看栈顶元素就很简单了；</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">MyStack</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 用一个栈实现队列，其实就是找规律</span>    <span class="token comment" spellcheck="true"># push 的时候麻烦</span>    <span class="token comment" spellcheck="true"># top 和 pop 的时候简单</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Initialize your data structure here.        """</span>        self<span class="token punctuation">.</span>queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Push element x onto stack.        :type x: int        :rtype: void        """</span>        self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Removes the element on top of the stack and returns that element.        :rtype: int        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Get the top element.        :rtype: int        """</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Returns whether the stack is empty.        :rtype: bool        """</span>        <span class="token keyword">return</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>queue<span class="token comment" spellcheck="true"># Your MyStack object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MyStack()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># param_2 = obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.top()</span><span class="token comment" spellcheck="true"># param_4 = obj.empty()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法2：用两个队列实现栈</p><h3 id="LeetCode-第-232-题：用两个栈（stack）实现队列（queue）"><a href="#LeetCode-第-232-题：用两个栈（stack）实现队列（queue）" class="headerlink" title="LeetCode 第 232 题：用两个栈（stack）实现队列（queue）"></a>LeetCode 第 232 题：用两个栈（stack）实现队列（queue）</h3><p>设计辅助函数，出队列都从 stack2 出，进队列（push）都从 stack1 进。</p><p>自己在纸上画一画就很清楚了。只要涉及出队列和 peek 队列的，都执行一次辅助函数的操作。</p><p><strong>要特别注意的地方：只有当 stack2 为空的时候，才可以一次性把 stack1 倒到 stack2，然后再从 stack 栈顶拿元素。</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 关键：stack1 是主栈</span>    <span class="token comment" spellcheck="true"># stack2 永远是辅助</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 永远只向 stack1 加入元素</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__shift_stacks</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 这里不要忘记，只有当 stack2 为空的时候，才可以一次性把 stack1 倒到 stack2  </span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">:</span>            <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 只要是 pop 或者 peek 的时候，表示要从队列首拿出元素</span>        <span class="token comment" spellcheck="true"># 此时就要把 stack1 的元素全部倒入 stack2 ，然后拿出 stack2 的栈顶元素</span>        self<span class="token punctuation">.</span>__shift_stacks<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__shift_stacks<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 两个栈没有元素复制，只有二者都空的时候，才表示队列为空</span>        <span class="token keyword">return</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>stack1 <span class="token operator">and</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>stack2<span class="token comment" spellcheck="true"># Your MyQueue object will be instantiated and called as such:</span><span class="token comment" spellcheck="true"># obj = MyQueue()</span><span class="token comment" spellcheck="true"># obj.push(x)</span><span class="token comment" spellcheck="true"># param_2 = obj.pop()</span><span class="token comment" spellcheck="true"># param_3 = obj.peek()</span><span class="token comment" spellcheck="true"># param_4 = obj.empty()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LeetCode-第-341-题：Flatten-Nested-List-Iterator"><a href="#LeetCode-第-341-题：Flatten-Nested-List-Iterator" class="headerlink" title="LeetCode 第 341  题：Flatten Nested List Iterator"></a>LeetCode 第 341  题：Flatten Nested List Iterator</h3><p>传送门：<a href="https://leetcode.com/problems/flatten-nested-list-iterator/description/" target="_blank" rel="noopener">https://leetcode.com/problems/flatten-nested-list-iterator/description/</a></p><p>参考解答： </p><p><a href="http://blog.csdn.net/jmspan/article/details/51285573" target="_blank" rel="noopener">http://blog.csdn.net/jmspan/article/details/51285573</a></p><p><a href="http://blog.csdn.net/l294265421/article/details/51203616" target="_blank" rel="noopener">http://blog.csdn.net/l294265421/article/details/51203616</a></p><p>思路: 题目要求用迭代器实现, 所以不能预先把值求出来. 可以利用栈来实现, 也就是用两个栈一个保存当前数组的元素指针, 另一个保存这个数组的结束迭代器. 用栈的目的是可以模拟递归, 也就是可以层层嵌套, 最深的总是在最上面, 当遍历完深层的数组还可以回来继续遍历之前的层. </p><p><a href="https://segmentfault.com/a/1190000008925686&gt;" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008925686&gt;</a></p><p><a href="https://segmentfault.com/a/1190000008925686" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008925686</a></p><p><a href="https://segmentfault.com/a/1190000008925686" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008925686</a></p><p>(这篇文章里面有很多扩展阅读，例如：leetcode 315 Count of Smaller Numbers After Self 以及 BST总结。) </p><p>这道题是拉平层层嵌套的链表，题目难度为Medium。 </p><p>这种嵌套的问题很自然想到要用栈来处理，由于要按照先后次序输出，所以要将链表从尾部开始依次进栈，然后判断栈顶元素是数字还是链表，如果是链表，将该链表出栈之后按同样的方法将它自身的元素从尾部开始进栈，直到栈顶元素是数字即可出栈输出了。这里将主要操作放在了hasNext()函数中，没有在next()函数中处理是为了避免空链表干扰hasNext()函数的判断。具体代码： </p><p>解法一： </p><p>参考：<a href="http://blog.csdn.net/zdavb/article/details/51553476" target="_blank" rel="noopener">http://blog.csdn.net/zdavb/article/details/51553476</a> </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">NestedInteger</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Integer <span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">NestedIntegerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">NestedInteger</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isInteger <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer intData<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isInteger<span class="token punctuation">,</span> Integer intData<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>isInteger <span class="token operator">=</span> isInteger<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>intData <span class="token operator">=</span> intData<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isInteger<span class="token punctuation">,</span> NestedInteger<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> nestedIntegers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>isInteger <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>NestedInteger nestedInteger <span class="token operator">:</span> nestedIntegers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>nestedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nestedInteger<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> isInteger<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> intData<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nestedList<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NestedIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把下一个的值放在这个 data 变量里面</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NestedIterator</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nestedList <span class="token operator">=</span> nestedList<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>nestedList <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> nestedList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            NestedInteger tmpInt <span class="token operator">=</span> nestedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpInt<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                data <span class="token operator">=</span> tmpInt<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                nestedList<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> tmpInt<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试用例一： </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 测试用例 [1,[4,[6,5]]]     * @param args     */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    NestedInteger six <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger five <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger six_1_five <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> six<span class="token punctuation">,</span> five<span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger four <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger four_2_six_1_five <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> four<span class="token punctuation">,</span> six_1_five<span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger one_3_four_2_six_1_five <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> one<span class="token punctuation">,</span> four_2_six_1_five<span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedIterator nestedIterator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIterator</span><span class="token punctuation">(</span>one_3_four_2_six_1_five<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>nestedIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer next <span class="token operator">=</span> nestedIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d \t"</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解法二：自己根据一的思路，使用 Stack 来完成的 </p><p>心得： </p><p>思考？为什么用栈就可以解决这个问题呢？ </p><p>Java 代码： </p><p>NestedInteger 接口： </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">NestedInteger</span> <span class="token punctuation">{</span>     <span class="token keyword">boolean</span> <span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Integer <span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NestedInteger 接口的实现（LeeCode 此题并不要求，我为了测试添加）： </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">NestedIntegerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">NestedInteger</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> isInteger<span class="token punctuation">;</span>    <span class="token keyword">int</span> intData<span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isInteger<span class="token punctuation">,</span> <span class="token keyword">int</span> intData<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>isInteger <span class="token operator">=</span> isInteger<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>intData <span class="token operator">=</span> intData<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isInteger<span class="token punctuation">,</span> NestedInteger<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> nestedIntegers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>isInteger <span class="token operator">=</span> isInteger<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>NestedInteger nestedInteger <span class="token operator">:</span> nestedIntegers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            nestedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nestedInteger<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> isInteger<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> intData<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nestedList<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NestedIterator 接口的实现（这是 LeetCode 要求我们做的事情）： </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NestedIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NestedIterator</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nestedList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nestedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            NestedInteger top <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>top<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                data <span class="token operator">=</span> top<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList <span class="token operator">=</span> top<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nestedList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nestedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试用例： </p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试用例 [[6,4,5],8,[1,2]] * * @param args */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    NestedInteger six <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger four <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger five <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger six_four_five <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> six<span class="token punctuation">,</span> four<span class="token punctuation">,</span> five<span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger eight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger one_two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> one<span class="token punctuation">,</span>two<span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedInteger six_four_five__eight__one_two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIntegerImpl</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> six_four_five<span class="token punctuation">,</span> eight<span class="token punctuation">,</span>one_two<span class="token punctuation">)</span><span class="token punctuation">;</span>    NestedIterator nestedIterator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NestedIterator</span><span class="token punctuation">(</span>six_four_five__eight__one_two<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>nestedIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer next <span class="token operator">=</span> nestedIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d \t"</span><span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解法三：（同解法二，只不过使用的是双端队列） </p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NestedIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">private</span> Deque<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NestedIterator</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>NestedInteger nestedInteger <span class="token operator">:</span> nestedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            deque<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>nestedInteger<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            NestedInteger top <span class="token operator">=</span> deque<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>top<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> top<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList <span class="token operator">=</span> top<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nestedList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    deque<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>nestedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「栈」专题 2：二叉树的三种非递归实现</title>
      <link href="/leetcode-algo/2017/09/02/leetcode-solution/stack-2/"/>
      <url>/leetcode-algo/2017/09/02/leetcode-solution/stack-2/</url>
      
        <content type="html"><![CDATA[<h2 id="「栈」专题-2：二叉树的三种非递归实现"><a href="#「栈」专题-2：二叉树的三种非递归实现" class="headerlink" title="「栈」专题 2：二叉树的三种非递归实现"></a>「栈」专题 2：二叉树的三种非递归实现</h2><p>对于递归而言，简单来说就是自己调用自己，但是再一次调用自己，又有不一样的地方，具体表现就是参数不同。</p><p>通常我们写递归程序的时候，是不会直接使用栈的。因为操作系统在执行递归程序的时候，就帮助我们使用了栈。我们可以把操作系统为了帮助我们执行递归程序而使用的栈，称作“系统栈”。</p><p>从操作系统的角度来看，实现递归的手段，恰恰是使用了栈。对于栈的熟练掌握，可以加深我们对递归问题的理解。</p><p>之后的若干章节，我们还会多次使用递归。</p><p>递归在算法的学习中是举足轻重的。所以，我们十分有必要学习好栈这种数据结构。</p><p>对于递归的学习，我们使用”二叉树”作为入手点。以二叉树中的算法来理解递归。因为二叉树的定义就是通过递归定义的。</p><p>二叉树的遍历有三种遍历：1、前序遍历；2、中序遍历；3、后序遍历。分别就对应了 LeetCode 第 144 题、第 94 题、第 145 题。</p><p>关于二叉树的遍历分为以下四种：先序遍历、中序遍历、后序遍历、层序遍历。其中先序、中序、后序遍历又分别有递归方式和非递归方式。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「栈」专题 1：栈的使用</title>
      <link href="/leetcode-algo/2017/09/01/leetcode-solution/stack-1/"/>
      <url>/leetcode-algo/2017/09/01/leetcode-solution/stack-1/</url>
      
        <content type="html"><![CDATA[<h2 id="「栈」专题-1：栈的使用"><a href="#「栈」专题-1：栈的使用" class="headerlink" title="「栈」专题 1：栈的使用"></a>「栈」专题 1：栈的使用</h2><p>这一部分，我们开始介绍“栈、队列、优先队列”。栈和队列虽然是简单的数据结构，但是使用这些简单的数据结构所解决的算法问题不一定简单。在这一章里，我们将来探索，和栈与队列相关的算法问题。</p><p>栈和队列的使用，栈和队列是两种基础的数据结构。Stack 这个基础数据结构的特点是：后进先出，这一点是非常重要的。下面请看 LeetCode 第 20 题：</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 7：栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 876 题：链表的中间结点（简单）</title>
      <link href="/leetcode-algo/2017/08/27/leetcode-algo/0876-middle-of-the-linked-list/"/>
      <url>/leetcode-algo/2017/08/27/leetcode-algo/0876-middle-of-the-linked-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-876-题：链表的中间结点（简单）"><a href="#「力扣」第-876-题：链表的中间结点（简单）" class="headerlink" title="「力扣」第 876 题：链表的中间结点（简单）"></a>「力扣」第 876 题：链表的中间结点（简单）</h2><ul><li><p>中文地址：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/；" target="_blank" rel="noopener">https://leetcode-cn.com/problems/middle-of-the-linked-list/；</a></p></li><li><p>题解地址：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/kuai-man-zhi-zhen-zhu-yao-zai-yu-diao-shi-by-liwei/" target="_blank" rel="noopener">快慢指针（Python 代码、Java 代码）</a>。</p></li></ul><blockquote><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：</p><p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.<br>示例 2：</p><p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p><p>提示：</p><p>给定链表的结点数介于 1 和 100 之间。</p></blockquote><h3 id="方法：快慢指针（Python-代码、Java-代码）"><a href="#方法：快慢指针（Python-代码、Java-代码）" class="headerlink" title="方法：快慢指针（Python 代码、Java 代码）"></a>方法：快慢指针（Python 代码、Java 代码）</h3><p>使用快慢指针是求单链表中间结点，以及 <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">倒数第 k 个结点</a> 的常用方法。</p><p>题目要求：如果有两个中间结点，则返回第二个中间结点。此时快指针可以前进的条件是：当前快指针和当前快指针的下一个结点都非空。</p><ul><li>如果题目要求：如果有两个中间结点，则返回第一个中间结点，此时快指针可以前进的条件是：当前快指针的下一个结点和当前快指针的下下一个结点都非空。</li></ul><p>注意体会以上二者的不同之处，其实画一个图就很清楚了。</p><p><img src="https://pic.leetcode-cn.com/2b7a4130111600cf615b5584b3cc7f863d289a9a7d43b90147c79f51f68a5aa6-876-1.png" alt="876-1.png"><br><img src="https://pic.leetcode-cn.com/5c3f88cc6b312b7193a6e071cef93ec5eb3070005af23cad22a11e10ea0aca3e-876-2.png" alt="876-2.png"></p><p><strong>参考代码</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">class ListNode {    int val;    ListNode next;    ListNode(int x) {        val = x;    }}public class Solution {    public ListNode middleNode(ListNode head) {        if (head == null) {            return null;        }        ListNode slow = head;        ListNode fast = head;        while (fast != null && fast.next != null) {            slow = slow.next;            fast = fast.next.next;        }        return slow;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass Solution:    def middleNode(self, head: ListNode) -> ListNode:        if head is None:            return None        slow = head        fast = head        while fast and fast.next:            slow = slow.next            fast = fast.next.next        return slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 460 题：LFU 缓存</title>
      <link href="/leetcode-algo/2017/08/26/leetcode-algo/0460-lfu-cache/"/>
      <url>/leetcode-algo/2017/08/26/leetcode-algo/0460-lfu-cache/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-460-题：LFU-缓存"><a href="#「力扣」第-460-题：LFU-缓存" class="headerlink" title="「力扣」第 460 题：LFU 缓存"></a>「力扣」第 460 题：LFU 缓存</h2><ul><li><a href="https://leetcode-cn.com/problems/lfu-cache" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/lfu-cache/solution/ha-xi-biao-shuang-xiang-lian-biao-java-by-liweiwei/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：get 和 put。</p><p>get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。<br>put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，最近最少使用的键将被去除。</p><p>进阶：<br>你是否可以在 O(1) 时间复杂度内执行两项操作？</p><p>示例：</p><pre><code>LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回 1cache.put(3, 3);    // 去除 key 2cache.get(2);       // 返回 -1 (未找到key 2)cache.get(3);       // 返回 3cache.put(4, 4);    // 去除 key 1cache.get(1);       // 返回 -1 (未找到 key 1)cache.get(3);       // 返回 3cache.get(4);       // 返回 4</code></pre></blockquote><p>题目意思：缓存是有限的，在缓存满的时候，删除哪些元素，就有不同的缓存删除策略。</p><p>说明：如果缓存不限制大小，就没有下面的这两道问题了。即下面这两种策略是在缓存满的情况下，两种不同的缓存删除规则。</p><h3 id="LRU-（Least-Recently-Used）缓存机制（看时间）"><a href="#LRU-（Least-Recently-Used）缓存机制（看时间）" class="headerlink" title="LRU （Least Recently Used）缓存机制（看时间）"></a>LRU （Least Recently Used）缓存机制（看时间）</h3><p>「力扣」第 146 题：<a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></p><ul><li>在缓存满的时候，删除缓存里最久未使用的数据，然后再放入新元素；</li><li>数据的访问时间很重要，<strong>访问时间距离现在越近</strong>，就越不容易被删除；</li></ul><p>就是喜新厌旧，淘汰在缓存里呆的时间最久的元素。在删除元素的时候，只看「时间」这一个维度。</p><h3 id="LFU-（Least-Frequently-Used）缓存机制（看访问次数）"><a href="#LFU-（Least-Frequently-Used）缓存机制（看访问次数）" class="headerlink" title="LFU （Least Frequently Used）缓存机制（看访问次数）"></a>LFU （Least Frequently Used）缓存机制（看访问次数）</h3><ul><li>在缓存满的时候，删除缓存里使用次数最少的元素，然后在缓存中放入新元素；</li><li>数据的访问次数很重要，<strong>访问次数越多</strong>，就越不容易被删除；</li><li>根据题意，「当存在平局（即两个或更多个键具有相同使用频率）时，最近最少使用的键将被去除」，即在「访问次数」相同的情况下，按照时间顺序，先删除在缓存里时间最久的数据。</li></ul><p>说明：本题其实就是在「力扣」第 146 题：<a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a> 的基础上，在删除策略里多考虑了一个维度（「访问次数」）的信息。</p><p>核心思想：先考虑访问次数，在访问次数相同的情况下，再考虑缓存的时间。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>由于题目的时间复杂度要求 $O(1)$，空间肯定不能省，存取数据时间性能最好的就是哈希表，因此底层的数据结构一定是一个哈希表；</li><li>又由于缓存大小有限制，删除策略是「先看访问频次，再看访问时间」，所以需要记录每个数据访问的频次；</li><li>「删除某个数据」得 $O(1)$，访问某个数据，时间优先级得提前（提前到当前频次最高），<strong>这样的数据结构符合在头尾访问数据最快，并且删除其中一个结点也得是 $O(1)$，这种数据结构是「双向链表」</strong>；</li><li>「链表」结点得记录：1、value，2、key（在哈希表里删除的时候用得上），3、访问次数信息，以便知道下一个访问次数是多少；4、前驱结点引用，5、后继结点引用；</li><li>哈希表存储的 key 就是题目的 key，方便快速查询和删除，value 是结点的引用，方便对结点进行操作。</li></ul><p>这样一套设计下来，题目中要求的操作就是 $O(1)$ 了。</p><p>下面是内存结构示意图：</p><p><img src="https://pic.leetcode-cn.com/909ea661e76e600e49763d06d2fa72b7897e36ebf47d966292636bce1b241734-image.png" alt="image.png"></p><p>（图是用软件 OmniGraffle 画的。不太复杂的规则图形，用 PPT 也可以画出来。）</p><ul><li>每次访问一个已经存在的元素的时候：应该先把结点类从当前所属的访问次数双链表里删除，然后再添加到它「下一个访问次数」的双向链表的头部。</li></ul><p>编码说明：</p><ul><li>应该先弄清楚思路，再编码；</li><li>可以设计成「双向链表」的尾部存储较新访问的结点，头部是当前频次最旧的结点。双向链表在结构上是对称的，编码的时候注意保持语义一致；</li><li>「双向链表」的常见操作是使用两个虚拟结点，一个访问头部最快，另一个访问尾部最快，这个技巧其实在「单链表」中我们已经见过，叫「哨兵结点」；</li><li>链表中的相关操作建议画图去思考实现，否则凭空想象一些指针变量的指向操作容易出错；</li><li>如果在编码的过程中，发现一些数据需要维护，可以适当增加属性；</li><li>在一些操作中相同的操作，应该考虑抽取成公用的方法；</li><li>在编码完成以后，需要注意调试，这一步是很花时间的，也没有过多的技巧，添加打印输出语句。</li></ul><p>注意：</p><ol><li>以下代码由于本人水平有限，封装还不够好，仅供参考；</li><li>下面的代码细节特别多，读者<strong>浏览即可，不建议模仿，应该尝试自己编写完成，相信是一个不错的编程练习</strong>；</li><li><code>ListNode</code> 结点类，哈希表要用到，双向链表也会用到，因此设计在外面；</li><li>Java 里的 <code>LinkedList</code> 就是双向链表，这里只是为了练习，定制化一些操作，因此手写。</li></ol><p><strong>参考代码</strong>：</p><p>感谢 <a href="/u/zhangkyou/">@zhangkyou</a> 和 <a href="/u/lzhlyle/">@lzhlyle</a> 朋友的提醒，原来我的代码维护的是 <code>maxFrequent</code>，时间复杂度没有到 $O(1)$，应该维护的是 <code>minFrequent</code>。需要在以下两处维护这个变量：</p><ul><li>插入一个新结点的时候，因为这个结点之前肯定没有被访问过，此时设置 <code>minFrequent = 1</code>，相当于归位了；</li><li>当 <code>put</code> 和 <code>get</code> 的时候，都有把当前链表里的结点移到另一个链表结点的操作。如果移除的那个链表恰好是访问次数最小链表，并且移除以后链表的结点个数为 <code>0</code>，<code>minFrequent</code> 需要加 1 。</li></ul><pre class="line-numbers language-Java"><code class="language-Java">import java.util.HashMap;import java.util.Map;public class LFUCache {    /**     * key 就是题目中的 key     * value 是结点类     */    private Map<Integer, ListNode> map;    /**     * 访问次数哈希表，使用 ListNode[] 也可以，不过要占用很多空间     */    private Map<Integer, DoubleLinkedList> frequentMap;    /**     * 外部传入的容量大小     */    private Integer capacity;    /**     * 全局最高访问次数，删除最少使用访问次数的结点时会用到     */    private Integer minFrequent = 1;    public LFUCache(int capacity) {        map = new HashMap<>(capacity);        frequentMap = new HashMap<>();        this.capacity = capacity;    }    /**     * get 一次操作，访问次数就增加 1；     * 从原来的链表调整到访问次数更高的链表的表头     *     * @param key     * @return     */    public int get(int key) {        // 测试测出来的，capacity 可能传 0        if (capacity == 0) {            return -1;        }        if (map.containsKey(key)) {            // 获得结点类            ListNode listNode = removeListNode(key);            // 挂接到新的访问次数的双向链表的头部            int frequent = listNode.frequent;            addListNode2Head(frequent, listNode);            return listNode.value;        } else {            return -1;        }    }    /**     * @param key     * @param value     */    public void put(int key, int value) {        if (capacity == 0) {            return;        }        // 如果 key 存在，就更新访问次数 + 1，更新值        if (map.containsKey(key)) {            ListNode listNode = removeListNode(key);            // 更新 value            listNode.value = value;            int frequent = listNode.frequent;            addListNode2Head(frequent, listNode);            return;        }        // 如果 key 不存在        // 1、如果满了，先删除访问次数最小的的末尾结点，再删除 map 里对应的 key        if (map.size() == capacity) {            // 1、从双链表里删除结点            DoubleLinkedList doubleLinkedList = frequentMap.get(minFrequent);            ListNode removeNode = doubleLinkedList.removeTail();            // 2、删除 map 里对应的 key            map.remove(removeNode.key);        }        // 2、再创建新结点放在访问次数为 1 的双向链表的前面        ListNode newListNode = new ListNode(key, value);        addListNode2Head(1, newListNode);        map.put(key, newListNode);        // 【注意】因为这个结点是刚刚创建的，最少访问次数一定为 1        this.minFrequent = 1;    }    // 以下部分主要是结点类和双向链表的操作    /**     * 结点类，是双向链表的组成部分     */    private class ListNode {        private int key;        private int value;        private int frequent = 1;        private ListNode pre;        private ListNode next;        public ListNode() {        }        public ListNode(int key, int value) {            this.key = key;            this.value = value;        }    }    /**     * 双向链表     */    private class DoubleLinkedList {        /**         * 虚拟头结点，它无前驱结点         */        private ListNode dummyHead;        /**         * 虚拟尾结点，它无后继结点         */        private ListNode dummyTail;        /**         * 当前双向链表的有效结点数         */        private int count;        public DoubleLinkedList() {            // 虚拟头尾结点赋值多少无所谓            this.dummyHead = new ListNode(-1, -1);            this.dummyTail = new ListNode(-2, -2);            dummyHead.next = dummyTail;            dummyTail.pre = dummyHead;            count = 0;        }        /**         * 把一个结点类添加到双向链表的开头（头部是最新使用数据）         *         * @param addNode         */        public void addNode2Head(ListNode addNode) {            ListNode oldHead = dummyHead.next;            // 两侧结点指向它            dummyHead.next = addNode;            oldHead.pre = addNode;            // 它的前驱和后继指向两侧结点            addNode.pre = dummyHead;            addNode.next = oldHead;            count++;        }        /**         * 把双向链表的末尾结点删除（尾部是最旧的数据，在缓存满的时候淘汰）         *         * @return         */        public ListNode removeTail() {            ListNode oldTail = dummyTail.pre;            ListNode newTail = oldTail.pre;            // 两侧结点建立连接            newTail.next = dummyTail;            dummyTail.pre = newTail;            // 它的两个属性切断连接            oldTail.pre = null;            oldTail.next = null;            // 重要：删除一个结点，当前双向链表的结点个数少 1            count--;            return oldTail;        }    }    /**     * 将原来访问次数的结点，从双向链表里脱离出来     *     * @param key     * @return     */    private ListNode removeListNode(int key) {        // 获得结点类        ListNode deleteNode = map.get(key);        ListNode preNode = deleteNode.pre;        ListNode nextNode = deleteNode.next;        // 两侧结点建立连接        preNode.next = nextNode;        nextNode.pre = preNode;        // 删除去原来两侧结点的连接        deleteNode.pre = null;        deleteNode.next = null;        // 维护双链表结点数        frequentMap.get(deleteNode.frequent).count--;        // 【注意】维护 minFrequent        // 如果当前结点正好在最小访问次数的链表上，并且移除以后结点数为 0，最小访问次数需要加 1        if (deleteNode.frequent == minFrequent && frequentMap.get(deleteNode.frequent).count == 0) {            minFrequent++;        }        // 访问次数加 1        deleteNode.frequent++;        return deleteNode;    }    /**     * 把结点放在对应访问次数的双向链表的头部     *     * @param frequent     * @param addNode     */    private void addListNode2Head(int frequent, ListNode addNode) {        DoubleLinkedList doubleLinkedList;        // 如果不存在，就初始化        if (frequentMap.containsKey(frequent)) {            doubleLinkedList = frequentMap.get(frequent);        } else {            doubleLinkedList = new DoubleLinkedList();        }        // 添加到 DoubleLinkedList 的表头        doubleLinkedList.addNode2Head(addNode);        frequentMap.put(frequent, doubleLinkedList);    }    public static void main(String[] args) {        LFUCache cache = new LFUCache(2);        cache.put(1, 1);        cache.put(2, 2);        System.out.println(cache.map.keySet());        int res1 = cache.get(1);        System.out.println(res1);        cache.put(3, 3);        System.out.println(cache.map.keySet());        int res2 = cache.get(2);        System.out.println(res2);        int res3 = cache.get(3);        System.out.println(res3);        cache.put(4, 4);        System.out.println(cache.map.keySet());        int res4 = cache.get(1);        System.out.println(res4);        int res5 = cache.get(3);        System.out.println(res5);        int res6 = cache.get(4);        System.out.println(res6);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 445 题：两数相加 II（中等）</title>
      <link href="/leetcode-algo/2017/08/25/leetcode-algo/0445-add-two-numbers-ii/"/>
      <url>/leetcode-algo/2017/08/25/leetcode-algo/0445-add-two-numbers-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-445-题：两数相加-II（中等）"><a href="#「力扣」第-445-题：两数相加-II（中等）" class="headerlink" title="「力扣」第 445 题：两数相加 II（中等）"></a>「力扣」第 445 题：两数相加 II（中等）</h2><ul><li><p>英文网址：<a href="https://leetcode.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">445. Add Two Numbers II</a>  ；</p></li><li><p>中文网址：<a href="https://leetcode-cn.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">445. 两数相加 II</a> ；</p></li><li><p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/solution/liang-ge-zhan-shi-yong-tou-cha-fa-sheng-cheng-jie-/" target="_blank" rel="noopener">题解地址</a></p></li></ul><blockquote><p>给定两个<strong>非空</strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>进阶:</strong>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p><strong>示例</strong>：</p><pre><code>输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</code></pre></blockquote><p>查考知识点：在链表的头结点插入新结点。</p><p><strong>参考代码</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Stack;class ListNode {    int val;    ListNode next;    ListNode(int x) {        val = x;    }    public ListNode(int[] nums) {        if (nums == null || nums.length == 0) {            throw new IllegalArgumentException("arr can not be empty");        }        this.val = nums[0];        ListNode curr = this;        for (int i = 1; i < nums.length; i++) {            curr.next = new ListNode(nums[i]);            curr = curr.next;        }    }    @Override    public String toString() {        StringBuilder s = new StringBuilder();        ListNode cur = this;        while (cur != null) {            s.append(cur.val);            s.append(" -> ");            cur = cur.next;        }        s.append("NULL");        return s.toString();    }}public class Solution {    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {        // 特判        if (l1 == null) {            return l2;        }        if (l2 == null) {            return l1;        }        // 为了保证从低位开始计算，因此使用两个栈        Stack<Integer> stack1 = new Stack<>();        Stack<Integer> stack2 = new Stack<>();        while (l1 != null) {            stack1.push(l1.val);            l1 = l1.next;        }        while (l2 != null) {            stack2.push(l2.val);            l2 = l2.next;        }        ListNode nextNode = null;        ListNode curNode;        int carry = 0;        while (!stack1.empty() || !stack2.empty()) {            if (!stack1.empty()) {                carry += stack1.pop();            }            if (!stack2.empty()) {                carry += stack2.pop();            }            // 头插法            curNode = new ListNode(carry % 10);            curNode.next = nextNode;            nextNode = curNode;            carry /= 10;        }        if (carry == 1) {            ListNode head = new ListNode(carry);            head.next = nextNode;            return head;        }        return nextNode;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考资料：</p><p>反转以后，再相加。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * pre cur next */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ListNode <span class="token function">reverseListNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode rL1 <span class="token operator">=</span> <span class="token function">reverseListNode</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode rL2 <span class="token operator">=</span> <span class="token function">reverseListNode</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>rL1 <span class="token operator">!=</span> null <span class="token operator">||</span> rL2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rL1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> rL1<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                rL1 <span class="token operator">=</span> rL1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rL2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> rL2<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                rL2 <span class="token operator">=</span> rL2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            sum <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">reverseListNode</span><span class="token punctuation">(</span>dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较不好理解的写法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode p1 <span class="token operator">=</span> l1<span class="token punctuation">;</span>        ListNode p2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode head<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>stack2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur<span class="token punctuation">.</span>val <span class="token operator">=</span> sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 下一个节点存的值是：是否进位</span>            head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> head<span class="token punctuation">;</span>            sum <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cur<span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> cur<span class="token punctuation">.</span>next <span class="token operator">:</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路：需要考虑的问题是如果不允许修改输入的链表该怎么办；使用一个辅助的数据结构来完成。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        """</span>        stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        p1 <span class="token operator">=</span> l1        p2 <span class="token operator">=</span> l2        <span class="token keyword">while</span> p1<span class="token punctuation">:</span>            stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p1<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next        <span class="token keyword">while</span> p2<span class="token punctuation">:</span>            stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p2<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        s <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> stack1 <span class="token operator">or</span> stack2<span class="token punctuation">:</span>            <span class="token keyword">if</span> stack1<span class="token punctuation">:</span>                s <span class="token operator">+=</span> stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> stack2<span class="token punctuation">:</span>                s <span class="token operator">+=</span> stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span>            s <span class="token operator">//=</span> <span class="token number">10</span>        <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        head <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>res<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        cur_node <span class="token operator">=</span> head        <span class="token keyword">while</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">:</span>            cur_node<span class="token punctuation">.</span>next <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>res<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            cur_node <span class="token operator">=</span> cur_node<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 328 题：奇偶链表（中等）</title>
      <link href="/leetcode-algo/2017/08/24/leetcode-algo/0328-odd-even-linked-list/"/>
      <url>/leetcode-algo/2017/08/24/leetcode-algo/0328-odd-even-linked-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-328-题：奇偶链表（中等）"><a href="#「力扣」第-328-题：奇偶链表（中等）" class="headerlink" title="「力扣」第 328 题：奇偶链表（中等）"></a>「力扣」第 328 题：奇偶链表（中等）</h2><ul><li><p>中文网址：<a href="https://leetcode-cn.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">328. 奇偶链表</a> 。</p></li><li><p>英文网址：<a href="https://leetcode.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">328. Odd Even Linked List</a> ，</p></li></ul><blockquote><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p>示例 1:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code></pre><p>示例 2:</p><pre><code>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</code></pre><p>说明：</p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul></blockquote><p>思路：题目要求<strong>原地算法</strong>完成，那么就一定得“穿针引线”了。</p><ul><li>方法1：可以使用 <a href="https://liweiwei1419.github.io/leetcode-solution/leetcode-0086-partition-list/" target="_blank" rel="noopener">LeetCode 第 86 题题解思路 2 </a>完成。</li><li>方法2：同样使用两个指针，一次跳过一个节点完成“穿针引线”，特别注意要一些边界情况的判断。</li></ul><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/328-1.jpg" alt="LeetCode 第 328 题：奇数（Odd）偶数（Even）链表"></p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># odd 奇数</span>        odd_head <span class="token operator">=</span> head        even_head <span class="token operator">=</span> head<span class="token punctuation">.</span>next        odd_cur <span class="token operator">=</span> odd_head        even_cur <span class="token operator">=</span> even_head        <span class="token keyword">while</span> even_cur <span class="token operator">and</span> even_cur<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            odd_cur<span class="token punctuation">.</span>next <span class="token operator">=</span> odd_cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            even_cur<span class="token punctuation">.</span>next <span class="token operator">=</span> even_cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            odd_cur <span class="token operator">=</span> odd_cur<span class="token punctuation">.</span>next            even_cur <span class="token operator">=</span> even_cur<span class="token punctuation">.</span>next        odd_cur<span class="token punctuation">.</span>next <span class="token operator">=</span> even_head        <span class="token keyword">return</span> odd_head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我还写过一个题解在<a href="https://liweiwei1419.github.io/leetcode-solution/leetcode-0328-odd-even-linked-list/" target="_blank" rel="noopener">这里</a>，可以参考一下。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 237 题：删除链表中的节点（简单）</title>
      <link href="/leetcode-algo/2017/08/23/leetcode-algo/0237-delete-node-in-a-linked-list/"/>
      <url>/leetcode-algo/2017/08/23/leetcode-algo/0237-delete-node-in-a-linked-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-237-题：删除链表中的节点（简单）"><a href="#「力扣」第-237-题：删除链表中的节点（简单）" class="headerlink" title="「力扣」第 237 题：删除链表中的节点（简单）"></a>「力扣」第 237 题：删除链表中的节点（简单）</h2><ul><li>传送门：英文网址：<a href="https://leetcode.com/problems/delete-node-in-a-linked-list/description/" target="_blank" rel="noopener">237. Delete Node in a Linked List</a> ；</li><li>中文网址：<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/description/" target="_blank" rel="noopener">237. 删除链表中的节点</a> 。</li></ul><blockquote><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png" alt="img"></p><p>示例 1：</p><pre><code>输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><p>示例 2：</p><pre><code>输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre></blockquote><p><strong>说明:</strong></p><ul><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。</li></ul><p>删除链表上的节点。（思考一下，我们原来学习的链表的删除是怎么删除的，通过索引来删除？）</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span>Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode currNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        currNode<span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            currNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            currNode <span class="token operator">=</span> currNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode currNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>currNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>currNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            currNode <span class="token operator">=</span> currNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 第 1 步：把待删除结点的下一结点的值赋值给自己</span>        ListNode nextNode <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>val <span class="token operator">=</span> nextNode<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第 2 步：删除下一个结点</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> nextNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        nextNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        solution<span class="token punctuation">.</span><span class="token function">deleteNode</span><span class="token punctuation">(</span>node1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这道题理解题意是关键，题目要求的是删除这个节点     *     * @param node     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            node <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode deleteNode <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>val <span class="token operator">=</span> deleteNode<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> deleteNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        deleteNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 234 题：回文链表（简单）</title>
      <link href="/leetcode-algo/2017/08/22/leetcode-algo/0234-palindrome-linked-list/"/>
      <url>/leetcode-algo/2017/08/22/leetcode-algo/0234-palindrome-linked-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-234-题：回文链表（简单）"><a href="#「力扣」第-234-题：回文链表（简单）" class="headerlink" title="「力扣」第 234 题：回文链表（简单）"></a>「力扣」第 234 题：回文链表（简单）</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/palindrome-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list</a></li></ul><blockquote><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><pre><code>输入: 1-&gt;2输出: false</code></pre><p>示例 2:</p><pre><code>输入: 1-&gt;2-&gt;2-&gt;1输出: true</code></pre><p>进阶：<br>你能否用 $O(n)$ 时间复杂度和 $O(1)$ 空间复杂度解决此题？</p></blockquote><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>放在一个动态数组中，然后判断这个动态数组的回文性。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">judgeArrPalindrome</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">judgeArrPalindrome</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：借助栈"><a href="#方法二：借助栈" class="headerlink" title="方法二：借助栈"></a>方法二：借助栈</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 分清楚奇数和偶数结点两种情况，不反转链表，借助栈完成回文链表的判断</span>    <span class="token comment" spellcheck="true">//      slow</span>    <span class="token comment" spellcheck="true">// 1，2，3，4，5</span>    <span class="token comment" spellcheck="true">//   slow</span>    <span class="token comment" spellcheck="true">// 1，2，3，4</span>    <span class="token comment" spellcheck="true">/**     * @param head     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode fastNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode slowNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>slowNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fastNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fastNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slowNode <span class="token operator">=</span> slowNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fastNode <span class="token operator">=</span> fastNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>slowNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fastNode<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 链表有奇数个结点</span>            stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        slowNode <span class="token operator">=</span> slowNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>slowNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> slowNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            slowNode <span class="token operator">=</span> slowNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三：反转后面的链表"><a href="#方法三：反转后面的链表" class="headerlink" title="方法三：反转后面的链表"></a>方法三：反转后面的链表</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1、使用快慢指针找到链表的中间结点</span>        <span class="token comment" spellcheck="true">// 偶数个结点的时候，来到了中间靠左的那个结点</span>        ListNode slowNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode fastNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fastNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fastNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slowNode <span class="token operator">=</span> slowNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fastNode <span class="token operator">=</span> fastNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 2、slowNode 的下一个就是新链表，反转它</span>        ListNode curNode <span class="token operator">=</span> slowNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意：这里要切点连接，否则反转的额时候会出问题</span>        slowNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3、反转链表的后半部分</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode next <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> curNode<span class="token punctuation">;</span>            curNode <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 此时 pre 成为新链表的表头</span>        <span class="token comment" spellcheck="true">// 4、逐个比对，两边长度不一，但只要"前缀部分相等即可"</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> pre <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">!=</span> pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习3：LeetCode-第-234-题：回文链表"><a href="#练习3：LeetCode-第-234-题：回文链表" class="headerlink" title="练习3：LeetCode 第 234 题：回文链表"></a>练习3：LeetCode 第 234 题：<a href="https://leetcode-cn.com/problems/palindrome-linked-list" target="_blank" rel="noopener">回文链表</a></h3><p>传送门：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a>。</p><blockquote><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><pre><code>输入: 1-&gt;2输出: false</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: 1-&gt;2-&gt;2-&gt;1输出: true</code></pre><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p></blockquote><p>求解关键：找到链表中间位置的结点，做一些相关的处理。特别要注意的是，不管哪种方法，都要对一些细节问题仔细考虑，可以举出具体的例子，画图帮助编码实现。</p><p>思路1：从中间位置开始反转链表，逐个比较。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * https://leetcode-cn.com/problems/palindrome-linked-list/description/ * * @author liwei */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// slow 的下一个就是新链表，反转它</span>        ListNode cur <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 此时 pre 成为新链表开头</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> pre <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">!=</span> pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> palindrome <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>palindrome<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：在寻找链表中间结点的过程中，慢结点向前遍历的时候，把遍历到的值放入一个栈中。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author liwei */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 分清楚奇数和偶数结点两种情况，不反转链表，借助栈完成回文链表的判断</span>    <span class="token comment" spellcheck="true">//      slow</span>    <span class="token comment" spellcheck="true">// 1，2，3，4，5</span>    <span class="token comment" spellcheck="true">//   slow</span>    <span class="token comment" spellcheck="true">// 1，2，3，4</span>    <span class="token comment" spellcheck="true">/**     * @param head     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 链表有奇数个结点</span>            stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution2 solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> palindrome <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>palindrome<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 206 题：反转链表（简单）</title>
      <link href="/leetcode-algo/2017/08/21/leetcode-algo/0206-reverse-linked-list/"/>
      <url>/leetcode-algo/2017/08/21/leetcode-algo/0206-reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-206-题：反转链表（简单）"><a href="#「力扣」第-206-题：反转链表（简单）" class="headerlink" title="「力扣」第 206 题：反转链表（简单）"></a>「力扣」第 206 题：反转链表（简单）</h2><ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/chuan-zhen-yin-xian-di-gui-by-liweiwei1419/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>反转一个单链表。</p><p>示例：</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p>进阶：<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p></blockquote><h3 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h3><p><img src="https://pic.leetcode-cn.com/2e044f2ccb55bbbe3ef599eb580e4197fa5f06fb3ee7aabbe0d3a3bd20473514-206-1.jpg" alt="206-1.jpg"></p><p>很常规的一道问题，关键在于画图分析。</p><ul><li><p>在画图的过程中，我们就可以分析出完成翻转链表这件事情，一共要用 3 个指针 <code>pre</code>、<code>cur</code>、<code>next</code>；</p></li><li><p>当前遍历的 <code>cur</code> 指针是一定有的；</p></li><li><p>当前结点的 <code>next</code> 结点要指到它前一个结点，所以 <code>pre</code> 也必须有；</p></li><li><p>迭代要继续下去，<code>cur</code> 结点的下一个结点也得使用一个指针 <code>next</code> 保存一下，其中 <code>next</code> 可以在 <code>cur</code> 确定以后初始化。</p></li><li><p>画图分析 <code>next</code> 指针的指向，我们注意到我们分析出来的指针指向的先后顺序，通常跟数组的元素交换操作一样，程序写出来是“头尾相连”的；</p></li><li><p>最后一定不要忘记，返回的是 <code>pre</code> 节点。</p></li></ul><p>总结一下：</p><blockquote><p><strong>“穿针引线”法一般有 2 个步骤：</strong><br><strong>步骤 1：更新结点的 <code>next</code> 指针的指向；</strong><br><strong>步骤 2：更新循环变量，通常在循环一开始的时候，会预先保存下一轮要更新的结点，在循环结束的时候，直接赋值为这些变量即可。</strong></p></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 初始化上一个指针</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化当前指针</span>        ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 第 1 步：先把下一轮的循环变量保存一下，为了第 3 步方便</span>            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第 2 步：实现当前节点的 next 指针的反转</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第 3 步：更新下一轮迭代的循环变量</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 遍历完成以后，原来的最后一个节点就成为了 pre</span>        <span class="token comment" spellcheck="true">// 这个 pre 就是反转以后的新的链表的头指针</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li><p>时间复杂度：$O(N)$，仅仅遍历了一次链表；</p></li><li><p>空间复杂度：$O(1)$，仅仅遍历了一次链表，这里只使用了有限个的“指针”，帮助我们完成了链表的反转操作。</p></li></ul><p>如果你觉得穿针引线麻烦，那就交给递归来做这件事情吧。</p><h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode nextNode <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode newHead <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        nextNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，仅仅遍历了一次链表；</li><li>空间复杂度：$O(N)$，递归需要消耗递归栈。</li></ul><hr><p>以前的笔记。</p><p>分析：分析这道问题的时候写的草稿。</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/206-1.jpg" alt="LeetCode 第 206 题：反转链表"></p><p>题目的要求是节点是不动的，而应该改变的是节点的 next 指针的方向。而不应该是去修改链表的值，使得这个新的链表看起来是反向的。指针变化的过程其实并不复杂，关键是我们把图画出来，需要多少个临时变量，指针变化过程也就一目了然了。我们可以看到，reverseList 的参数是一个 ListNode 类型的对象，即对象的头结点。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 1、结合自己画的图并不难写出逻辑，把图画出来，迭代的思路就已经有了     * 2、借助三个指针：pre、current、next 完成链表的反转     * 3、     * @param head     * @return     */</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化上一个指针</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化当前指针</span>        ListNode current <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 第 1 步：先把 next 存起来，下一轮迭代要用到</span>            ListNode next <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第 2 步：实现当前节点的 next 指针的反转</span>            current<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第 3 步：重新定义下一轮迭代的循环变量</span>            pre <span class="token operator">=</span> current<span class="token punctuation">;</span>            current <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 遍历完成以后，原来的最后一个节点就成为了 pre</span>        <span class="token comment" spellcheck="true">// 这个 pre 就是反转以后的新的链表的头指针</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个解法的时间复杂度是 $O(n)$，因为它仅仅遍历了一次链表，空间复杂度是$O(1)$，因为这里仅仅使用了有限个的“指针”，帮助我们完成了链表的反转操作。</p><p>补充：如果不使用“穿针引线”，还可以用递归完成。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 203 题：移除链表元素（简单）</title>
      <link href="/leetcode-algo/2017/08/20/leetcode-algo/0203-remove-linked-list-elements/"/>
      <url>/leetcode-algo/2017/08/20/leetcode-algo/0203-remove-linked-list-elements/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-203-题：移除链表元素（简单）"><a href="#「力扣」第-203-题：移除链表元素（简单）" class="headerlink" title="「力扣」第 203 题：移除链表元素（简单）"></a>「力扣」第 203 题：移除链表元素（简单）</h2><ul><li>英文网址：<a href="https://leetcode.com/problems/remove-linked-list-elements/description/" target="_blank" rel="noopener">203. Remove Linked List Elements</a> ；</li><li>中文网址：<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/description/" target="_blank" rel="noopener">203. 删除链表中的结点</a>  。</li></ul><blockquote><p>删除链表中等于给定值 <strong>val</strong> 的所有节点。</p><p><strong>示例</strong>：</p><pre><code>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre></blockquote><p>1、设计第 $1$ 个结点，因此需要设置虚拟头结点。</p><p>2、两种方法：（1）递归；（2）穿针引线。</p><h3 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 下面，我们将 LeetCode 中的给出的链表的节点这个类进行一些扩展，方便我们的调试</span>    <span class="token comment" spellcheck="true">// 1、给出一个数字数组，通过数组构建数字链表</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 体会这里 this 指代了什么，其实就是 head</span>        <span class="token comment" spellcheck="true">// 因为这是一个构造函数，所以也无须将 head 返回</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2、重写 toString() 方法，方便我们查看链表中的元素</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 还是要特别注意的是，理解这里 this 的用法</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 穿针引线</span>    <span class="token keyword">public</span> ListNode <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 待删除的结点</span>                ListNode deleteNode <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> deleteNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                deleteNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        solution<span class="token punctuation">.</span><span class="token function">removeElements</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：使用递归的方法"><a href="#方法二：使用递归的方法" class="headerlink" title="方法二：使用递归的方法"></a>方法二：使用递归的方法</h3><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>removeElements<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span>        <span class="token keyword">return</span> head<span class="token punctuation">.</span>next <span class="token keyword">if</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> val <span class="token keyword">else</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路：先给出一个容易想到的解法，但是这个解法对于删除头结点的逻辑写得比较长。</p><p>Java 代码：（代码比较冗长，没有意义，可以跳过不看，只要跟头结点有关的问题，要设置虚拟头结点就好了。）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 基本思路：只要当前遍历的节点的下一个节点不为空 * 把它拿出来比较一下目标值： * 如果和目标值相同，就（1）先把要删除的节点存一下。 * （2）当前的节点的下一个引用指向要删除节点的下一个引用。 * （3）把要删除节点的下一个节点的引用置为 null。 * 但是，特别要注意：这种方法对于，如果要删除的节点是头结点的方式，并不适用 * * @param head * @param value * @return */</span><span class="token keyword">public</span> ListNode <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里陷阱很多，要特别注意测试用例为"要删除的节点值连续出现在链表表头的情况"</span>    <span class="token comment" spellcheck="true">// 例如，待考察链表 {1, 1, 1, 2, 3, 4, 5} ，待删除的元素的值是 1 的情况</span>    <span class="token comment" spellcheck="true">// 为了删除头结点，我们编写了很长的一段代码</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode delNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        delNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode current <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode delNode <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            current<span class="token punctuation">.</span>next <span class="token operator">=</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            delNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面介绍一种设立链表的虚拟头结点的技巧，使得删除头结点的逻辑可以合并到删除非链表头结点的逻辑中。<br>思路很简单，就是在带考察的链表前面加上一个虚拟节点，使得原来的头结点不是头结点。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode current <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode delNode <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            current<span class="token punctuation">.</span>next <span class="token operator">=</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            delNode <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    ListNode retNode <span class="token operator">=</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    dummyHead <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">return</span> retNode<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路：</p><p>1、使用虚拟头结点；</p><p>2、<strong>掌握递归写法</strong>。</p><p>重点：千万不要忘记，还有递归写法。</p><p>Python 代码：使用递归，假设小一个规模的问题已经求解，然后处理原问题。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :type val: int        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>removeElements<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span>        <span class="token keyword">return</span> head<span class="token punctuation">.</span>next <span class="token keyword">if</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> val <span class="token keyword">else</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先处理递归到底的情况，直接返回 null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 假设下一个结点开始的链表已经处理完了</span>    ListNode res <span class="token operator">=</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 再将头结点和除了头结点以外的链表部分合并考虑</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> res<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 160 题：相交链表（简单）</title>
      <link href="/leetcode-algo/2017/08/19/leetcode-algo/0160-intersection-of-two-linked-lists/"/>
      <url>/leetcode-algo/2017/08/19/leetcode-algo/0160-intersection-of-two-linked-lists/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-160-题：相交链表（简单）"><a href="#「力扣」第-160-题：相交链表（简单）" class="headerlink" title="「力扣」第 160 题：相交链表（简单）"></a>「力扣」第 160 题：相交链表（简单）</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a></li></ul><blockquote><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表<strong>：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></p><pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></p><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></p><pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。</code></pre><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 $O(n)$ 时间复杂度，且仅用 $O(1)$ 内存。</li></ul></blockquote><p>这一节我们再来看一个比较常见的问题：相交链表。这道题是力扣上第 160 号问题，要我们编写一个程序，找到两个单链表相交的起始节点。</p><h3 id="方法一：使用哈希表（空间复杂度不符合要求）"><a href="#方法一：使用哈希表（空间复杂度不符合要求）" class="headerlink" title="方法一：使用哈希表（空间复杂度不符合要求）"></a>方法一：使用哈希表（空间复杂度不符合要求）</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashSet<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> hashSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> headA<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            hashSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        curNode <span class="token operator">=</span> headB<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>hashSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>curNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> curNode<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二-：需要先遍历得到两个链表的长度"><a href="#方法二-：需要先遍历得到两个链表的长度" class="headerlink" title="方法二 ：需要先遍历得到两个链表的长度"></a>方法二 ：需要先遍历得到两个链表的长度</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>        next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>headA <span class="token operator">==</span> null <span class="token operator">||</span> headB <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> aLen <span class="token operator">=</span> <span class="token function">getLenOfListNode</span><span class="token punctuation">(</span>headA<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bLen <span class="token operator">=</span> <span class="token function">getLenOfListNode</span><span class="token punctuation">(</span>headB<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 总是让 A 链表是短链表</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>aLen <span class="token operator">></span> bLen<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode temp <span class="token operator">=</span> headA<span class="token punctuation">;</span>            headA <span class="token operator">=</span> headB<span class="token punctuation">;</span>            headB <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 注意：这里要取绝对值</span>        <span class="token keyword">int</span> distance <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>aLen <span class="token operator">-</span> bLen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> distance<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            headB <span class="token operator">=</span> headB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>headA <span class="token operator">!=</span> headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>            headA <span class="token operator">=</span> headA<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            headB <span class="token operator">=</span> headB<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> headA<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getLenOfListNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            len<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> len<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三：让-A、B-链表等长"><a href="#方法三：让-A、B-链表等长" class="headerlink" title="方法三：让 A、B 链表等长"></a>方法三：让 A、B 链表等长</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode headA<span class="token punctuation">,</span> ListNode headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>headA <span class="token operator">==</span> null <span class="token operator">||</span> headB <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode head1 <span class="token operator">=</span> headA<span class="token punctuation">;</span>        ListNode head2 <span class="token operator">=</span> headB<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> head2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                head1 <span class="token operator">=</span> head1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                head1 <span class="token operator">=</span> headB<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                head2 <span class="token operator">=</span> head2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                head2 <span class="token operator">=</span> headA<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head1<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 148 题：排序链表</title>
      <link href="/leetcode-algo/2017/08/18/leetcode-algo/0148-sort-list/"/>
      <url>/leetcode-algo/2017/08/18/leetcode-algo/0148-sort-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-148-题：排序链表"><a href="#「力扣」第-148-题：排序链表" class="headerlink" title="「力扣」第 148 题：排序链表"></a>「力扣」第 148 题：排序链表</h2><p>传送门：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a>；</p><p>题解地址：<a href="https://leetcode-cn.com/problems/sort-list/solution/zi-di-xiang-shang-de-gui-bing-pai-xu-java-dai-ma-b/" target="_blank" rel="noopener">自底向上的“归并排序”（Java 代码）</a>。</p><blockquote><p>在 $O(n log n)$ 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例 1:</p><p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4<br>示例 2:</p><p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><h2 id="自底向上的“归并排序”（Java-代码）"><a href="#自底向上的“归并排序”（Java-代码）" class="headerlink" title="自底向上的“归并排序”（Java 代码）"></a>自底向上的“归并排序”（Java 代码）</h2><p>这个方法比较 tricky，可能编码上还有优化的空间，大家看一看就好了。</p><p>（温馨提示：下面的幻灯片中，有几页上有较多的文字，可能需要您停留一下，可以点击右下角的后退 “|◀” 或者前进 “▶|” 按钮控制幻灯片的播放。）</p><p><img src="https://pic.leetcode-cn.com/5dde7ef2dbf5dfc6ba492967ad90ae47c8b69912c933c6ff7fdd1b193df79a3a-148-1.png" alt="148-1.png">),<img src="https://pic.leetcode-cn.com/c346cb3c15ca1573ad84812ebc7414ea15f603a77eaec8da8e65b49406d57c9b-148-2.png" alt="148-2.png">),<img src="https://pic.leetcode-cn.com/6cba91ad06d27ba535ab7f5479ded87728ab6a443dbc6180aa999ca7205d2398-148-3.png" alt="148-3.png">),<img src="https://pic.leetcode-cn.com/191596efb354dc1a20d5c2cc074a5849afd30a4524e2ebdc1f52453657cb5f8f-148-4.png" alt="148-4.png">),<img src="https://pic.leetcode-cn.com/c31c4944662863515d3c8b2ba480c6d3d66edb1250514aa918afbf538a69bfc1-148-5.png" alt="148-5.png">),<img src="https://pic.leetcode-cn.com/41707f28feeec83b718eb3402135d4184f90f4069372dbf54f6da5b86ad3376f-148-6.png" alt="148-6.png">),<img src="https://pic.leetcode-cn.com/855652a477f968df5f59eaf66d6c61388d0e36abd5298d96d6bb02f1b0f49707-148-7.png" alt="148-7.png">),<img src="https://pic.leetcode-cn.com/177b1e7f1e186062f06eb54abaa1a9a0c89899901d25f6ae851cb2cb47a15f19-148-8.png" alt="148-8.png">),<img src="https://pic.leetcode-cn.com/261d0c730ba13d41aed5ea6b690c8b44a6d05d0de6f219f000c5df68ae5b43d6-148-9.png" alt="148-9.png">),<img src="https://pic.leetcode-cn.com/d6eefcc333bd3362c60f32808b7fab93eec20c1c65cee6930d2c7cf0cae38748-148-10.png" alt="148-10.png">),<img src="https://pic.leetcode-cn.com/c65fa18c769b01844170815abb245dc85a8d348924466cd301ce75b3dc888b09-148-11.png" alt="148-11.png">),<img src="https://pic.leetcode-cn.com/05cfa4d484aabc6b57598602b5d0653784646b9c928b48fd5f19b36ea62b20d6-148-12.png" alt="148-12.png">),<img src="https://pic.leetcode-cn.com/5ab524c4b1cdd9eded4c53d25c50b6dbd17c7ae9d070ec99eaed95afa12d0b39-148-13.png" alt="148-13.png">),<img src="https://pic.leetcode-cn.com/849c0c08926d27356efd734be87f73e7a8dd86d8b4e74d6962962228652a685f-148-14.png" alt="148-14.png">),<img src="https://pic.leetcode-cn.com/92858f3f9669b8c2f278029b715e2d467307a8a4fec93f67733d17b2676442c8-148-15.png" alt="148-15.png">),<img src="https://pic.leetcode-cn.com/75ab2a5b498b86c2d99d753d3da59d324c4b183edadbea6f93e7af100da427b0-148-16.png" alt="148-16.png">),<img src="https://pic.leetcode-cn.com/26a88cb6fab5285cc5e9b06d32e3e73e8b2b0b6eeadbb45b50d86a406701cf5c-148-17.png" alt="148-17.png">),<img src="https://pic.leetcode-cn.com/6291f1d052621a96ef6d5ce0b4cb9a8c8f8cb48c766bcb7d0ffa9c0836a9ac6f-148-18.png" alt="148-18.png">),<img src="https://pic.leetcode-cn.com/61fcc46a226ec29242dc14238e4a6495b48c5e9f4def7aafa79527dc6235f518-148-19.png" alt="148-19.png">),<img src="https://pic.leetcode-cn.com/c965e5623aa846259a16dfb32a6eeb7be72412568efcc8791e49d26bd470ef66-148-20.png" alt="148-20.png">),<img src="https://pic.leetcode-cn.com/af5ea17697e91188bb270ad6e1112a80f7fa92ad9e9fa7aaaef6055696ad77b7-148-21.png" alt="148-21.png">),<img src="https://pic.leetcode-cn.com/58c1457d8f202fd3010b2761482645da71ac98b30d60844fcd1f596d2c470d7e-148-22.png" alt="148-22.png">),<img src="https://pic.leetcode-cn.com/cd5b0ceec9624717db1290db4d1c426e7ba1e86ad1c24134a813dcc5221f9e08-148-23.png" alt="148-23.png">),<img src="https://pic.leetcode-cn.com/a2dc861706e5193ecfa52a5c28dc8032b1d0a48c8ad065d362e130bd2b9cc65e-148-24.png" alt="148-24.png"></p><p><strong>参考代码</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">/** * 自下而上进行归并 * * @author liwei */public class Solution2 {    public ListNode sortList(ListNode head) {        if (head == null || head.next == null) {            return head;        }        // 这里设置 64 ，是一个绰绰有余的数字，可以满足结点数量为 2^64 这么多的单链表的排序        ListNode[] counter = new ListNode[64];        ListNode curNode = head;        // 遍历到的最大的 counter 数组的索引        int maxIndex = 0;        while (curNode != null) {            // 先把当前元素暂存起来，马上我们就要把它放到 counter 数组合适的位置上            ListNode carryNode = curNode;            // curNode 指针马上后移，方便下次处理            curNode = curNode.next;            // 拿出的节点就和原来的链表没有关系了，我们在 counter 数组中完成排序，所以要切断它和原链表的关系            carryNode.next = null;            // 尝试从 counter 数组 0 号索引开始放置            int i = 0;            // 只要非空当前位置非空，就进行一次 merge，merge 以后尝试放到下一格，如果下一格非空就继续合并            // 合并以后再尝试放到下一格，直到下一格为空，直接放在那个为空的下一格就好            while (counter[i] != null) {                ListNode newMergeNode = mergeOfTwoSortedListNode(carryNode, counter[i]);                counter[i] = null;                i++;                carryNode = newMergeNode;            }            // 遇到了空，就把 carryNode 放在数组的这个位置上            counter[i] = carryNode;            // 记录最多使用到 counter 数组的第几位，最后合并的时候要用上            if (i > maxIndex) {                maxIndex = i;            }        }        // 遍历整个 count 数组，将它们全部归并，这个操作就和归并 n 个有序单链表是一样的了，我们这里采用两两归并        // 还可以采用 LeetCode 第 23 题的办法完成这一步        // 参考：https://liweiwei1419.github.io/leetcode-solution/leetcode-0023-merge-k-sorted-lists/        ListNode res = null;        for (int i = 0; i <= maxIndex; i++) {            if (counter[i] != null) {                res = mergeOfTwoSortedListNode(res, counter[i]);            }        }        return res;    }    /**     * 归并两个已经排好序的单链表，是我们非常熟悉的操作了，可以递归完成，也可以穿针引线，这里我们递归完成     *     * @param l1 顺序存放的单链表1     * @param l2 顺序存放的单链表2     * @return 合并以后的单链表     */    private ListNode mergeOfTwoSortedListNode(ListNode l1, ListNode l2) {        if (l1 == null) {            return l2;        }        if (l2 == null) {            return l1;        }        if (l1.val < l2.val) {            l1.next = mergeOfTwoSortedListNode(l1.next, l2);            return l1;        } else {            l2.next = mergeOfTwoSortedListNode(l1, l2.next);            return l2;        }    }    public static void main(String[] args) {        int[] nums = new int[]{9, 8, 2, 7, 6, 5, 4, 3, 1};        ListNode head = new ListNode(nums);        Solution2 solution2 = new Solution2();        ListNode sortList = solution2.sortList(head);        System.out.println(sortList);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面补充“自顶向下”的“归并排序”的写法，注意 3 种写法的不同之处。</p><p>Python 代码 1：</p><pre class="line-numbers language-Python"><code class="language-Python">class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass Solution:    def sortList(self, head: ListNode) -> ListNode:        if head is None or head.next is None:            return head        # 找到中点        slow = head        fast = head        # 使用这种方式，当结点个数为 2 个时候，slow 在左结点        # 不会导致死循环        while fast.next and fast.next.next:            slow = slow.next            fast = fast.next.next        head2 = slow.next        slow.next = None        lnode = self.sortList(head)        rnode = self.sortList(head2)        return self.__merge_two_sorted_list(lnode, rnode)    def __merge_two_sorted_list(self, head1, head2):        if head1 is None:            return head2        if head2 is None:            return head1        if head1.val < head2.val:            head1.next = self.__merge_two_sorted_list(head1.next, head2)            return head1        else:            head2.next = self.__merge_two_sorted_list(head1, head2.next)            return head2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码 2：</p><pre class="line-numbers language-Python"><code class="language-Python">class ListNode:    def __init__(self, x):        self.val = x        self.next = None# 这里有个小陷阱，如果遇到问题，不要着急，代码调试就好了class Solution:    def sortList(self, head: ListNode) -> ListNode:        if head is None or head.next is None:            return head        # 找到中点        slow = head        fast = head        while fast and fast.next:            # 这里要保存一下前一个指针            p = slow            slow = slow.next            fast = fast.next.next        p.next = None        # print_node_list(head)        # print_node_list(head2)        lnode = self.sortList(head)        rnode = self.sortList(slow)        return self.__merge_two_sorted_list(lnode, rnode)    def __merge_two_sorted_list(self, head1, head2):        if head1 is None:            return head2        if head2 is None:            return head1        if head1.val < head2.val:            head1.next = self.__merge_two_sorted_list(head1.next, head2)            return head1        else:            head2.next = self.__merge_two_sorted_list(head1, head2.next)            return head2def create_node_list(arr):    head = ListNode(arr[0])    cur = head    for i in range(1, len(arr)):        cur.next = ListNode(arr[i])        cur = cur.next    return headdef print_node_list(head):    while head:        print(head.val, '->', end=' ')        head = head.next    print('NULL')if __name__ == '__main__':    arr = [4, 2, 1, 3]    head = create_node_list(arr)    print_node_list(head)    solution = Solution()    result = solution.sortList(head)    print_node_list(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码 3：</p><pre class="line-numbers language-Python"><code class="language-Python">class ListNode:    def __init__(self, x):        self.val = x        self.next = None# 这里有个小陷阱，如果遇到问题，不要着急，代码调试就好了class Solution:    def sortList(self, head: ListNode) -> ListNode:        if head is None or head.next is None:            return head        # 玄机在这里，如果非要用 while fast and fast.next:        # 让快指针先走一步，以避免死循环        slow = head        fast = head.next        while fast and fast.next:            slow = slow.next            fast = fast.next.next        new_head = slow.next        slow.next = None        lnode = self.sortList(head)        rnode = self.sortList(new_head)        return self.__merge_two_sorted_list(lnode, rnode)    def __merge_two_sorted_list(self, head1, head2):        if head1 is None:            return head2        if head2 is None:            return head1        if head1.val < head2.val:            head1.next = self.__merge_two_sorted_list(head1.next, head2)            return head1        else:            head2.next = self.__merge_two_sorted_list(head1, head2.next)            return head2def create_node_list(arr):    head = ListNode(arr[0])    cur = head    for i in range(1, len(arr)):        cur.next = ListNode(arr[i])        cur = cur.next    return headdef print_node_list(head):    while head:        print(head.val, '->', end=' ')        head = head.next    print('NULL')if __name__ == '__main__':    arr = [4, 2, 1, 3]    head = create_node_list(arr)    print_node_list(head)    solution = Solution()    result = solution.sortList(head)    print_node_list(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>class ListNode {    int val;    ListNode next;    ListNode(int x) {        val = x;    }    ListNode(int[] nums) {        ListNode currNode = this;        currNode.val = nums[0];        for (int i = 1; i &lt; nums.length; i++) {            currNode.next = new ListNode(nums[i]);            currNode = currNode.next;        }    }    @Override    public String toString() {        ListNode currNode = this;        StringBuilder s = new StringBuilder();        while (currNode != null) {            s.append(currNode.val);            s.append(&quot; -&gt; &quot;);            currNode = currNode.next;        }        s.append(&quot;NULL&quot;);        return s.toString();    }}</code></pre><p>伪代码</p><pre><code>current = dummy.next;tail = dummy;for (step = 1; step &lt; length; step *= 2) {    while (current) {        // left-&gt;@-&gt;@-&gt;@-&gt;@-&gt;@-&gt;@-&gt;null        left = current;        // left-&gt;@-&gt;@-&gt;null   right-&gt;@-&gt;@-&gt;@-&gt;@-&gt;null        right = cut(current, step); // 将 current 切掉前 step 个头切下来。        // left-&gt;@-&gt;@-&gt;null   right-&gt;@-&gt;@-&gt;null   current-&gt;@-&gt;@-&gt;null        current = cut(right, step); // 将 right 切掉前 step 个头切下来。        // dummy.next -&gt; @-&gt;@-&gt;@-&gt;@-&gt;null，最后一个节点是 tail，始终记录        //                        ^        //                        tail        tail.next = merge(left, right);        while (tail-&gt;next) tail = tail-&gt;next; // 保持 tail 为尾部    }}</code></pre><p>作者：ivan_allen<br>链接：<a href="https://leetcode-cn.com/problems/two-sum/solution/148-pai-xu-lian-biao-bottom-to-up-o1-kong-jian-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/solution/148-pai-xu-lian-biao-bottom-to-up-o1-kong-jian-by-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>好了，下面是比较正式的代码。</p><pre><code>class Solution {public:    ListNode* sortList(ListNode* head) {        ListNode dummyHead(0);        dummyHead.next = head;        auto p = head;        int length = 0;        while (p) {            ++length;            p = p-&gt;next;        }        for (int size = 1; size &lt; length; size &lt;&lt;= 1) {            auto cur = dummyHead.next;            auto tail = &amp;dummyHead;            while (cur) {                auto left = cur;                auto right = cut(left, size); // left-&gt;@-&gt;@ right-&gt;@-&gt;@-&gt;@...                cur = cut(right, size); // left-&gt;@-&gt;@ right-&gt;@-&gt;@  cur-&gt;@-&gt;...                tail-&gt;next = merge(left, right);                while (tail-&gt;next) {                    tail = tail-&gt;next;                }            }        }        return dummyHead.next;    }    ListNode* cut(ListNode* head, int n) {        auto p = head;        while (--n &amp;&amp; p) {            p = p-&gt;next;        }        if (!p) return nullptr;        auto next = p-&gt;next;        p-&gt;next = nullptr;        return next;    }    ListNode* merge(ListNode* l1, ListNode* l2) {        ListNode dummyHead(0);        auto p = &amp;dummyHead;        while (l1 &amp;&amp; l2) {            if (l1-&gt;val &lt; l2-&gt;val) {                p-&gt;next = l1;                p = l1;                l1 = l1-&gt;next;                   } else {                p-&gt;next = l2;                p = l2;                l2 = l2-&gt;next;            }        }        p-&gt;next = l1 ? l1 : l2;        return dummyHead.next;    }};</code></pre><p>作者：ivan_allen<br>链接：<a href="https://leetcode-cn.com/problems/two-sum/solution/148-pai-xu-lian-biao-bottom-to-up-o1-kong-jian-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/solution/148-pai-xu-lian-biao-bottom-to-up-o1-kong-jian-by-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="练习3：LeetCode-第-148-题：单链表的排序，使用归并排序"><a href="#练习3：LeetCode-第-148-题：单链表的排序，使用归并排序" class="headerlink" title="练习3：LeetCode 第 148 题：单链表的排序，使用归并排序"></a>练习3：LeetCode 第 148 题：单链表的排序，使用归并排序</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="noopener">148. Sort List</a> ，中文网址：<a href="https://leetcode-cn.com/problems/sort-list/description/" target="_blank" rel="noopener">148. 排序链表</a> 。</p><blockquote><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p><strong>示例 1:</strong></p><pre><code>输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre></blockquote><p>写一个排序算法，用 $O(n\log n)$ 的时间复杂度为一个链表进行排序。</p><p>对于单链表而言，归并排序是一个不错的选择。</p><p>思路1：自顶向下的归并排序。</p><p>注意1：特别注意下面这么一段：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> fast<span class="token punctuation">.</span>next <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">:</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li>这个方法走到这里，因为有前面的特判，所以至少得有 $2$ 个结点，才可以排序。而<strong>取中点的操作，只有在“下个结点”和“下下结点”</strong>都存在的时候，才能这么做；</li><li>看看这个循环的循环体就明白了。</li></ul><p>注意2：找到中间结点以后，记得把链表“从中切断”，这是符合逻辑的。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># 找到中点</span>        slow <span class="token operator">=</span> head        fast <span class="token operator">=</span> head        <span class="token keyword">while</span> fast<span class="token punctuation">.</span>next <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        head2 <span class="token operator">=</span> slow<span class="token punctuation">.</span>next        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> None        lnode <span class="token operator">=</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        rnode <span class="token operator">=</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head2<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>lnode<span class="token punctuation">,</span> rnode<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__merge_two_sorted_list</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head1<span class="token punctuation">,</span> head2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head1 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head2        <span class="token keyword">if</span> head2 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head1        <span class="token keyword">if</span> head1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> head2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            head1<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>head1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head2<span class="token punctuation">)</span>            <span class="token keyword">return</span> head1        <span class="token keyword">else</span><span class="token punctuation">:</span>            head2<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>head1<span class="token punctuation">,</span> head2<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            <span class="token keyword">return</span> head2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种写法：</p><p>特别注意，如果是</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> fast <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">:</span>    p <span class="token operator">=</span> slow    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种取法，<strong>遇到两个结点的时候，slow 会向前走一步，但是截断得在 slow 结点之前，否则会进入死循环，按照我说的，画一个两个结点的链表就很清楚了</strong>。</p><p>遇到死循环的时候，不要着急，还有耐心 debug，分析代码运行流程，很多时候问题就迎刃而解了。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token comment" spellcheck="true"># 这里有个小陷阱，如果遇到问题，不要着急，代码调试就好了</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># 找到中点</span>        slow <span class="token operator">=</span> head        fast <span class="token operator">=</span> head        <span class="token keyword">while</span> fast <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            p <span class="token operator">=</span> slow            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        p<span class="token punctuation">.</span>next <span class="token operator">=</span> None        <span class="token comment" spellcheck="true"># print_node_list(head)</span>        <span class="token comment" spellcheck="true"># print_node_list(head2)</span>        lnode <span class="token operator">=</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        rnode <span class="token operator">=</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>slow<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>lnode<span class="token punctuation">,</span> rnode<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__merge_two_sorted_list</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head1<span class="token punctuation">,</span> head2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head1 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head2        <span class="token keyword">if</span> head2 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head1        <span class="token keyword">if</span> head1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> head2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            head1<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>head1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head2<span class="token punctuation">)</span>            <span class="token keyword">return</span> head1        <span class="token keyword">else</span><span class="token punctuation">:</span>            head2<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>head1<span class="token punctuation">,</span> head2<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            <span class="token keyword">return</span> head2<span class="token keyword">def</span> <span class="token function">create_node_list</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    head <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    cur <span class="token operator">=</span> head    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next    <span class="token keyword">return</span> head<span class="token keyword">def</span> <span class="token function">print_node_list</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> head<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token string">'->'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'NULL'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>    head <span class="token operator">=</span> create_node_list<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    print_node_list<span class="token punctuation">(</span>head<span class="token punctuation">)</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span>    print_node_list<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：自底向上的归并排序。</p><p>我以前写了一个示意图，可以点<a href="https://liweiwei1419.github.io/leetcode-solution/leetcode-0148-sort-list/" target="_blank" rel="noopener">这里</a>看，思想还是很简单的。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 147 题：对链表进行插入排序（中等）</title>
      <link href="/leetcode-algo/2017/08/17/leetcode-algo/0147-insertion-sort-list/"/>
      <url>/leetcode-algo/2017/08/17/leetcode-algo/0147-insertion-sort-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-147-题：对链表进行插入排序（中等）"><a href="#「力扣」第-147-题：对链表进行插入排序（中等）" class="headerlink" title="「力扣」第 147 题：对链表进行插入排序（中等）"></a>「力扣」第 147 题：对链表进行插入排序（中等）</h2><ul><li><p>英文网址：<a href="https://leetcode.com/problems/insertion-sort-list/description/" target="_blank" rel="noopener">147. Insertion Sort List</a> ；</p></li><li><p>中文网址：<a href="https://leetcode-cn.com/problems/insertion-sort-list/description/" target="_blank" rel="noopener">147. 对链表进行插入排序</a> 。</p></li></ul><p>我写的题解地址：<a href="https://leetcode-cn.com/problems/insertion-sort-list/solution/chuan-zhen-yin-xian-by-liweiwei1419-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insertion-sort-list/solution/chuan-zhen-yin-xian-by-liweiwei1419-2/</a></p><blockquote><p>对链表进行插入排序。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"></p><p>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p><p>插入排序算法：</p><ol><li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li><li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li><li>重复直到所有输入数据插入完为止。</li></ol><p>示例 1：</p><pre><code>输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4</code></pre><p>示例 2：</p><pre><code>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">insertionSortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 第 1 步：先把下一个结点存一下，下一次遍历就从 nextNode 开始</span>            ListNode nextNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第 2 步：需要找到要插入的位置的前一个结点的位置，这需要从前向后找，这一点非常不一样</span>            <span class="token comment" spellcheck="true">// 每一次 preNode 都得从头开始</span>            ListNode preNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 因为有 preNode.next ，所以应该先判断非空</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>preNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> preNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> curNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 严格小于就可以了，没有必要移到小于等于的最后一个，不用保证稳定性</span>                preNode <span class="token operator">=</span> preNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 退出循环的时候，preNode.next.val >= curNode.val</span>            <span class="token comment" spellcheck="true">// 第 3 步：穿针引线</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> preNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            preNode<span class="token punctuation">.</span>next <span class="token operator">=</span> curNode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第 4 步：循环变量更新</span>            curNode <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution3 solution3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode insertionSortList <span class="token operator">=</span> solution3<span class="token punctuation">.</span><span class="token function">insertionSortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>insertionSortList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度： $O(N^2)$ ，这里 $N$ 表示链表结点的个数，对于每个结点找合适位置时，最多需要遍历 $O(N)$ 次。</li><li>空间复杂度：$O(1)$。</li></ul><p>分析：这道题的题意我们感觉有那么些误导我们的意思，我们能想到从头开始找结点应该插入的位置，但感觉这种做法又不像插入排序。解决这个问题不要太死板，不要怕麻烦我觉得是解这道问题的关键（这句话感觉跟没说一个样，^_^）。</p><ol><li>插入排序每次会将遍历到的一个元素插入到已经排序的部分；</li><li>熟悉插入排序的朋友们都知道，这种插入过程是从后向前的，但是对于单链表来说，只保存了当前结点到下一个结点的 next 指针，并没有保存从当前结点到上一个节点的 pre 指针；</li><li>我们就要变换思路了，每次都要从链表的第 1 个元素开始，找到新遍历的节点适合插入的位置，进行穿针引线；</li><li>具体来说对于单链表的第 1 个元素，涉及到头结点的操作的时候，我们的做法往往是设计一个虚拟头结点，以简化编码。<br> 综上所述，想清楚上面的问题，写出正确的代码应该不是难事。</li></ol><p>为一个链表实现插入排序。</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/147-1.jpg" alt="LeetCode 第 147 题：单链表的插入排序-1"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/147-2.jpg" alt="LeetCode 第 147 题：单链表的插入排序-2"></p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">insertionSortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先写最特殊的情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode pre<span class="token punctuation">;</span>        ListNode next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果遍历下去，是顺序排列的话，那最简单了，curNode 指针向前就行了</span>            <span class="token comment" spellcheck="true">// 这一步是一个循环的过程</span>            <span class="token comment" spellcheck="true">// 暂存当前结点的下一结点</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curNode<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 下面针对上一步跳出循环的两个条件进行特殊处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果后面没有元素了，那就说明，此时链表已经有序，可以结束我们的排序逻辑了</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 否则就一定满足 curNode.val > curNode.next.val; 为真</span>                <span class="token comment" spellcheck="true">// pre 打回到起点</span>                pre <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>                next <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 把 pre 挪到可以放置 next 结点的上一个位置</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 穿针引线的 3 个步骤，请见图 https://liweiwei1419.github.io/images/leetcode-solution/147-1.jpg</span>                <span class="token comment" spellcheck="true">// 穿针引线步骤 1</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 穿针引线步骤 2</span>                next<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 穿针引线步骤 2</span>                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode insertionSortList <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">insertionSortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>insertionSortList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等价写法：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">insertionSortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 虚拟头结点</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode preNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用于遍历的指针</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 没有这一步：dummyNode.next = head;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 这一步是找到一个正确的位置插入，只要比 curNode 的值小，都应该跳过</span>            <span class="token comment" spellcheck="true">// 直到遇到第 1 个大于等于它的元素</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>preNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> preNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> curNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                preNode <span class="token operator">=</span> preNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 应该把 node 放在 pre 的下一个</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> preNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            preNode<span class="token punctuation">.</span>next <span class="token operator">=</span> curNode<span class="token punctuation">;</span>            preNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>            curNode <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution2 solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode insertionSortList <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">insertionSortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>insertionSortList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 146 题：LRU 缓存机制（中等）</title>
      <link href="/leetcode-algo/2017/08/16/leetcode-algo/0146-lru-cache/"/>
      <url>/leetcode-algo/2017/08/16/leetcode-algo/0146-lru-cache/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-146-题：LRU-缓存机制（中等）"><a href="#「力扣」第-146-题：LRU-缓存机制（中等）" class="headerlink" title="「力扣」第 146 题：LRU 缓存机制（中等）"></a>「力扣」第 146 题：LRU 缓存机制（中等）</h2><ul><li><a href="https://leetcode-cn.com/problems/lru-cache" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/lru-cache/solution/ha-xi-biao-shuang-xiang-lian-biao-java-by-liweiw-2/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>进阶:</p><p>你是否可以在 $O(1)$ 时间复杂度内完成这两种操作？</p><p><strong>示例</strong>：</p><pre><code>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1);       // 返回  1cache.put(3, 3);    // 该操作会使得密钥 2 作废cache.get(2);       // 返回 -1 (未找到)cache.put(4, 4);    // 该操作会使得密钥 1 作废cache.get(1);       // 返回 -1 (未找到)cache.get(3);       // 返回  3cache.get(4);       // 返回  4</code></pre></blockquote><p>题目意思：缓存是有限的，在缓存满的时候，删除哪些元素，就有不同的缓存删除策略。</p><h3 id="LRU-（Least-Recently-Used）缓存机制"><a href="#LRU-（Least-Recently-Used）缓存机制" class="headerlink" title="LRU （Least Recently Used）缓存机制"></a>LRU （Least Recently Used）缓存机制</h3><ul><li>在缓存满的时候，删除缓存里最久未使用的数据，然后再放入新元素；</li><li>数据的访问时间很重要，<strong>访问时间距离现在最近</strong>，就最不容易被删除。</li></ul><p>核心思想：在删除元素的时候，只看在缓存里的存在时间。</p><p>另一种缓存删除机制是 LFU （Least Frequently Used，最不经常使用）缓存机制，这道题是「力扣」第 460 题：<a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">LFU 缓存</a>。算法的设计思想其实是一样的。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>由于题目的时间复杂度要求 $O(1)$，空间肯定不能省，存取数据时间性能最好的就是哈希表，因此底层的数据结构一定是一个哈希表；</li><li>根据题目意思，访问某个数据，时间优先级得提前，还有删除末尾结点的需求，<strong>这样的数据结构得在头尾访问数据最快，这种数据结构是「双向链表」</strong>；</li><li>「链表」结点需要记录：1、value，2、key（在哈希表里删除的时候用得上），3、前驱结点引用，4、后继结点引用。</li></ul><p>这样一套设计下来，题目中要求的操作就是 $O(1)% 了。</p><p>下面是内存结构示意图：</p><p><img src="https://pic.leetcode-cn.com/9f81c68ea2fcc02af72dcc30987984d8457e7f1260762810f99c97cb88f0b0a7-image.png" alt="image.png"></p><p>编码说明：</p><ul><li>应该先弄清楚思路，再编码；</li><li>可以设计成「双向链表」的尾部存储较新访问的结点，头部是当前频次最旧的结点。双向链表在结构上是对称的，编码的时候注意保持语义一致；</li><li>「双向链表」的常见操作是使用两个虚拟结点，一个访问头部最快，另一个访问尾部最快，这个技巧其实在「单链表」中我们已经见过，叫「哨兵结点」；</li><li>链表中的相关操作建议画图去思考实现，否则凭空想象一些指针变量的指向操作容易出错；</li><li>在一些操作中相同的操作，应该考虑抽取成公用的方法；</li><li>在编码完成以后，需要注意调试，这一步是很花时间的，也没有过多的技巧，添加打印输出语句。</li></ul><p>注意：</p><ol><li>以下代码由于本人水平有限，封装还不够好，仅供参考；</li><li>下面的代码细节特别多，读者<strong>浏览即可，不建议模仿</strong>，应该尝试自己编写完成，相信是一个不错的编程练习；</li><li>Java 里的 <code>LinkedList</code> 就是双向链表，这里只是为了练习，定制化一些操作，因此手写。</li></ol><p><strong>参考代码</strong>：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.HashMap;import java.util.Map;public class LRUCache {    private Map<Integer, ListNode> map;    /**     * 双链表结点类     */    private class ListNode {        private Integer key;        private Integer value;        /**         * 前驱结点 precursor         */        private ListNode pre;        /**         * 后继结点 successor（写成 next 是照顾单链表的表示习惯）         */        private ListNode next;        public ListNode() {        }        public ListNode(Integer key, Integer value) {            this.key = key;            this.value = value;        }    }    private int capacity;    /**     * 虚拟头结点没有前驱     */    private ListNode dummyHead;    /**     * 虚拟尾结点没有后继     */    private ListNode dummyTail;    public LRUCache(int capacity) {        map = new HashMap<>(capacity);        this.capacity = capacity;        dummyHead = new ListNode(-1, -1);        dummyTail = new ListNode(-1, -1);        // 初始化链表为 head <-> tail        dummyHead.next = dummyTail;        dummyTail.pre = dummyHead;    }    /**     * 如果存在，把当前结点移动到双向链表的头部     *     * @param key     * @return     */    public int get(int key) {        if (map.containsKey(key)) {            ListNode node = map.get(key);            int val = node.value;            // 把当前 node 移动到双向链表的头部            moveNode2Head(key);            return val;        } else {            return -1;        }    }    /**     * 如果哈希表的容量满了，就要删除一个链表末尾元素，然后在链表头部插入新元素     *     * @param key     * @param value     */    public void put(int key, int value) {        if (map.containsKey(key)) {            // 1、更新 value            map.get(key).value = value;            // 2、把当前 node 移动到双向链表的头部            moveNode2Head(key);            return;        }        // 放元素的操作是一样的        if (map.size() == capacity) {            // 如果满了            ListNode oldTail = removeTail();            // 设计 key 就是为了在这里删除            map.remove(oldTail.key);        }        // 然后添加元素        ListNode newNode = new ListNode(key, value);        map.put(key, newNode);        addNode2Head(newNode);    }    // 为了突出主干逻辑，下面是 3 个公用的方法    /**     * 删除双链表尾部结点     */    private ListNode removeTail() {        ListNode oldTail = dummyTail.pre;        ListNode newTail = oldTail.pre;        // 两侧结点建立连接        newTail.next = dummyTail;        dummyTail.pre = newTail;        // 释放引用        oldTail.pre = null;        oldTail.next = null;        return oldTail;    }    /**     * 把当前 key 指向的结点移到双向链表的头部     *     * @param key     */    private void moveNode2Head(int key) {        // 1、先把 node 拿出来        ListNode node = map.get(key);        // 2、原来 node 的前驱和后继接上        node.pre.next = node.next;        node.next.pre = node.pre;        // 3、再把 node 放在末尾        addNode2Head(node);    }    /**     * 在双链表的头部新增一个结点     *     * @param newNode     */    private void addNode2Head(ListNode newNode) {        // 1、当前头结点        ListNode oldHead = dummyHead.next;        // 2、末尾结点的后继指向新结点        oldHead.pre = newNode;        // 3、设置新结点的前驱和后继        newNode.pre = dummyHead;        newNode.next = oldHead;        // 4、更改虚拟头结点的后继结点        dummyHead.next = newNode;    }    public static void main(String[] args) {        LRUCache cache = new LRUCache(2);        cache.put(1, 1);        cache.put(2, 2);        System.out.println(cache.map.keySet());        int res1 = cache.get(1);        System.out.println(res1);        cache.put(3, 3);        int res2 = cache.get(2);        System.out.println(res2);        int res3 = cache.get(3);        System.out.println(res3);        cache.put(4, 4);        System.out.println(cache.map.keySet());        int res4 = cache.get(1);        System.out.println(res4);        int res5 = cache.get(3);        System.out.println(res5);        int res6 = cache.get(4);        System.out.println(res6);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 143 题：重排链表（中等）</title>
      <link href="/leetcode-algo/2017/08/15/leetcode-algo/0143-reorder-list/"/>
      <url>/leetcode-algo/2017/08/15/leetcode-algo/0143-reorder-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-143-题：重排链表（中等）"><a href="#「力扣」第-143-题：重排链表（中等）" class="headerlink" title="「力扣」第 143 题：重排链表（中等）"></a>「力扣」第 143 题：重排链表（中等）</h2><p>链接：<a href="https://leetcode-cn.com/problems/reorder-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reorder-list</a></p><blockquote><p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>L<strong>n<em>→</em>L<em>1→</em>L</strong>n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><pre><code>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</code></pre><p><strong>示例 2:</strong></p><pre><code>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</code></pre></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author liwei * @date 18/7/5 上午9:36 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode anotherHead <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤1：从中间截断链表</span>        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤2：反转链表的后半截</span>        ListNode reverseList <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>anotherHead<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤3：合并两个链表</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> reverseList<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> ListNode <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>ListNode head1<span class="token punctuation">,</span> ListNode head2<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// k % 2 == 0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            head1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>head1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head2<span class="token punctuation">,</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> head1<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            head2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span> head2<span class="token punctuation">.</span>next<span class="token punctuation">,</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> head2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode preNode <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode nextNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> preNode<span class="token punctuation">;</span>            preNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>            curNode <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> preNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution2 solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        solution2<span class="token punctuation">.</span><span class="token function">reorderList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 142 题：环形链表 II（中等）</title>
      <link href="/leetcode-algo/2017/08/14/leetcode-algo/0142-linked-list-cycle-ii/"/>
      <url>/leetcode-algo/2017/08/14/leetcode-algo/0142-linked-list-cycle-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-142-题：环形链表-II（中等）"><a href="#「力扣」第-142-题：环形链表-II（中等）" class="headerlink" title="「力扣」第 142 题：环形链表 II（中等）"></a>「力扣」第 142 题：环形链表 II（中等）</h2><p>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a></p><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 1：</p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p>示例 2：</p><pre><code>输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 3：</strong></p><pre><code>输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>        next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 注意：不要习惯性把 head 返回回去</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 起点要一样，这里第 141 题的结论</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意这种写法，因为快指针一次走两步，</span>        <span class="token comment" spellcheck="true">// 所以要看它下一个结点以及下下一个结点是否为空</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 特判，如果只是因为链表不存在环，那就返回空，因为既然不存在环，肯定没有重复结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">==</span> null <span class="token operator">||</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        slow <span class="token operator">=</span> head        fast <span class="token operator">=</span> head        <span class="token keyword">while</span> fast<span class="token punctuation">.</span>next <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            <span class="token keyword">if</span> fast <span class="token operator">==</span> slow<span class="token punctuation">:</span>                <span class="token keyword">break</span>        <span class="token keyword">if</span> fast<span class="token punctuation">.</span>next <span class="token keyword">is</span> None <span class="token operator">or</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        slow <span class="token operator">=</span> head        <span class="token keyword">while</span> slow <span class="token operator">!=</span> fast<span class="token punctuation">:</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 141 题：环形链表（简单）</title>
      <link href="/leetcode-algo/2017/08/13/leetcode-algo/0141-linked-list-cycle/"/>
      <url>/leetcode-algo/2017/08/13/leetcode-algo/0141-linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-141-题：环形链表（简单）"><a href="#「力扣」第-141-题：环形链表（简单）" class="headerlink" title="「力扣」第 141 题：环形链表（简单）"></a>「力扣」第 141 题：环形链表（简单）</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a></li></ul><blockquote><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 </p><p>示例 1：</p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>示例 2：</strong></p><pre><code>输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 3：</strong></p><pre><code>输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p><strong>进阶：</strong></p><p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p></blockquote><h3 id="方法一：直接测试"><a href="#方法一：直接测试" class="headerlink" title="方法一：直接测试"></a>方法一：直接测试</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：使用哈希表"><a href="#方法二：使用哈希表" class="headerlink" title="方法二：使用哈希表"></a>方法二：使用哈希表</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashSet<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Set<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> hashSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hashSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>curNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                hashSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 使用哈希表的方法查重肯定是可以的，但并不推荐</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        s <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        point <span class="token operator">=</span> head        <span class="token keyword">while</span> point<span class="token punctuation">:</span>            <span class="token keyword">if</span> point <span class="token keyword">in</span> s<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                s<span class="token punctuation">.</span>add<span class="token punctuation">(</span>point<span class="token punctuation">)</span>            point <span class="token operator">=</span> point<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三：并查集思想"><a href="#方法三：并查集思想" class="headerlink" title="方法三：并查集思想"></a>方法三：并查集思想</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution3</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 并查集的思路</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode nextNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> dummyNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            curNode <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法四：快慢指针"><a href="#方法四：快慢指针" class="headerlink" title="方法四：快慢指针"></a>方法四：快慢指针</h3><p>1、慢指针一次走一步、快指针一次走两步；</p><p>2、注意：快指针可以走的条件 <code>fast != null &amp;&amp; fast.next != null</code>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>        next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 慢指针一次走一步、快指针一次走两步</span>        <span class="token comment" spellcheck="true">// 注意：快指针可以走的条件 fast != null &amp;&amp; fast.next != null</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>        next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 快慢指针</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 慢指针一次走一步、快指针一次走两步</span>        <span class="token comment" spellcheck="true">// 注意：快指针可以走的条件 fast != null &amp;&amp; fast.next != null</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token comment" spellcheck="true"># 思想：快慢指针（推荐）</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        slow <span class="token operator">=</span> head        <span class="token comment" spellcheck="true"># 快指针先走一步</span>        fast <span class="token operator">=</span> head<span class="token punctuation">.</span>next        <span class="token keyword">while</span> slow <span class="token operator">!=</span> fast<span class="token punctuation">:</span>            <span class="token keyword">if</span> fast <span class="token keyword">is</span> None <span class="token operator">or</span> fast<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 这一版代码比较费解，不推荐</span>    <span class="token keyword">def</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: bool        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        slow <span class="token operator">=</span> head        fast <span class="token operator">=</span> head        <span class="token comment" spellcheck="true"># 快指针每走一步，都做了判断</span>        <span class="token keyword">while</span> fast<span class="token punctuation">:</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next            <span class="token keyword">if</span> fast<span class="token punctuation">:</span>                fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next                slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">if</span> fast <span class="token operator">==</span> slow<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 138 题：复制带随机指针的链表（中等）</title>
      <link href="/leetcode-algo/2017/08/12/leetcode-algo/0138-copy-list-with-random-pointer/"/>
      <url>/leetcode-algo/2017/08/12/leetcode-algo/0138-copy-list-with-random-pointer/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-138-题：复制带随机指针的链表（中等）"><a href="#「力扣」第-138-题：复制带随机指针的链表（中等）" class="headerlink" title="「力扣」第 138 题：复制带随机指针的链表（中等）"></a>「力扣」第 138 题：复制带随机指针的链表（中等）</h2><p>链接：<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/copy-list-with-random-pointer</a></p><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的深拷贝。 </p><p>示例：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1470150906153-2yxeznm.png" alt="img"></p><pre><code>输入：{&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:{&quot;$ref&quot;:&quot;2&quot;},&quot;val&quot;:2},&quot;random&quot;:{&quot;$ref&quot;:&quot;2&quot;},&quot;val&quot;:1}解释：节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。</code></pre><p>提示：</p><ol><li>你必须返回给定头的拷贝作为对克隆列表的引用。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 92 题：反转链表 II</title>
      <link href="/leetcode-algo/2017/08/11/leetcode-algo/0092-reverse-linked-list-ii/"/>
      <url>/leetcode-algo/2017/08/11/leetcode-algo/0092-reverse-linked-list-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-92-题：反转链表-II"><a href="#「力扣」第-92-题：反转链表-II" class="headerlink" title="「力扣」第 92 题：反转链表 II"></a>「力扣」第 92 题：反转链表 II</h2><ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/4-ge-zhi-zhen-3-ge-zhi-zhen-by-liweiwei1419/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明：<br>1 ≤ m ≤ n ≤ 链表长度。</p><p>示例：</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre></blockquote><h3 id="方法一：使用-4-个指针变量"><a href="#方法一：使用-4-个指针变量" class="headerlink" title="方法一：使用 4 个指针变量"></a>方法一：使用 4 个指针变量</h3><p>1、利用第 206 题的做法：把介于 <code>m</code> 和 <code>n</code> 的链表截取出来，反转一下，再接回去。</p><p>注意：因为涉及第 1 个结点的操作，为了避免分类讨论，常见的做法是引入虚拟头结点。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9epy68exjj314u08cmxj.jpg" alt="image-20191129104224767"></p><p>2、为此，我们需要一些指针变量，它们是 <code>m</code> 和 <code>n</code> 的边界，<code>m</code> 的前一个结点，<code>n</code> 的后一个结点。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9epy7krv6j315g0dg0ta.jpg" alt="image-20191129104329202"></p><p>3、因此，首先要遍历分别得到 <code>p1</code> 和 <code>p2</code>，然后 <code>p3</code> 和  <code>p4</code> 就可以确定了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9epyatz7wj315g0f0mxw.jpg" alt="image-20191129104638461">Java 代码：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 利用第 206 题：穿针引线</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用 4 个指针变量</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 因为有头结点有可能发生变化，使用虚拟头结点可以避免复杂的分类讨论</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode p1 <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第 1 步：从虚拟头结点走 m - 1 步，来到 m 结点的前一个结点</span>        <span class="token comment" spellcheck="true">// 建议写在 for 循环里，语义清晰</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第 2 步：从 p1 再走 n - m + 1 步，来到 n 结点</span>        ListNode p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第 3 步：切断出一个子链表（截取链表）</span>        ListNode p3 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode p4 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p1<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        p2<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第 4 步：反转子链表</span>        <span class="token function">reverseLinkedList</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第 5 步：接回到原来的链表中</span>        p1<span class="token punctuation">.</span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span>        p3<span class="token punctuation">.</span>next <span class="token operator">=</span> p4<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverseLinkedList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 也可以使用递归反转一个链表</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在循环开始之前声明，可以避免在循环中反复声明新变量</span>        ListNode next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：使用-3个指针变量"><a href="#方法二：使用-3个指针变量" class="headerlink" title="方法二：使用 3个指针变量"></a>方法二：使用 3个指针变量</h3><hr><p>以前写的笔记</p><h3 id="练习1：LeetCode-第-92-题：反转从位置-m-到-n-的链表，k-个组进行一次反转"><a href="#练习1：LeetCode-第-92-题：反转从位置-m-到-n-的链表，k-个组进行一次反转" class="headerlink" title="练习1：LeetCode 第 92 题：反转从位置 m 到 n 的链表，k 个组进行一次反转"></a>练习1：LeetCode 第 92 题：反转从位置 m 到 n 的链表，k 个组进行一次反转</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="noopener">92. Reverse Linked List II</a>  ，中文网址：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="noopener">92. 反转链表 II</a>  。</p><blockquote><p>反转一个单链表。</p><p><strong>示例:</strong></p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/414598-f83685e15724a1d7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="LeetCode 第 92 题：反转从位置 m 到 n 的链表，k 个组进行一次反转-1"></p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个虚拟的结点（dummy）</span>        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>k <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// tail 是尾巴的意思</span>        ListNode tail <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>k <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode temp <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            tail<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// pre 指针向后移动</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// System.out.println(pre.val);</span>        ListNode p <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode curNode<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curNode <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> curNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置 dummyNode 是这一类问题的一般做法</span>    ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode pre <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode cur <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        next<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种解法：来自“小吴”的动图，比较自然，但是代码写起来不够简洁。</p><p>图示：</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/0092.gif" alt="LeetCode 第 92 题：反转从位置 m 到 n 的链表，k 个组进行一次反转-2"></p><p>Python 代码：<br><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/0092.png" alt="LeetCode 第 92 题：反转从位置 m 到 n 的链表，k 个组进行一次反转-3"></p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 86 题：分隔链表（中等）</title>
      <link href="/leetcode-algo/2017/08/10/leetcode-algo/0086-partition-list/"/>
      <url>/leetcode-algo/2017/08/10/leetcode-algo/0086-partition-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-86-题：分隔链表（中等）"><a href="#「力扣」第-86-题：分隔链表（中等）" class="headerlink" title="「力扣」第 86 题：分隔链表（中等）"></a>「力扣」第 86 题：分隔链表（中等）</h2><ul><li>英文网址：<a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">86. Partition List</a> ；</li><li>中文网址：<a href="https://leetcode-cn.com/problems/partition-list/description/" target="_blank" rel="noopener">86. 分隔链表</a>。</li></ul><p>链接：<a href="https://leetcode-cn.com/problems/partition-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-list</a></p><blockquote><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p>示例：</p><pre><code>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code></pre></blockquote><p>思路：分别拿两个虚拟头结点，最后拼在一起。</p><p>![image-20191204142152454](/Users/liwei/Library/Application Support/typora-user-images/image-20191204142152454.png)Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 空间复杂度为常数的解法：穿针引线</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 空间复杂度为常数的解法：穿针引线</span>    <span class="token keyword">public</span> ListNode <span class="token function">partition</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 比 x 小的虚拟头结点</span>        ListNode dummyNodeL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 大于等于 x 的虚拟头结点</span>        ListNode dummyNodeR <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用于遍历</span>        ListNode curL <span class="token operator">=</span> dummyNodeL<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用于遍历</span>        ListNode curR <span class="token operator">=</span> dummyNodeR<span class="token punctuation">;</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            val <span class="token operator">=</span> head<span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 接在 L 的后面</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                curL<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                curL <span class="token operator">=</span> curL<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 接在 R 的后面</span>                curR<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                curR <span class="token operator">=</span> curR<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        curL<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyNodeR<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 特别注意：最后这一步不能忘记，否则会产生一个循环链表</span>        curR<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummyNodeL<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分隔链表之后："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode partition <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>partition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：（反例）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 不是穿针引线，缺点：partition 的时候复制了结点</span>    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :type x: int        :rtype: ListNode        """</span>        dummy_node_l <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy_node_r <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cur_l <span class="token operator">=</span> dummy_node_l        cur_r <span class="token operator">=</span> dummy_node_r        <span class="token keyword">while</span> head <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>            val <span class="token operator">=</span> head<span class="token punctuation">.</span>val            <span class="token keyword">if</span> val <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>                cur_l<span class="token punctuation">.</span>next <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>                cur_l <span class="token operator">=</span> cur_l<span class="token punctuation">.</span>next            <span class="token keyword">else</span><span class="token punctuation">:</span>                cur_r<span class="token punctuation">.</span>next <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>val<span class="token punctuation">)</span>                cur_r <span class="token operator">=</span> cur_r<span class="token punctuation">.</span>next            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next        <span class="token comment" spellcheck="true"># 把较小的链表接在较大的链表后面，这一步容易忘记</span>        cur_l<span class="token punctuation">.</span>next <span class="token operator">=</span> dummy_node_r<span class="token punctuation">.</span>next        <span class="token keyword">return</span> dummy_node_l<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 83 题：删除排序链表中的重复元素（简单）</title>
      <link href="/leetcode-algo/2017/08/09/leetcode-algo/0083-remove-duplicates-from-sorted-list/"/>
      <url>/leetcode-algo/2017/08/09/leetcode-algo/0083-remove-duplicates-from-sorted-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-83-题：删除排序链表中的重复元素（简单）"><a href="#「力扣」第-83-题：删除排序链表中的重复元素（简单）" class="headerlink" title="「力扣」第 83 题：删除排序链表中的重复元素（简单）"></a>「力扣」第 83 题：删除排序链表中的重复元素（简单）</h2><ul><li><p>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list；" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list；</a></p></li><li><p>传送门：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list" target="_blank" rel="noopener">删除排序链表中的重复元素</a>。</p></li></ul><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><pre><code>输入: 1-&gt;1-&gt;2输出: 1-&gt;2</code></pre><p>示例 2：</p><pre><code>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3</code></pre></blockquote><h3 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h3><pre><code>// 我觉得就是细心一点，把穿针引线的细节考虑到// 因为第 1 个结点不会被删除，因此，不用设置虚拟结点// 1 -&gt; 1 -&gt; 1 -&gt; 1 -&gt; 2// cur  del       del</code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode currNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        currNode<span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            currNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            currNode <span class="token operator">=</span> currNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode currNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>currNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>currNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            currNode <span class="token operator">=</span> currNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 最后添加一个 NULL 标志表示添加到末尾了</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                ListNode deleteNode <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> deleteNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                deleteNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：依旧是穿针引线"><a href="#方法二：依旧是穿针引线" class="headerlink" title="方法二：依旧是穿针引线"></a>方法二：依旧是穿针引线</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当前和下一个结点都非空的时候才删除</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 值相同的时候考虑删除</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>val <span class="token operator">==</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                ListNode deleteNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 看看是否还可以删除</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>deleteNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> deleteNode<span class="token punctuation">.</span>val <span class="token operator">==</span> deleteNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    deleteNode <span class="token operator">=</span> deleteNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 穿针引线</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> deleteNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                deleteNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路：有序链表，相同元素最多保留 $1$ 个。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token comment" spellcheck="true"># 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</span><span class="token comment" spellcheck="true"># 【判断的条件是"下一个结点"】</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token comment" spellcheck="true"># 先判断极端条件</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        cur <span class="token operator">=</span> head        <span class="token keyword">while</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            <span class="token keyword">if</span> next<span class="token punctuation">.</span>val <span class="token operator">==</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># q 向后挪动一位</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next                next<span class="token punctuation">.</span>next <span class="token operator">=</span> None            <span class="token keyword">else</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 82 题：删除排序链表中的重复元素 II（中等）</title>
      <link href="/leetcode-algo/2017/08/08/leetcode-algo/0082-remove-duplicates-from-sorted-list-ii/"/>
      <url>/leetcode-algo/2017/08/08/leetcode-algo/0082-remove-duplicates-from-sorted-list-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-82-题：删除排序链表中的重复元素-II（中等）"><a href="#「力扣」第-82-题：删除排序链表中的重复元素-II（中等）" class="headerlink" title="「力扣」第 82 题：删除排序链表中的重复元素 II（中等）"></a>「力扣」第 82 题：删除排序链表中的重复元素 II（中等）</h2><p>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii；" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii；</a></p><p>传送门：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a>。</p><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p>示例 1:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5</code></pre><p>示例 2:</p><pre><code>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3</code></pre></blockquote><h3 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 只要涉及头结点的操作，设置虚拟头结点避免对链表第 1 个结点的分类讨论</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果接连两个结点的 val 相等，至少要把它们都删掉</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 要删除的起点至少应该是当前判断相同的结点的第 2 个</span>                ListNode delNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果后面还有相同的结点，delNode 后移一位，即 delNode 应该是指向相同的结点的最后一个</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>delNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> delNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    delNode <span class="token operator">=</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                delNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键：要两个两个一起判断。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这里我们要清楚，例如 1 1 2 3 ,头结点也是有可能被删除的，所以要设置虚拟头结点</span>        <span class="token comment" spellcheck="true">// 只要涉及头结点的操作，我们都设立虚拟头结点</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 题目要求的删除结点这个操作是站在被删除结点前面的</span>        <span class="token comment" spellcheck="true">// 所以循环可以继续的条件应该这样写</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果接连两个结点的 val 相等，至少要把它们都删掉</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 要删除的起点至少应该是当前判断相同的结点的第 2 个</span>                ListNode delNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果后面还有相同的结点，delNode 后移一位，即 delNode 应该是指向相同的结点的最后一个</span>                <span class="token comment" spellcheck="true">// 注意：这里得用循环，例如： 1 2 2 2 2 2 2 2 2 3 3 3</span>                <span class="token comment" spellcheck="true">// 得让 delNode 结点挪到最后一个 2 上</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>delNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> delNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    delNode <span class="token operator">=</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 接下来把有重复的链表段删除就可以了</span>                <span class="token comment" spellcheck="true">// 1        2   2   2         3</span>                <span class="token comment" spellcheck="true">// curNode          delNode</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                delNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 否则向前走一步</span>                curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution2 solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode deleteDuplicates <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>deleteDuplicates<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head        cur <span class="token operator">=</span> dummy        <span class="token keyword">while</span> cur<span class="token punctuation">.</span>next <span class="token operator">and</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 继续往后看，有没有相等的元素</span>                <span class="token comment" spellcheck="true"># del_node 至少删掉它</span>                del_node <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next                <span class="token keyword">while</span> del_node<span class="token punctuation">.</span>next <span class="token operator">and</span> del_node<span class="token punctuation">.</span>val <span class="token operator">==</span> del_node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                    del_node <span class="token operator">=</span> del_node<span class="token punctuation">.</span>next                <span class="token comment" spellcheck="true"># 开始删除操作</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> del_node<span class="token punctuation">.</span>next                del_node<span class="token punctuation">.</span>next <span class="token operator">=</span> None            <span class="token keyword">else</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 61 题：旋转链表（中等）</title>
      <link href="/leetcode-algo/2017/08/07/leetcode-algo/0061-rotate-list/"/>
      <url>/leetcode-algo/2017/08/07/leetcode-algo/0061-rotate-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-61-题：旋转链表（中等）"><a href="#「力扣」第-61-题：旋转链表（中等）" class="headerlink" title="「力扣」第 61 题：旋转链表（中等）"></a>「力扣」第 61 题：旋转链表（中等）</h2><ul><li>英文网址：<a href="https://leetcode.com/problems/rotate-list/description/" target="_blank" rel="noopener">61. Rotate List</a> ；</li><li>中文网址：<a href="https://leetcode-cn.com/problems/rotate-list/description/" target="_blank" rel="noopener">61. 旋转链表</a> 。</li></ul><p>链接：<a href="https://leetcode-cn.com/problems/rotate-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-list</a></p><p>我写的题解地址：<a href="https://leetcode-cn.com/problems/rotate-list/solution/chuan-zhen-yin-xian-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-list/solution/chuan-zhen-yin-xian-by-liweiwei1419/</a></p><blockquote><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1：</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><p>示例 2：</p><pre><code>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</code></pre></blockquote><p>思路：问题本身不难，但是要处理一些细节。</p><p>1、一定要先求出链表的总长度；</p><p>2、求得总长度的时候，顺便标记好末尾结点，并且把末尾结点的 next 指针指到头结点去，形成环，否则容易出现空指针异常；</p><p>3、到底多少 pre 指针还要走多少步，举 1 到 2 个具体的例子带进去就知道了。</p><p>关键：画图分析穿针引线的步骤。这道题的标签或许定为“简单”会更合适一点。</p><p><img src="https://pic.leetcode-cn.com/0d3f7795cfae2afa8d4145f66216ba837f72ca08d86ecbc010ad1ae9e66696c2-image.png" alt="image.png"></p><p><strong>参考代码</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">class ListNode {    int val;    ListNode next;    ListNode(int x) {        val = x;    }    public ListNode(int[] nums) {        if (nums == null || nums.length == 0) {            throw new IllegalArgumentException("arr can not be empty");        }        this.val = nums[0];        ListNode curr = this;        for (int i = 1; i < nums.length; i++) {            curr.next = new ListNode(nums[i]);            curr = curr.next;        }    }    @Override    public String toString() {        StringBuilder s = new StringBuilder();        ListNode cur = this;        while (cur != null) {            s.append(cur.val ).append(" -> ");            cur = cur.next;        }        s.append("NULL");        return s.toString();    }}// 关键在于边界条件的讨论，和代码调试public class Solution {    public ListNode rotateRight(ListNode head, int k) {        // 特判        if (head == null || head.next == null || k == 0) {            return head;        }        // 第 1 步：先要知道链表有多少个结点        int n = 1;        ListNode fastNode = head;        while (fastNode.next != null) {            fastNode = fastNode.next;            n++;        }        // 此时 fastNode 到末尾结点        k = k % n;        if (k == 0) {            return head;        }        // 第 2 步：找到倒数第 k 个结点，走 n - k - 1 步        ListNode slowNode = head;        for (int i = 0; i < n - k - 1; i++) {            slowNode = slowNode.next;        }        // 第 3 步：穿针引线        ListNode newHead = slowNode.next;        // 先把尾部接到开头        fastNode.next = head;        // 再切断原来的连接        slowNode.next = null;        return newHead;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass Solution:    def rotateRight(self, head: ListNode, k: int) -> ListNode:        # 特判        if head is None or head.next is None or k <= 0:            return head        # 先看链表有多少元素        node = head        # 先数这个链表的长度        counter = 1        while node.next:            node = node.next            counter += 1        k = k % counter        if k == 0:            return head        node.next = head        node = head        # 可以取一些极端的例子找到规律        # counter - k - 1        for _ in range(counter - k - 1):            node = node.next        new_head = node.next        node.next = None        return new_head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 25 题：两个数相加（中等）</title>
      <link href="/leetcode-algo/2017/08/06/leetcode-algo/0025-reverse-nodes-in-k-group/"/>
      <url>/leetcode-algo/2017/08/06/leetcode-algo/0025-reverse-nodes-in-k-group/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-25-题：K-个一组翻转链表（困难）"><a href="#「力扣」第-25-题：K-个一组翻转链表（困难）" class="headerlink" title="「力扣」第 25 题：K 个一组翻转链表（困难）"></a>「力扣」第 25 题：K 个一组翻转链表（困难）</h2><ul><li>英文网址：<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="noopener">25. Reverse Nodes in k-Group</a> ；</li><li>中文网址：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="noopener">25. k个一组翻转链表</a> 。</li></ul><blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例 :</p><pre><code>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</code></pre><p>说明 :</p><ul><li>你的算法只能使用常数的额外空间。</li><li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li></ul></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用递归写法的话，先考虑特殊情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 探测长度的结点</span>        ListNode tempNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">int</span> curK <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tempNode <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curK <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curK<span class="token operator">--</span><span class="token punctuation">;</span>            tempNode <span class="token operator">=</span> tempNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curK <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 下面开始反转</span>            ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>            ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ListNode nextNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>                pre <span class="token operator">=</span> curNode<span class="token punctuation">;</span>                curNode <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> pre<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 参考资料：https://blog.csdn.net/weiyongle1996/article/details/78473055</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用递归写法的话，先考虑特殊情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 探测长度的结点</span>        ListNode tempNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">int</span> curK <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tempNode <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curK <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curK<span class="token operator">--</span><span class="token punctuation">;</span>            tempNode <span class="token operator">=</span> tempNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果够数了，先考虑反转</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curK <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 下面开始反转</span>            ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>            ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ListNode nextNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>                pre <span class="token operator">=</span> curNode<span class="token punctuation">;</span>                curNode <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> pre<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode reverseKGroup <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">reverseKGroup</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reverseKGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」 第 24 题：两两交换链表中的结点</title>
      <link href="/leetcode-algo/2017/08/05/leetcode-algo/0024-swap-nodes-in-pairs/"/>
      <url>/leetcode-algo/2017/08/05/leetcode-algo/0024-swap-nodes-in-pairs/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」-第-24-题：两两交换链表中的结点"><a href="#「力扣」-第-24-题：两两交换链表中的结点" class="headerlink" title="「力扣」 第 24 题：两两交换链表中的结点"></a>「力扣」 第 24 题：两两交换链表中的结点</h2><p>英文网址：<a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">24. Swap Nodes in Pairs</a> ；</p><p>中文网址：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a> 。</p><p>我写的题解：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/chuan-zhen-yin-xian-di-gui-by-liweiwei1419-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/chuan-zhen-yin-xian-di-gui-by-liweiwei1419-2/</a></p><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例</strong>：</p><pre><code>给定 1 -&gt; 2 -&gt; 3 -&gt; 4, 你应该返回 2 -&gt; 1 -&gt; 4 -&gt; 3.</code></pre><p><strong>说明:</strong></p><ul><li>你的算法只能使用常数的额外空间。</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li></ul></blockquote><p>穿针引线和递归。</p><h3 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9o535qi8dj30u01404qp.jpg" alt="image-20191129143317788"></p><p>Java 代码：用 3 个指针</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 这里设置 dummyNode 是为了处理头结点的特殊情况</span>        <span class="token comment" spellcheck="true">// 使得头结点和非头结点可以统一处理</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 重新初始化 p1 和 p2</span>            ListNode p1 <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            ListNode p2 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// "穿针引线"的步骤就 3 步</span>            p1<span class="token punctuation">.</span>next <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 循环变量更新</span>            curNode <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 给定 1->2->3->4, 你应该返回 2->1->4->3.</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode swapPairs <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">swapPairs</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>swapPairs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：用 4 个指针</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        ListNode p1<span class="token punctuation">;</span>        ListNode p2<span class="token punctuation">;</span>        ListNode nextNode<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p1 <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 先保存一下</span>            nextNode <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 穿针引线</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span>            p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>            p1<span class="token punctuation">.</span>next <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 特别注意，下一轮 curNode 应该站在 p1</span>            curNode <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 给定 1->2->3->4, 你应该返回 2->1->4->3.</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode swapPairs <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">swapPairs</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>swapPairs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p>Java 代码：如果使用递归的方法，就特别简单。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode p2 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode newHead <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 下面这两行代码可以交换</span>        p1<span class="token punctuation">.</span>next <span class="token operator">=</span> newHead<span class="token punctuation">;</span>        p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token keyword">return</span> p2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 递归处理</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没有必要设置虚拟头结点了</span>        ListNode p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode p2 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token keyword">return</span> p2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode p2 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token keyword">return</span> p2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：两种方法：1、用递归来做就特别简单；2、穿针引线比较麻烦。</p><p>解法1：穿针引线做法：设计以下 4 个引用（指针）。<br>1、成对的结点 1 ：node1<br>2、成对的结点 2 ：node2<br>3、成对的结点 1 的前驱：p<br>4、成对的结点 2 的后继：next</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 交换链表中成对的元素     * （自己把图画出来，对于指针交换的过程就好理解了）     *     * @param head     * @return     */</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode p <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode node1 <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            ListNode node2 <span class="token operator">=</span> node1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            ListNode next <span class="token operator">=</span> node2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            node1<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            node2<span class="token punctuation">.</span>next <span class="token operator">=</span> node1<span class="token punctuation">;</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span>            p <span class="token operator">=</span> node1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ListNode <span class="token function">createLinkedList</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode current <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            current<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printLinkedList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode current <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d => "</span><span class="token punctuation">,</span> current<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"NULL "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode head1 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">createLinkedList</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        solution<span class="token punctuation">.</span><span class="token function">printLinkedList</span><span class="token punctuation">(</span>head1<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode reverseHead <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">swapPairs</span><span class="token punctuation">(</span>head1<span class="token punctuation">)</span><span class="token punctuation">;</span>        solution<span class="token punctuation">.</span><span class="token function">printLinkedList</span><span class="token punctuation">(</span>reverseHead<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：以下及其以后的动图如果没有特别说明，都来自这个伟大的 GitHub 仓库：<a href="https://github.com/MisterBooo/LeetCodeAnimation/blob/master/Readme.md。" target="_blank" rel="noopener">https://github.com/MisterBooo/LeetCodeAnimation/blob/master/Readme.md。</a></p><p><img src="https://camo.githubusercontent.com/e01d0b7be8d7e51bae4135959ce54c1d9b274738/68747470733a2f2f6275636b65742d313235373132363534392e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32303138313230363136313131352e676966" alt=""></p><p>解法2：如果使用递归的方法，就特别简单。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author liwei * @date 18/7/4 下午9:42 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode p2 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode newHead <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 下面这两行代码可以交换</span>        p1<span class="token punctuation">.</span>next <span class="token operator">=</span> newHead<span class="token punctuation">;</span>        p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token keyword">return</span> p2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面这样写就更简单了：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode first <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode second <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        first<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>second<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        second<span class="token punctuation">.</span>next <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 给定 1->2->3->4, 你应该返回 2->1->4->3.</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode swapPairs <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">swapPairs</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>swapPairs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考资料：<a href="https://blog.csdn.net/Koala_Tree/article/details/81476772。" target="_blank" rel="noopener">https://blog.csdn.net/Koala_Tree/article/details/81476772。</a></p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 23 题：合并 K 个排序链表（困难）</title>
      <link href="/leetcode-algo/2017/08/04/leetcode-solution-new/merge-k-sorted-lists/"/>
      <url>/leetcode-algo/2017/08/04/leetcode-solution-new/merge-k-sorted-lists/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-23-题：合并-K-个排序链表（困难）"><a href="#「力扣」第-23-题：合并-K-个排序链表（困难）" class="headerlink" title="「力扣」第 23 题：合并 K 个排序链表（困难）"></a>「力扣」第 23 题：合并 K 个排序链表（困难）</h2><ul><li><p>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p></li><li><p>我写的题解地址：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/tan-xin-suan-fa-you-xian-dui-lie-fen-zhi-fa-python/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/tan-xin-suan-fa-you-xian-dui-lie-fen-zhi-fa-python/</a></p></li></ul><blockquote><p>合并 <code>k</code> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例：</p><pre><code>输入:[  1 -&gt; 4 -&gt; 5,  1 -&gt; 3 -&gt; 4,  2 -&gt; 6]输出: 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt;6</code></pre></blockquote><table><thead><tr><th>题目地址</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">LeetCode 第 23 题：合并K个排序链表</a></td><td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/tan-xin-suan-fa-you-xian-dui-lie-fen-zhi-fa-python/" target="_blank" rel="noopener">贪心算法、优先队列 + 分治法（Python 代码、Java 代码）</a></td></tr></tbody></table><h3 id="方法一：贪心算法、优先队列"><a href="#方法一：贪心算法、优先队列" class="headerlink" title="方法一：贪心算法、优先队列"></a>方法一：贪心算法、优先队列</h3><p>思路分析：</p><p>1、由于是 $k$ 个排序链表，那么这 $k$ 个排序的链表<strong>头结点</strong>中 <code>val</code> <strong>最小</strong>的结点就是合并以后的链表中最小的结点；</p><p>2、最小结点所在的链表的头结点就要更新了，更新成最小结点的下一个结点（如果有的话），此时还是这 $k$ 个链表，这 $k$ 个排序的链表<strong>头结点</strong>中 <code>val</code> <strong>最小</strong>的结点就是合并以后的链表中第 $2$ 小的结点。</p><p>写到这里，我想你应该差不多明白了，我们每一次都从这 $k$ 个排序的链表<strong>头结点</strong>中拿出 <code>val</code> 最小的结点“穿针引线”成新的链表，这个链表就是题目要求的“合并后的排序链表”。“局部最优，全局就最优”，这不就是贪心算法的思想吗。</p><p>这里我们举生活中的例子来理解这个思路。</p><blockquote><p>假设你是一名体育老师，有 $3$ 个班的学生，他们已经按照身高从矮到高排好成了 $3$ 列纵队，现在要把这 $3$ 个班的学生也按照身高从矮到高排列 $1$ 列纵队。我们可以这么做：<br>1、让 $3$ 个班的学生按列站在你的面前，这时你能看到站在队首的学生的全身；<br>2、每一次队首的 $3$ 名同学，请最矮的同学出列到“队伍4”（即我们最终认为排好序的队列），出列的这一列的后面的所有同学都向前走一步（其实走不走都行，只要你能比较出站在你面前的 3 位在队首的同学同学的高矮即可）；<br>3、重复第 2 步，直到 $3$ 个班的同学全部出列完毕。  </p></blockquote><p>具体实现的时候，“每一次队首的 $3$ 名同学，请最矮的同学出列”这件事情可以交给<strong>优先队列</strong>（最小堆、最小索引堆均可）去完成。在连续的两次出队之间完成“穿针引线”的工作。</p><p>下面的图解释了上面的思路。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/23-1.png" alt="LeetCode 第 23 题：合并K个排序链表-1"></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/23-2.png" alt="LeetCode 第 23 题：合并K个排序链表-2"></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/23-3.png" alt="LeetCode 第 23 题：合并K个排序链表-3"></p><p>Python3 代码：Python3 的 <code>heapq</code> 模块传入的 <code>tuple</code> 对象里面不能有引用对象，就只好传一个索引进去了。</p><pre class="line-numbers language-Python"><code class="language-Python">class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass Solution:    def mergeKLists(self, lists):        import heapq        l = []        size = len(lists)        for index in range(size):            if lists[index]:                heapq.heappush(l, (lists[index].val, index))        dummy_node = ListNode(-1)        cur = dummy_node        while l:            _, index = heapq.heappop(l)            head = lists[index]            cur.next = head            cur = cur.next            if head.next:                heapq.heappush(l, (head.next.val, index))                lists[index] = head.next                head.next = None        return dummy_node.next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python2 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass Solution:    def mergeKLists(self, lists):        import heapq        l = []        for head in lists:            if head:                heapq.heappush(l, (head.val, head))        dummy_node = ListNode(-1)        cur = dummy_node        while l:            _, head = heapq.heappop(l)            cur.next = head            cur = cur.next            if head.next:                heapq.heappush(l, (head.next.val, head.next))        return dummy_node.next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：保留了一些调试代码，供各位参考。</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Comparator;import java.util.PriorityQueue;class ListNode {    int val;    ListNode next;    ListNode(int x) {        val = x;    }    ListNode(Integer[] nums) {        ListNode currNode = this;        currNode.val = nums[0];        for (int i = 1; i < nums.length; i++) {            currNode.next = new ListNode(nums[i]);            currNode = currNode.next;        }    }    @Override    public String toString() {        ListNode currNode = this;        StringBuilder s = new StringBuilder();        while (currNode != null) {            s.append(currNode.val);            s.append(" -> ");            currNode = currNode.next;        }        // 最后添加一个 NULL 标志表示添加到末尾了        s.append("NULL");        return s.toString();    }}public class Solution {    public ListNode mergeKLists(ListNode[] lists) {        int len = lists.length;        if (len == 0) {            return null;        }        PriorityQueue<ListNode> priorityQueue = new PriorityQueue<>(len, Comparator.comparingInt(a -> a.val));        ListNode dummyNode = new ListNode(-1);        ListNode curNode = dummyNode;        for (ListNode list : lists) {            if (list != null) {                // 这一步很关键，不能也没有必要将空对象添加到优先队列中                priorityQueue.add(list);            }        }        while (!priorityQueue.isEmpty()) {            // 优先队列非空才能出队            ListNode node = priorityQueue.poll();            // 当前节点的 next 指针指向出队元素            curNode.next = node;            // 当前指针向前移动一个元素，指向了刚刚出队的那个元素            curNode = curNode.next;            if (curNode.next != null) {                // 只有非空节点才能加入到优先队列中                priorityQueue.add(curNode.next);            }        }        return dummyNode.next;    }    public static void main(String[] args) {        Integer[] nums1 = {1, 4, 5};        Integer[] nums2 = {1, 3, 4};        Integer[] nums3 = {2, 6};        ListNode head1 = new ListNode(nums1);        ListNode head2 = new ListNode(nums2);        ListNode head3 = new ListNode(nums3);        ListNode[] lists = new ListNode[3];        lists[0] = head1;        lists[1] = head2;        lists[2] = head3;        Solution solution = new Solution();        ListNode mergeKLists = solution.mergeKLists(lists);        System.out.println(mergeKLists);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在文末附上了使用最小索引堆解决这个问题的代码，稍显复杂，仅供参考。</p><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N \log k)$，这里 $N$ 是这 $k$ 个链表的结点总数，每一次从一个优先队列中选出一个最小结点的时间复杂度是 $O(\log k)$，故时间复杂度为 $O(N \log k)$。</li><li>空间复杂度：$O(k)$，使用优先队列需要 $k$ 个空间，“穿针引线”需要常数个空间，因此空间复杂度为 $O(k)$。</li></ul><h3 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>根据之前处理链表的经验（例如 <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCode 第 206 题：反转链表</a>），如果我们不想“穿针引线”，那么“递归”、“分治”是一个不错的选择。</p><p>代码结构和“归并排序”可以说是同出一辙：   </p><p>1、先一分为二，分别“递归地”解决了与原问题同结构，但规模更小的两个子问题；  </p><p>2、再考虑如何合并，这个合并的过程也是一个递归方法（同 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCode 第 21 题：合并两个有序链表</a>）。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass Solution:    def mergeKLists(self, lists):        size = len(lists)        if size == 0:            return None        return self.__merge_k_lists(lists, 0, size - 1)    def __merge_k_lists(self, lists, left, right):        if left >= right:            return lists[left]        mid = left + (right - left) // 2        listnode1 = self.__merge_k_lists(lists, left, mid)        listnode2 = self.__merge_k_lists(lists, mid + 1, right)        return self.__merge_two_sorted_list_node(listnode1, listnode2)    def __merge_two_sorted_list_node(self, list1, list2):        if list1 is None:            return list2        if list2 is None:            return list1        if list1.val < list2.val:            list1.next = self.__merge_two_sorted_list_node(list1.next, list2)            return list1        else:            list2.next = self.__merge_two_sorted_list_node(list1, list2.next)            return list2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Comparator;import java.util.PriorityQueue;class ListNode {    int val;    ListNode next;    ListNode(int x) {        val = x;    }    ListNode(Integer[] nums) {        ListNode currNode = this;        currNode.val = nums[0];        for (int i = 1; i < nums.length; i++) {            currNode.next = new ListNode(nums[i]);            currNode = currNode.next;        }    }    @Override    public String toString() {        ListNode currNode = this;        StringBuilder s = new StringBuilder();        while (currNode != null) {            s.append(currNode.val);            s.append(" -> ");            currNode = currNode.next;        }        // 最后添加一个 NULL 标志表示添加到末尾了        s.append("NULL");        return s.toString();    }}public class Solution {    public ListNode mergeKLists(ListNode[] lists) {        int len = lists.length;        if (len == 0) {            return null;        }        return mergeKLists(lists, 0, len - 1);    }    public ListNode mergeKLists(ListNode[] lists, int l, int r) {        // 思考这里为什么取等于？这是因为根据下文对 mergeKLists 的递归调用情况，区间最窄的时候，只可能是左右端点重合        if (l == r) {            return lists[l];        }        int mid = (r - l) / 2 + l;        ListNode l1 = mergeKLists(lists, l, mid);        ListNode l2 = mergeKLists(lists, mid + 1, r);        return mergeTwoSortedListNode(l1, l2);    }    private ListNode mergeTwoSortedListNode(ListNode l1, ListNode l2) {        if (l1 == null) {            return l2;        }        if (l2 == null) {            return l1;        }        if (l1.val < l2.val) {            l1.next = mergeTwoSortedListNode(l1.next, l2);            return l1;        }        l2.next = mergeTwoSortedListNode(l1, l2.next);        return l2;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N \log k)$，这里 $N$ 是这 $k$ 个链表的结点总数，$k$ 个链表二分是对数级别的。</li><li>空间复杂度：$O(1)$，合并两个排序链表需要“穿针引线”的指针数是常数个的。</li></ul><hr><h3 id="附：方法一的补充：使用最小索引堆"><a href="#附：方法一的补充：使用最小索引堆" class="headerlink" title="附：方法一的补充：使用最小索引堆"></a>附：方法一的补充：使用最小索引堆</h3><p>下面使用自己编写最小索引堆完成，代码比较长，仅供参考。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class IndexMinHeap:    def __init__(self, capacity):        self.data = [0 for _ in range(capacity + 1)]        self.indexes = [0 for _ in range(capacity + 1)]        self.reverse = [0 for _ in range(capacity + 1)]        self.count = 0        self.capacity = capacity    def size(self):        return self.count    def is_empty(self):        return self.count == 0    # 此时 insert 要给一个索引位置    def insert(self, i, item):        if self.count + 1 > self.capacity:            raise Exception('堆的容量不够了')        i += 1        self.data[i] = item        self.indexes[self.count + 1] = i        # 注意：反向查找表是如何更新的        self.reverse[i] = self.count + 1        self.count += 1        self.__shift_up(self.count)    def __shift_up(self, k):        while k > 1 and self.data[self.indexes[k // 2]] > self.data[self.indexes[k]]:            self.indexes[k // 2], self.indexes[k] = self.indexes[k], self.indexes[k // 2]            # 只要索引发生交换，反向查找表也要更新            self.reverse[self.indexes[k // 2]] = k // 2            self.reverse[self.indexes[k]] = k            k //= 2    def extract_min(self):        if self.count == 0:            raise Exception('堆里没有可以取出的元素')        # 里面套一层 indexes        ret = self.data[self.indexes[1]]        # 交换的是索引        self.indexes[1], self.indexes[self.count] = self.indexes[self.count], self.indexes[1]        # 只要索引发生交换，反向查找表也要更新        self.reverse[self.indexes[1]] = 1        self.reverse[self.indexes[self.count]] = self.count        # 设置失效        self.reverse[self.indexes[self.count]] = 0        self.count -= 1        self.__shift_down(1)        return ret    def __shift_down(self, k):        while 2 * k <= self.count:            j = 2 * k            # 比较的是 data ，交换的是 indexes            if j + 1 <= self.count and self.data[self.indexes[j + 1]] < self.data[self.indexes[j]]:                j = j + 1            if self.data[self.indexes[k]] <= self.data[self.indexes[j]]:                break            self.indexes[k], self.indexes[j] = self.indexes[j], self.indexes[k]            # 只要索引发生交换，反向查找表也要更新            self.reverse[self.indexes[k]] = k            self.reverse[self.indexes[j]] = j            k = j    # 新增方法    def extract_min_index(self):        assert self.count > 0        # 减 1 是为了符合用户视角        ret = self.indexes[1] - 1        self.indexes[1], self.indexes[self.count] = self.indexes[self.count], self.indexes[1]        # 只要索引发生交换，反向查找表也要更新        self.reverse[self.indexes[1]] = 1        self.reverse[self.indexes[self.count]] = self.count        # 设置失效        self.reverse[self.indexes[self.count]] = 0        self.count -= 1        self.__shift_down(1)        return ret    # 新增方法    def get_min_index(self):        return self.indexes[1] - 1    # 新增方法    def get_item(self, i):        # 内部数组的索引比用户视角多 1        return self.data[i + 1]    # 新增方法    def change(self, i, new_item):        # 把用户视角改成内部索引        i += 1        self.data[i] = new_item        # 重点：下面这一步是找原来数组中索引是 i 的元素        # 在索引数组中的索引是几，这是一个唯一值，找到即返回        # 优化：可以引入反向查找技术优化        j = self.reverse[i]        self.__shift_down(j)        self.__shift_up(j)# Definition for singly-linked list.class ListNode:    def __init__(self, x):        self.val = x        self.next = Noneclass Solution:    def mergeKLists(self, lists: 'List[ListNode]') -> 'ListNode':        # 这一步是去掉空链表        new_lists = []        for i in range(len(lists)):            if lists[i]:                new_lists.append(lists[i])        size = len(new_lists)        index_min_heap = IndexMinHeap(size)        for i in range(size):            index_min_heap.insert(i,new_lists[i].val)        dummy = ListNode(-1)        cur = dummy        while index_min_heap.size() > 0:            index = index_min_heap.get_min_index()            print(index, index_min_heap.data,new_lists[index].val)            cur.next = ListNode(new_lists[index].val)            cur = cur.next            if new_lists[index].next is None:                # 如果后面没有元素，就可以删掉了                index_min_heap.extract_min_index()            else:                index_min_heap.change(index, new_lists[index].next.val)                new_lists[index] = new_lists[index].next        return dummy.nextdef create_linked_list(nums):    if len(nums) == 0:        return None    head = ListNode(nums[0])    cur = head    for i in range(1, len(nums)):        cur.next = ListNode(nums[i])        cur = cur.next    return headdef print_linked_list(list_node):    if list_node is None:        return    cur = list_node    while cur:        print(cur.val, '->', end=' ')        cur = cur.next    print('null')if __name__ == '__main__':    sorted_linked1 = create_linked_list([i for i in range(1, 20, 3)])    sorted_linked2 = create_linked_list([i for i in range(2, 20, 3)])    sorted_linked3 = create_linked_list([i for i in range(3, 20, 3)])    print_linked_list(sorted_linked1)    print_linked_list(sorted_linked2)    print_linked_list(sorted_linked3)    solution = Solution()    result = solution.mergeKLists(lists=[sorted_linked1, sorted_linked2, sorted_linked3])    print_linked_list(result)    sorted_linked1 = create_linked_list([1,2,3])    sorted_linked2 = create_linked_list([4,5,6,7])    sorted_linked3 = create_linked_list([])    solution = Solution()    result = solution.mergeKLists(lists=[sorted_linked1, sorted_linked2,sorted_linked3])    print_linked_list(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LeetCode-第-23-题：归并多个有序链表"><a href="#LeetCode-第-23-题：归并多个有序链表" class="headerlink" title="LeetCode 第 23 题：归并多个有序链表"></a>LeetCode 第 23 题：归并多个有序链表</h3><p>传送门：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a>。</p><blockquote><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例:</strong></p><pre><code>输入:[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre></blockquote><p>思路1：使用优先队列。</p><p>首先要复习一下 Python 中优先队列的使用。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lists<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type lists: List[ListNode]        :rtype: ListNode        """</span>        <span class="token keyword">import</span> heapq        l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>lists<span class="token punctuation">)</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> lists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token punctuation">(</span>lists<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span>        dummy_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cur <span class="token operator">=</span> dummy_node        <span class="token keyword">while</span> l<span class="token punctuation">:</span>            _<span class="token punctuation">,</span> index <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>l<span class="token punctuation">)</span>            head <span class="token operator">=</span> lists<span class="token punctuation">[</span>index<span class="token punctuation">]</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> head            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            <span class="token keyword">if</span> head<span class="token punctuation">.</span>next<span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span>                lists<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">.</span>next                head<span class="token punctuation">.</span>next <span class="token operator">=</span> None        <span class="token keyword">return</span> dummy_node<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：使用分治</p><p>参考资料：<a href="https://liweiwei1419.github.io/leetcode-solution/leetcode-0023-merge-k-sorted-lists/" target="_blank" rel="noopener">https://liweiwei1419.github.io/leetcode-solution/leetcode-0023-merge-k-sorted-lists/</a></p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 23. 合并K个排序链表</span><span class="token comment" spellcheck="true"># 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</span><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token comment" spellcheck="true"># 思路：分治法与优先队列</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lists<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type lists: List[ListNode]        :rtype: ListNode        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>lists<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__merge_k_lists<span class="token punctuation">(</span>lists<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__merge_k_lists</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> lists<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> left <span class="token operator">>=</span> right<span class="token punctuation">:</span>            <span class="token keyword">return</span> lists<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        listnode1 <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_k_lists<span class="token punctuation">(</span>lists<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>        listnode2 <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_k_lists<span class="token punctuation">(</span>lists<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__merge_two_sorted_list_node<span class="token punctuation">(</span>listnode1<span class="token punctuation">,</span> listnode2<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__merge_two_sorted_list_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> list1<span class="token punctuation">,</span> list2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> list1 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> list2        <span class="token keyword">if</span> list2 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> list1        <span class="token keyword">if</span> list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            list1<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list_node<span class="token punctuation">(</span>list1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> list2<span class="token punctuation">)</span>            <span class="token keyword">return</span> list1        <span class="token keyword">else</span><span class="token punctuation">:</span>            list2<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list_node<span class="token punctuation">(</span>list1<span class="token punctuation">,</span> list2<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            <span class="token keyword">return</span> list2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治算法 </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 贪心算法 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 21 题：合并两个有序链表（简单）</title>
      <link href="/leetcode-algo/2017/08/03/leetcode-algo/0021-merge-two-sorted-lists/"/>
      <url>/leetcode-algo/2017/08/03/leetcode-algo/0021-merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-21-题：合并两个有序链表（简单）"><a href="#「力扣」第-21-题：合并两个有序链表（简单）" class="headerlink" title="「力扣」第 21 题：合并两个有序链表（简单）"></a>「力扣」第 21 题：合并两个有序链表（简单）</h2><p>中文网址：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">21. 合并两个有序链表</a>  ；</p><p>英文网址：<a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">21. Merge Two Sorted Lists</a>  ；</p><p>题解地址：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/chuan-zhen-yin-xian-java-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">穿针引线（Java 代码）</a>。</p><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><pre><code>输入：1 -&gt; 2 -&gt; 4, 1 -&gt; 3 -&gt; 4输出：1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt;4</code></pre></blockquote><p>分析：归并两个有序的链表，还是穿针引线的问题，用递归也可以做。掌握两种方法。</p><p>1、穿针引线；</p><p>2、递归。</p><h3 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h3><p><img src="https://pic.leetcode-cn.com/12b00e35459dc32405363e0f641653b5e926b7be94cfd063bd3b10943f3b84d1-image.png" alt="image.png"></p><p><img src="https://pic.leetcode-cn.com/ffba6fb487a62746149227b81ff6e948f13b96e7cfdb77a50d0fc80c59f750a6-image.png" alt="image.png"></p><p><strong>参考代码 1</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">class ListNode {    int val;    ListNode next;    ListNode(int x) {        val = x;    }    public ListNode(int[] nums) {        if (nums == null || nums.length == 0) {            throw new IllegalArgumentException("arr can not be empty");        }        this.val = nums[0];        ListNode curr = this;        for (int i = 1; i < nums.length; i++) {            curr.next = new ListNode(nums[i]);            curr = curr.next;        }    }    @Override    public String toString() {        StringBuilder s = new StringBuilder();        ListNode cur = this;        while (cur != null) {            s.append(cur.val);            s.append(" -> ");            cur = cur.next;        }        s.append("NULL");        return s.toString();    }}public class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        ListNode dummyNode = new ListNode(-1);        ListNode p1 = l1;        ListNode p2 = l2;        ListNode curNode = dummyNode;        // 两者都不为空的时候，才有必要进行比较        while (p1 != null && p2 != null) {            if (p1.val < p2.val) {                // 指针修改发生在这里                curNode.next = p1;                p1 = p1.next;            } else {                // 指针修改发生在这里                curNode.next = p2;                p2 = p2.next;            }            curNode = curNode.next;        }        // 跳出循环是因为 p1 == null 或者 p2 == null        if (p1 == null) {            curNode.next = p2;        }        if (p2 == null) {            curNode.next = p1;        }        return dummyNode.next;    }    public static void main(String[] args) {        int[] nums1 = {1, 3, 5, 7};        int[] nums2 = {2, 4, 6};        ListNode l1 = new ListNode(nums1);        ListNode l2 = new ListNode(nums2);        Solution solution = new Solution();        ListNode mergeTwoLists = solution.mergeTwoLists(l1, l2);        System.out.println(mergeTwoLists);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N)$，这里 $N$ 为两个链表的结点个数之和。</li><li>空间复杂度：$O(1)$，这里需要的指针和辅助结点的个数都是常数。</li></ul><h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 使用递归     *     * @param l1 有序链表     * @param l2 有序链表     * @return 有序链表     */</span>    <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 2 题：两个数相加（中等）</title>
      <link href="/leetcode-algo/2017/08/02/leetcode-algo/0019-remove-nth-node-from-end-of-list/"/>
      <url>/leetcode-algo/2017/08/02/leetcode-algo/0019-remove-nth-node-from-end-of-list/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-19-题：删除链表的倒数第-N-个节点（中等）"><a href="#「力扣」第-19-题：删除链表的倒数第-N-个节点（中等）" class="headerlink" title="「力扣」第 19 题：删除链表的倒数第 N 个节点（中等）"></a>「力扣」第 19 题：删除链表的倒数第 N 个节点（中等）</h2><ul><li><p>中文网址：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a> ；</p></li><li><p>英文网址：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a> 。</p></li></ul><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><p>给定一个链表: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>, 和 <code>n = 2</code>.</p><p>当删除了倒数第二个节点后，链表变为 <code>1-&gt;2-&gt;3-&gt;5</code>.<br>说明：</p><p>给定的 <code>n</code> 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p></blockquote><p>重点：1、设置虚拟头结点；2、快慢指针</p><h3 id="方法一：先数出有多少个结点，然后走-len-n-步"><a href="#方法一：先数出有多少个结点，然后走-len-n-步" class="headerlink" title="方法一：先数出有多少个结点，然后走 len - n 步"></a>方法一：先数出有多少个结点，然后走 <code>len - n</code> 步</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">getLenOfNode</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除索引为 len - n 的结点</span>        <span class="token comment" spellcheck="true">// 有了虚拟头结点以后，就走 len - n 步，来到要删除的结点之前</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode deleteNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> deleteNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        deleteNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getLenOfNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            len<span class="token operator">++</span><span class="token punctuation">;</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> len<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>使用快慢指针。其实只要掌握了如何找到距离末尾 $n$ 个元素的位置，就很容易了。还要注意的就是边界值的选取，其实往往我们认为的值与正确值无非就是 $+1$ 或者 $-1$ ，为了避免粗心出错，我们可以拿一个具体的例子。另外，涉及链表头结点的操作，一般都会引入虚拟结点，以减少讨论的可能，这是一个常见的技巧。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g83eo97mocj310y0d60tk.jpg" alt="image-20191019123938705"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g83eoivq2gj30vz0u0acd.jpg" alt="image-20191019123954924"></p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 快慢指针：给定的 n 保证是有效的。     *     * @param head     * @param n     * @return     */</span>    <span class="token keyword">public</span> ListNode <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 来到倒数第 N + 1 个结点的位置</span>        ListNode fastNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fastNode <span class="token operator">=</span> fastNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode slowNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fastNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fastNode <span class="token operator">=</span> fastNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            slowNode <span class="token operator">=</span> slowNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 此时 slowNode 来到了待删除的结点的上一个结点</span>        ListNode deleteNode <span class="token operator">=</span> slowNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slowNode<span class="token punctuation">.</span>next <span class="token operator">=</span> deleteNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        deleteNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthToTail</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pListHead<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> pListHead <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        fast <span class="token operator">=</span> pListHead        <span class="token comment" spellcheck="true"># 要注意的临界点1：</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next            <span class="token keyword">if</span> fast <span class="token keyword">is</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None        slow <span class="token operator">=</span> pListHead        <span class="token comment" spellcheck="true"># 要注意的临界点2：</span>        <span class="token keyword">while</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 2 题：两个数相加（中等）</title>
      <link href="/leetcode-algo/2017/08/01/leetcode-algo/0002-add-two-numbers/"/>
      <url>/leetcode-algo/2017/08/01/leetcode-algo/0002-add-two-numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-2-题：两个数相加（中等）"><a href="#「力扣」第-2-题：两个数相加（中等）" class="headerlink" title="「力扣」第 2 题：两个数相加（中等）"></a>「力扣」第 2 题：两个数相加（中等）</h2><p>中文链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">2. 两数相加</a> ；</p><p>英文链接：<a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">2. Add Two Numbers</a> 。</p><blockquote><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例</strong>：</p><pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre></blockquote><p>思路：需要考虑的问题：</p><p>1、数字中是否有前置的 $0$（除了 $0$ 以外，没有前置的 $0$）；</p><p>2、负数是否考虑。</p><p>编码过程中需要思考的问题：</p><p>1、如何分别获得这个数组的个位、十位、百位、千位；</p><p>2、分别相加，如果大于 $10$，进一。</p><h3 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode curNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        StringBuilder stringBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> stringBuilder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">||</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> l1<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sum <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode l1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode l2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode addTwoNumbers <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>addTwoNumbers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> val <span class="token operator">=</span> l1<span class="token punctuation">.</span>val <span class="token operator">+</span> l2<span class="token punctuation">.</span>val <span class="token operator">+</span> carry<span class="token punctuation">;</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>val <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            carry <span class="token operator">=</span> val <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>carry <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> l2<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> l1 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> l2        <span class="token keyword">if</span> l2 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> l1        dummy_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cur_node <span class="token operator">=</span> dummy_node        s <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 只要二者之一非空，就加下去</span>        <span class="token keyword">while</span> l1 <span class="token operator">or</span> l2<span class="token punctuation">:</span>            <span class="token keyword">if</span> l1<span class="token punctuation">:</span>                s <span class="token operator">+=</span> l1<span class="token punctuation">.</span>val                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next            <span class="token keyword">if</span> l2<span class="token punctuation">:</span>                s <span class="token operator">+=</span> l2<span class="token punctuation">.</span>val                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next            cur_node<span class="token punctuation">.</span>next <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>s <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span>            s <span class="token operator">//=</span> <span class="token number">10</span>            cur_node <span class="token operator">=</span> cur_node<span class="token punctuation">.</span>next        <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            cur_node<span class="token punctuation">.</span>next <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dummy_node<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「链表」专题 6：链表与双指针</title>
      <link href="/leetcode-algo/2017/07/21/leetcode-solution/linked-list-6/"/>
      <url>/leetcode-algo/2017/07/21/leetcode-solution/linked-list-6/</url>
      
        <content type="html"><![CDATA[<h2 id="「链表」专题-6：链表与双指针"><a href="#「链表」专题-6：链表与双指针" class="headerlink" title="「链表」专题 6：链表与双指针"></a>「链表」专题 6：链表与双指针</h2><h3 id="例题：「力扣」第-19-题：删除链表的倒数第-N-个结点"><a href="#例题：「力扣」第-19-题：删除链表的倒数第-N-个结点" class="headerlink" title="例题：「力扣」第 19 题：删除链表的倒数第 N 个结点"></a>例题：「力扣」第 19 题：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener">删除链表的倒数第 N 个结点</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a> ，中文网址：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a> 。</p><blockquote><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p></blockquote><p>思路：使用快慢指针。其实只要掌握了如何找到距离末尾 $n$ 个元素的位置，就很容易了。还要注意的就是边界值的选取，其实往往我们认为的值与正确值无非就是 $+1$ 或者 $-1$ ，为了避免粗心出错，我们可以拿一个具体的例子。另外，涉及链表头结点的操作，一般都会引入虚拟结点，以减少讨论的可能，这是一个常见的技巧。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthToTail</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pListHead<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type pListHead: ListNode        :type k: int        :rtype: ListNode        """</span>        <span class="token keyword">if</span> pListHead <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        fast <span class="token operator">=</span> pListHead        <span class="token comment" spellcheck="true"># 要注意的临界点1：</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next            <span class="token keyword">if</span> fast <span class="token keyword">is</span> None<span class="token punctuation">:</span>                <span class="token keyword">return</span> None        slow <span class="token operator">=</span> pListHead        <span class="token comment" spellcheck="true"># 要注意的临界点2：</span>        <span class="token keyword">while</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next        <span class="token keyword">return</span> slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习1：「力扣」第-61-题：旋转链表"><a href="#练习1：「力扣」第-61-题：旋转链表" class="headerlink" title="练习1：「力扣」第 61 题：旋转链表"></a>练习1：「力扣」第 61 题：<a href="https://leetcode-cn.com/problems/rotate-list" target="_blank" rel="noopener">旋转链表</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/rotate-list/description/" target="_blank" rel="noopener">61. Rotate List</a> ，中文网址：<a href="https://leetcode-cn.com/problems/rotate-list/description/" target="_blank" rel="noopener">61. 旋转链表</a> 。</p><blockquote><p>给定一个链表，旋转链表，将链表每个结点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例 1:</strong></p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</code></pre></blockquote><p>思路：问题本身不难，但是要处理一些细节。</p><p>1、一定要先求出链表的总长度；</p><p>2、求得总长度的时候，顺便标记好末尾结点，并且把末尾结点的 next 指针指到头结点去，形成环，否则容易出现空指针异常；</p><p>3、到底多少 pre 指针还要走多少步，举 1 到 2 个具体的例子带进去就知道了。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :type k: int        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># 先看链表有多少元素</span>        node <span class="token operator">=</span> head        <span class="token comment" spellcheck="true"># 先数这个链表的长度</span>        counter <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> node<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next            counter <span class="token operator">+=</span> <span class="token number">1</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> head        k <span class="token operator">=</span> k <span class="token operator">%</span> counter        node <span class="token operator">=</span> head        <span class="token comment" spellcheck="true"># counter - k - 1 可以取一些极端的例子找到规律</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>counter <span class="token operator">-</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>next        new_head <span class="token operator">=</span> node<span class="token punctuation">.</span>next        node<span class="token punctuation">.</span>next <span class="token operator">=</span> None        <span class="token keyword">return</span> new_head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习2：「力扣」第-143-题：重排链表"><a href="#练习2：「力扣」第-143-题：重排链表" class="headerlink" title="练习2：「力扣」第 143 题：重排链表"></a>练习2：「力扣」第 143 题：<a href="https://leetcode-cn.com/problems/reorder-list" target="_blank" rel="noopener">重排链表</a></h3><p>传送门：<a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a>。</p><blockquote><p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>L<strong>n<em>→</em>L<em>1→</em>L</strong>n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><pre><code>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</code></pre><p><strong>示例 2:</strong></p><pre><code>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</code></pre></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author liwei * @date 18/7/5 上午9:36 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode anotherHead <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤1：从中间截断链表</span>        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤2：反转链表的后半截</span>        ListNode reverseList <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>anotherHead<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤3：合并两个链表</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> reverseList<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> ListNode <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>ListNode head1<span class="token punctuation">,</span> ListNode head2<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// k % 2 == 0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            head1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>head1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head2<span class="token punctuation">,</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> head1<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            head2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoList</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span> head2<span class="token punctuation">.</span>next<span class="token punctuation">,</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> head2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode preNode <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode nextNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> preNode<span class="token punctuation">;</span>            preNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>            curNode <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> preNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution2 solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        solution2<span class="token punctuation">.</span><span class="token function">reorderList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习3：「力扣」第-234-题：回文链表"><a href="#练习3：「力扣」第-234-题：回文链表" class="headerlink" title="练习3：「力扣」第 234 题：回文链表"></a>练习3：「力扣」第 234 题：<a href="https://leetcode-cn.com/problems/palindrome-linked-list" target="_blank" rel="noopener">回文链表</a></h3><p>传送门：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a>。</p><blockquote><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><pre><code>输入: 1-&gt;2输出: false</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: 1-&gt;2-&gt;2-&gt;1输出: true</code></pre><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p></blockquote><p>求解关键：找到链表中间位置的结点，做一些相关的处理。特别要注意的是，不管哪种方法，都要对一些细节问题仔细考虑，可以举出具体的例子，画图帮助编码实现。</p><p>思路1：从中间位置开始反转链表，逐个比较。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * https://leetcode-cn.com/problems/palindrome-linked-list/description/ * * @author liwei */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// slow 的下一个就是新链表，反转它</span>        ListNode cur <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 此时 pre 成为新链表开头</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> pre <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">!=</span> pre<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> palindrome <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>palindrome<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：在寻找链表中间结点的过程中，慢结点向前遍历的时候，把遍历到的值放入一个栈中。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author liwei */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 分清楚奇数和偶数结点两种情况，不反转链表，借助栈完成回文链表的判断</span>    <span class="token comment" spellcheck="true">//      slow</span>    <span class="token comment" spellcheck="true">// 1，2，3，4，5</span>    <span class="token comment" spellcheck="true">//   slow</span>    <span class="token comment" spellcheck="true">// 1，2，3，4</span>    <span class="token comment" spellcheck="true">/**     * @param head     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 链表有奇数个结点</span>            stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution2 solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> palindrome <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>palindrome<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「链表」专题 5：不仅仅是穿针引线</title>
      <link href="/leetcode-algo/2017/07/20/leetcode-solution/linked-list-5/"/>
      <url>/leetcode-algo/2017/07/20/leetcode-solution/linked-list-5/</url>
      
        <content type="html"><![CDATA[<h2 id="「链表」专题-5：不仅仅是穿针引线"><a href="#「链表」专题-5：不仅仅是穿针引线" class="headerlink" title="「链表」专题 5：不仅仅是穿针引线"></a>「链表」专题 5：不仅仅是穿针引线</h2><h3 id="例：「力扣」第-237-题：删除链表中的结点"><a href="#例：「力扣」第-237-题：删除链表中的结点" class="headerlink" title="例：「力扣」第 237 题：删除链表中的结点"></a>例：「力扣」第 237 题：删除链表中的结点</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/delete-node-in-a-linked-list/description/" target="_blank" rel="noopener">237. Delete Node in a Linked List</a> ，中文网址：<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/description/" target="_blank" rel="noopener">237. 删除链表中的节点</a> 。</p><blockquote><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p><img src="http://upload-images.jianshu.io/upload_images/414598-4f7c78163a1a3479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LeetCode 第 237 题：删除链表中的结点"></p><p><strong>示例 1:</strong></p><pre><code>输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre><p><strong>说明:</strong></p><ul><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。</li></ul></blockquote><p>删除链表上的节点。（思考一下，我们原来学习的链表的删除是怎么删除的，通过索引来删除？）</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这道题理解题意是关键，题目要求的是删除这个节点     *     * @param node     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            node <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode deleteNode <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>val <span class="token operator">=</span> deleteNode<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> deleteNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        deleteNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「链表」专题 4：复杂的穿针引线</title>
      <link href="/leetcode-algo/2017/07/19/leetcode-solution/linked-list-4/"/>
      <url>/leetcode-algo/2017/07/19/leetcode-solution/linked-list-4/</url>
      
        <content type="html"><![CDATA[<h2 id="「链表」专题-4：复杂的穿针引线"><a href="#「链表」专题-4：复杂的穿针引线" class="headerlink" title="「链表」专题 4：复杂的穿针引线"></a>「链表」专题 4：复杂的穿针引线</h2><p>下面看一个比较经典的问题「两两交换链表中的结点」。</p><h3 id="例1：「力扣」第-24-题：两两交换链表中的结点"><a href="#例1：「力扣」第-24-题：两两交换链表中的结点" class="headerlink" title="例1：「力扣」第 24 题：两两交换链表中的结点"></a>例1：「力扣」第 24 题：两两交换链表中的结点</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">24. Swap Nodes in Pairs</a> ，中文网址：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a> 。</p><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>示例:</strong></p><pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre><p><strong>说明:</strong></p><ul><li>你的算法只能使用常数的额外空间。</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li></ul></blockquote><p>分析：两种方法：1、用递归来做就特别简单；2、穿针引线比较麻烦。</p><p>解法1：穿针引线做法：设计以下 4 个引用（指针）。<br>1、成对的结点 1 ：node1<br>2、成对的结点 2 ：node2<br>3、成对的结点 1 的前驱：p<br>4、成对的结点 2 的后继：next</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 交换链表中成对的元素     * （自己把图画出来，对于指针交换的过程就好理解了）     *     * @param head     * @return     */</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode p <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode node1 <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            ListNode node2 <span class="token operator">=</span> node1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            ListNode next <span class="token operator">=</span> node2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            node1<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            node2<span class="token punctuation">.</span>next <span class="token operator">=</span> node1<span class="token punctuation">;</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span>            p <span class="token operator">=</span> node1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ListNode <span class="token function">createLinkedList</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode current <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            current<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printLinkedList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode current <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d => "</span><span class="token punctuation">,</span> current<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"NULL "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode head1 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">createLinkedList</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        solution<span class="token punctuation">.</span><span class="token function">printLinkedList</span><span class="token punctuation">(</span>head1<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode reverseHead <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">swapPairs</span><span class="token punctuation">(</span>head1<span class="token punctuation">)</span><span class="token punctuation">;</span>        solution<span class="token punctuation">.</span><span class="token function">printLinkedList</span><span class="token punctuation">(</span>reverseHead<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：以下及其以后的动图如果没有特别说明，都来自这个伟大的 GitHub 仓库：<a href="https://github.com/MisterBooo/LeetCodeAnimation/blob/master/Readme.md。" target="_blank" rel="noopener">https://github.com/MisterBooo/LeetCodeAnimation/blob/master/Readme.md。</a></p><p><img src="https://camo.githubusercontent.com/e01d0b7be8d7e51bae4135959ce54c1d9b274738/68747470733a2f2f6275636b65742d313235373132363534392e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32303138313230363136313131352e676966" alt=""></p><p>解法2：如果使用递归的方法，就特别简单。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author liwei * @date 18/7/4 下午9:42 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode p2 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode newHead <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 下面这两行代码可以交换</span>        p1<span class="token punctuation">.</span>next <span class="token operator">=</span> newHead<span class="token punctuation">;</span>        p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token keyword">return</span> p2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面这样写就更简单了：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode first <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode second <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        first<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>second<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        second<span class="token punctuation">.</span>next <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">return</span> second<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 给定 1->2->3->4, 你应该返回 2->1->4->3.</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode swapPairs <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">swapPairs</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>swapPairs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考资料：<a href="https://blog.csdn.net/Koala_Tree/article/details/81476772。" target="_blank" rel="noopener">https://blog.csdn.net/Koala_Tree/article/details/81476772。</a></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1：「力扣」第-25-题：k个一组翻转链表"><a href="#练习1：「力扣」第-25-题：k个一组翻转链表" class="headerlink" title="练习1：「力扣」第 25 题：k个一组翻转链表"></a>练习1：「力扣」第 25 题：k个一组翻转链表</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="noopener">25. Reverse Nodes in k-Group</a> ，中文网址：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="noopener">25. k个一组翻转链表</a> 。</p><blockquote><p>给出一个链表，每 <em>k</em> 个节点一组进行翻转，并返回翻转后的链表。</p><p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <em>k</em> 的整数倍，那么将最后剩余节点保持原有顺序。</p><p><strong>示例 :</strong></p><p>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>当 <em>k</em> = 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>当 <em>k</em> = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p><strong>说明 :</strong></p><ul><li>你的算法只能使用常数的额外空间。</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li></ul></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 参考资料：https://blog.csdn.net/weiyongle1996/article/details/78473055</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用递归写法的话，先考虑特殊情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 探测长度的结点</span>        ListNode tempNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">int</span> curK <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tempNode <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curK <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curK<span class="token operator">--</span><span class="token punctuation">;</span>            tempNode <span class="token operator">=</span> tempNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果够数了，先考虑反转</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curK <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 下面开始反转</span>            ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>            ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ListNode nextNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>                pre <span class="token operator">=</span> curNode<span class="token punctuation">;</span>                curNode <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> pre<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode reverseKGroup <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">reverseKGroup</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reverseKGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习2：「力扣」第-147-题：单链表的插入排序"><a href="#练习2：「力扣」第-147-题：单链表的插入排序" class="headerlink" title="练习2：「力扣」第 147 题：单链表的插入排序"></a>练习2：「力扣」第 147 题：单链表的插入排序</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/insertion-sort-list/description/" target="_blank" rel="noopener">147. Insertion Sort List</a> ，中文网址：<a href="https://leetcode-cn.com/problems/insertion-sort-list/description/" target="_blank" rel="noopener">147. 对链表进行插入排序</a> 。</p><blockquote><p>对链表进行插入排序。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt=""></p><p>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p><p><strong>插入排序算法：</strong></p><ol><li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li><li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li><li>重复直到所有输入数据插入完为止。</li></ol><p><strong>示例 1：</strong></p><pre><code>输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre></blockquote><p>分析：这道题的题意我们感觉有那么些误导我们的意思，我们能想到从头开始找结点应该插入的位置，但感觉这种做法又不像插入排序。解决这个问题不要太死板，不要怕麻烦我觉得是解这道问题的关键（这句话感觉跟没说一个样，^_^）。</p><ol><li>插入排序每次会将遍历到的一个元素插入到已经排序的部分；</li><li>熟悉插入排序的朋友们都知道，这种插入过程是从后向前的，但是对于单链表来说，只保存了当前结点到下一个结点的 next 指针，并没有保存从当前结点到上一个节点的 pre 指针；</li><li>我们就要变换思路了，每次都要从链表的第 1 个元素开始，找到新遍历的节点适合插入的位置，进行穿针引线；</li><li>具体来说对于单链表的第 1 个元素，涉及到头结点的操作的时候，我们的做法往往是设计一个虚拟头结点，以简化编码。<br> 综上所述，想清楚上面的问题，写出正确的代码应该不是难事。</li></ol><p>为一个链表实现插入排序。</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/147-1.jpg" alt="LeetCode 第 147 题：单链表的插入排序-1"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/147-2.jpg" alt="LeetCode 第 147 题：单链表的插入排序-2"></p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">insertionSortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先写最特殊的情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode pre<span class="token punctuation">;</span>        ListNode next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果遍历下去，是顺序排列的话，那最简单了，curNode 指针向前就行了</span>            <span class="token comment" spellcheck="true">// 这一步是一个循环的过程</span>            <span class="token comment" spellcheck="true">// 暂存当前结点的下一结点</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curNode<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 下面针对上一步跳出循环的两个条件进行特殊处理</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果后面没有元素了，那就说明，此时链表已经有序，可以结束我们的排序逻辑了</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 否则就一定满足 curNode.val > curNode.next.val; 为真</span>                <span class="token comment" spellcheck="true">// pre 打回到起点</span>                pre <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>                next <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 把 pre 挪到可以放置 next 结点的上一个位置</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 穿针引线的 3 个步骤，请见图 https://liweiwei1419.github.io/images/leetcode-solution/147-1.jpg</span>                <span class="token comment" spellcheck="true">// 穿针引线步骤 1</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 穿针引线步骤 2</span>                next<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 穿针引线步骤 2</span>                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode insertionSortList <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">insertionSortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>insertionSortList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等价写法：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">insertionSortList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 虚拟头结点</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode preNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用于遍历的指针</span>        ListNode curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 没有这一步：dummyNode.next = head;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            next <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 这一步是找到一个正确的位置插入，只要比 curNode 的值小，都应该跳过</span>            <span class="token comment" spellcheck="true">// 直到遇到第 1 个大于等于它的元素</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>preNode<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> preNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> curNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                preNode <span class="token operator">=</span> preNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 应该把 node 放在 pre 的下一个</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> preNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            preNode<span class="token punctuation">.</span>next <span class="token operator">=</span> curNode<span class="token punctuation">;</span>            preNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>            curNode <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution2 solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode insertionSortList <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">insertionSortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>insertionSortList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习3：「力扣」第-148-题：单链表的排序，使用归并排序"><a href="#练习3：「力扣」第-148-题：单链表的排序，使用归并排序" class="headerlink" title="练习3：「力扣」第 148 题：单链表的排序，使用归并排序"></a>练习3：「力扣」第 148 题：单链表的排序，使用归并排序</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="noopener">148. Sort List</a> ，中文网址：<a href="https://leetcode-cn.com/problems/sort-list/description/" target="_blank" rel="noopener">148. 排序链表</a> 。</p><blockquote><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p><strong>示例 1:</strong></p><pre><code>输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre></blockquote><p>写一个排序算法，用 $O(n\log n)$ 的时间复杂度为一个链表进行排序。</p><p>对于单链表而言，归并排序是一个不错的选择。</p><p>思路1：自顶向下的归并排序。</p><p>注意1：特别注意下面这么一段：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> fast<span class="token punctuation">.</span>next <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">:</span>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li>这个方法走到这里，因为有前面的特判，所以至少得有 $2$ 个结点，才可以排序。而<strong>取中点的操作，只有在“下个结点”和“下下结点”</strong>都存在的时候，才能这么做；</li><li>看看这个循环的循环体就明白了。</li></ul><p>注意2：找到中间结点以后，记得把链表“从中切断”，这是符合逻辑的。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># 找到中点</span>        slow <span class="token operator">=</span> head        fast <span class="token operator">=</span> head        <span class="token keyword">while</span> fast<span class="token punctuation">.</span>next <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        head2 <span class="token operator">=</span> slow<span class="token punctuation">.</span>next        slow<span class="token punctuation">.</span>next <span class="token operator">=</span> None        lnode <span class="token operator">=</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        rnode <span class="token operator">=</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head2<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>lnode<span class="token punctuation">,</span> rnode<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__merge_two_sorted_list</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head1<span class="token punctuation">,</span> head2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head1 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head2        <span class="token keyword">if</span> head2 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head1        <span class="token keyword">if</span> head1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> head2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            head1<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>head1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head2<span class="token punctuation">)</span>            <span class="token keyword">return</span> head1        <span class="token keyword">else</span><span class="token punctuation">:</span>            head2<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>head1<span class="token punctuation">,</span> head2<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            <span class="token keyword">return</span> head2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种写法：</p><p>特别注意，如果是</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> fast <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">:</span>    p <span class="token operator">=</span> slow    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种取法，<strong>遇到两个结点的时候，slow 会向前走一步，但是截断得在 slow 结点之前，否则会进入死循环，按照我说的，画一个两个结点的链表就很清楚了</strong>。</p><p>遇到死循环的时候，不要着急，还有耐心 debug，分析代码运行流程，很多时候问题就迎刃而解了。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token comment" spellcheck="true"># 这里有个小陷阱，如果遇到问题，不要着急，代码调试就好了</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># 找到中点</span>        slow <span class="token operator">=</span> head        fast <span class="token operator">=</span> head        <span class="token keyword">while</span> fast <span class="token operator">and</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            p <span class="token operator">=</span> slow            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next        p<span class="token punctuation">.</span>next <span class="token operator">=</span> None        <span class="token comment" spellcheck="true"># print_node_list(head)</span>        <span class="token comment" spellcheck="true"># print_node_list(head2)</span>        lnode <span class="token operator">=</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span>        rnode <span class="token operator">=</span> self<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>slow<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>lnode<span class="token punctuation">,</span> rnode<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__merge_two_sorted_list</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head1<span class="token punctuation">,</span> head2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> head1 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head2        <span class="token keyword">if</span> head2 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head1        <span class="token keyword">if</span> head1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> head2<span class="token punctuation">.</span>val<span class="token punctuation">:</span>            head1<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>head1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> head2<span class="token punctuation">)</span>            <span class="token keyword">return</span> head1        <span class="token keyword">else</span><span class="token punctuation">:</span>            head2<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>__merge_two_sorted_list<span class="token punctuation">(</span>head1<span class="token punctuation">,</span> head2<span class="token punctuation">.</span>next<span class="token punctuation">)</span>            <span class="token keyword">return</span> head2<span class="token keyword">def</span> <span class="token function">create_node_list</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    head <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    cur <span class="token operator">=</span> head    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next    <span class="token keyword">return</span> head<span class="token keyword">def</span> <span class="token function">print_node_list</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> head<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token string">'->'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>next    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'NULL'</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>    head <span class="token operator">=</span> create_node_list<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    print_node_list<span class="token punctuation">(</span>head<span class="token punctuation">)</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>sortList<span class="token punctuation">(</span>head<span class="token punctuation">)</span>    print_node_list<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：自底向上的归并排序。</p><p>我以前写了一个示意图，可以点<a href="https://liweiwei1419.github.io/leetcode-solution/leetcode-0148-sort-list/" target="_blank" rel="noopener">这里</a>看，思想还是很简单的。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「链表」专题 3：设立虚拟头结点</title>
      <link href="/leetcode-algo/2017/07/18/leetcode-solution/linked-list-3/"/>
      <url>/leetcode-algo/2017/07/18/leetcode-solution/linked-list-3/</url>
      
        <content type="html"><![CDATA[<h2 id="「链表」专题-3：设立虚拟头结点"><a href="#「链表」专题-3：设立虚拟头结点" class="headerlink" title="「链表」专题 3：设立虚拟头结点"></a>「链表」专题 3：设立虚拟头结点</h2><p>这是处理链表问题常用的技巧。</p><h3 id="例1：「力扣」第-203-题：移除链表元素"><a href="#例1：「力扣」第-203-题：移除链表元素" class="headerlink" title="例1：「力扣」第 203 题：移除链表元素"></a>例1：「力扣」第 203 题：移除链表元素</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/remove-linked-list-elements/description/" target="_blank" rel="noopener">203. Remove Linked List Elements</a>  ，中文网址：<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/description/" target="_blank" rel="noopener">203. 删除链表中的结点</a>  。</p><blockquote><p>删除链表中等于给定值 <strong>val</strong> 的所有节点。</p><p><strong>示例:</strong></p><pre><code>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre></blockquote><p>思路：先给出一个容易想到的解法，但是这个解法对于删除头结点的逻辑写得比较长。</p><p>Java 代码：（代码比较冗长，没有意义，可以跳过不看，只要跟头结点有关的问题，要设置虚拟头结点就好了。）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 基本思路：只要当前遍历的节点的下一个节点不为空 * 把它拿出来比较一下目标值： * 如果和目标值相同，就（1）先把要删除的节点存一下。 * （2）当前的节点的下一个引用指向要删除节点的下一个引用。 * （3）把要删除节点的下一个节点的引用置为 null。 * 但是，特别要注意：这种方法对于，如果要删除的节点是头结点的方式，并不适用 * * @param head * @param value * @return */</span><span class="token keyword">public</span> ListNode <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里陷阱很多，要特别注意测试用例为"要删除的节点值连续出现在链表表头的情况"</span>    <span class="token comment" spellcheck="true">// 例如，待考察链表 {1, 1, 1, 2, 3, 4, 5} ，待删除的元素的值是 1 的情况</span>    <span class="token comment" spellcheck="true">// 为了删除头结点，我们编写了很长的一段代码</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode delNode <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        delNode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode current <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode delNode <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            current<span class="token punctuation">.</span>next <span class="token operator">=</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            delNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面介绍一种设立链表的虚拟头结点的技巧，使得删除头结点的逻辑可以合并到删除非链表头结点的逻辑中。<br>思路很简单，就是在带考察的链表前面加上一个虚拟节点，使得原来的头结点不是头结点。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dummyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode current <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode delNode <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            current<span class="token punctuation">.</span>next <span class="token operator">=</span> delNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            delNode <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    ListNode retNode <span class="token operator">=</span> dummyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    dummyHead <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">return</span> retNode<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路：</p><p>1、使用虚拟头结点；</p><p>2、<strong>掌握递归写法</strong>。</p><p>重点：千万不要忘记，还有递归写法。</p><p>Python 代码：使用递归，假设小一个规模的问题已经求解，然后处理原问题。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :type val: int        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        head<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>removeElements<span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span>        <span class="token keyword">return</span> head<span class="token punctuation">.</span>next <span class="token keyword">if</span> head<span class="token punctuation">.</span>val <span class="token operator">==</span> val <span class="token keyword">else</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先处理递归到底的情况，直接返回 null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 假设下一个结点开始的链表已经处理完了</span>    ListNode res <span class="token operator">=</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 再将头结点和除了头结点以外的链表部分合并考虑</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> res<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1：「力扣」第-82-题：删除排序链表中的元素-II"><a href="#练习1：「力扣」第-82-题：删除排序链表中的元素-II" class="headerlink" title="练习1：「力扣」第 82 题：删除排序链表中的元素 II"></a>练习1：「力扣」第 82 题：删除排序链表中的元素 II</h3><p>传送门：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a>。</p><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p><p><strong>示例 1:</strong></p><pre><code>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3</code></pre></blockquote><p>关键：要两个两个一起判断。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head        cur <span class="token operator">=</span> dummy        <span class="token keyword">while</span> cur<span class="token punctuation">.</span>next <span class="token operator">and</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 继续往后看，有没有相等的元素</span>                <span class="token comment" spellcheck="true"># del_node 至少删掉它</span>                del_node <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next                <span class="token keyword">while</span> del_node<span class="token punctuation">.</span>next <span class="token operator">and</span> del_node<span class="token punctuation">.</span>val <span class="token operator">==</span> del_node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                    del_node <span class="token operator">=</span> del_node<span class="token punctuation">.</span>next                <span class="token comment" spellcheck="true"># 开始删除操作</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> del_node<span class="token punctuation">.</span>next                del_node<span class="token punctuation">.</span>next <span class="token operator">=</span> None            <span class="token keyword">else</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习2：「力扣」第-21-题：合并两个有序链表"><a href="#练习2：「力扣」第-21-题：合并两个有序链表" class="headerlink" title="练习2：「力扣」第 21 题：合并两个有序链表"></a>练习2：「力扣」第 21 题：合并两个有序链表</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">21. Merge Two Sorted Lists</a>  ，中文网址：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">21. 合并两个有序链表</a>  。</p><p>分析：归并两个有序的链表，还是穿针引线的问题，用递归也可以做。</p><p>Java 代码：使用递归最简单。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution3</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 使用递归     *     * @param l1 有序链表     * @param l2 有序链表     * @return 有序链表     */</span>    <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            l1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            l2<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：使用穿针引线。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * https://leetcode-cn.com/problems/merge-two-sorted-lists/description/ */</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"arr can not be empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" -> "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @author liwei */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode p1 <span class="token operator">=</span> l1<span class="token punctuation">;</span>        ListNode p2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>        ListNode curNode <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 两者都不为空的时候，才有必要进行比较</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 指针修改发生在这里</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>                p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 指针修改发生在这里</span>                curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span>                p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 跳出循环是因为 p1 == null 或者 p2 == null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「链表」专题 2：测试的链表程序</title>
      <link href="/leetcode-algo/2017/07/17/leetcode-solution/linked-list-2/"/>
      <url>/leetcode-algo/2017/07/17/leetcode-solution/linked-list-2/</url>
      
        <content type="html"><![CDATA[<h2 id="「链表」专题-2：测试的链表程序"><a href="#「链表」专题-2：测试的链表程序" class="headerlink" title="「链表」专题 2：测试的链表程序"></a>「链表」专题 2：测试的链表程序</h2><p>为了测试我们写的代码是否正确，我们需要自己写两个个方法，这两个方法对于调试代码来说是十分有帮助的。</p><h3 id="编写辅助函数：通过一个数组创建一个链表"><a href="#编写辅助函数：通过一个数组创建一个链表" class="headerlink" title="编写辅助函数：通过一个数组创建一个链表"></a>编写辅助函数：通过一个数组创建一个链表</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">createLinkedList</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode current <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把这个迭代想象成一个动画去理解，就很好理解了</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        current<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对代码的说明</p><p>1、先创建头结点，在把头结点设置为当前节点，然后开始遍历，几乎成为了一个套路；</p><p>2、<code>current = current.next;</code> 表示指针后移，模板代码；</p><p>3、用头结点就可以代表一个链表，所以返回的是 <code>head</code>。</p><p>注意：要考虑到数组为空的情况。</p><h3 id="编写辅助函数：通过一个链表的头结点打印一个链表"><a href="#编写辅助函数：通过一个链表的头结点打印一个链表" class="headerlink" title="编写辅助函数：通过一个链表的头结点打印一个链表"></a>编写辅助函数：通过一个链表的头结点打印一个链表</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printLinkedList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>    ListNode current <span class="token operator">=</span>  head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d -> "</span><span class="token punctuation">,</span>current<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"NULL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们在 main 函数中测试一下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode list1 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">createLinkedList</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    solution<span class="token punctuation">.</span><span class="token function">printLinkedList</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode list2 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">reverseList</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span><span class="token punctuation">;</span>    solution<span class="token punctuation">.</span><span class="token function">printLinkedList</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1：「力扣」第-83-题：从一个有序的列表中删除重复的元素"><a href="#练习1：「力扣」第-83-题：从一个有序的列表中删除重复的元素" class="headerlink" title="练习1：「力扣」第 83 题：从一个有序的列表中删除重复的元素"></a>练习1：「力扣」第 83 题：从一个有序的列表中删除重复的元素</h3><p>传送门：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list" target="_blank" rel="noopener">删除排序链表中的重复元素</a>。</p><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p><strong>示例 1:</strong></p><pre><code>输入: 1-&gt;1-&gt;2输出: 1-&gt;2</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3</code></pre></blockquote><p>思路：有序链表，相同元素最多保留 $1$ 个。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for singly-linked list.</span><span class="token comment" spellcheck="true"># class ListNode(object):</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.next = None</span><span class="token comment" spellcheck="true"># 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</span><span class="token comment" spellcheck="true"># 【判断的条件是"下一个结点"】</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token comment" spellcheck="true"># 先判断极端条件</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        cur <span class="token operator">=</span> head        <span class="token keyword">while</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next            <span class="token keyword">if</span> next<span class="token punctuation">.</span>val <span class="token operator">==</span> cur<span class="token punctuation">.</span>val<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># q 向后挪动一位</span>                cur<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next                next<span class="token punctuation">.</span>next <span class="token operator">=</span> None            <span class="token keyword">else</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习2：「力扣」第-86-题：分割链表"><a href="#练习2：「力扣」第-86-题：分割链表" class="headerlink" title="练习2：「力扣」第 86 题：分割链表"></a>练习2：「力扣」第 86 题：分割链表</h3><p>英文网址：<a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">86. Partition List</a>  ，中文网址：<a href="https://leetcode-cn.com/problems/partition-list/description/" target="_blank" rel="noopener">86. 分隔链表</a>。</p><blockquote><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p><strong>示例:</strong></p><pre><code>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code></pre></blockquote><p>思路：分别拿两个虚拟头结点，最后拼在一起。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 空间复杂度为常数的解法：穿针引线</span>    <span class="token keyword">public</span> ListNode <span class="token function">partition</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 比 x 小的虚拟头结点</span>        ListNode dummyNodeL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 大于等于 x 的虚拟头结点</span>        ListNode dummyNodeR <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用于遍历</span>        ListNode curL <span class="token operator">=</span> dummyNodeL<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用于遍历</span>        ListNode curR <span class="token operator">=</span> dummyNodeR<span class="token punctuation">;</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            val <span class="token operator">=</span> head<span class="token punctuation">.</span>val<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                curL<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                curL <span class="token operator">=</span> curL<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                curR<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>                curR <span class="token operator">=</span> curR<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        curL<span class="token punctuation">.</span>next <span class="token operator">=</span> dummyNodeR<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 特别注意：最后这一步不能忘记，否则会产生一个循环链表</span>        curR<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummyNodeL<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        ListNode head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution2 solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分隔链表之后："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode partition <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>partition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习3：「力扣」第-328-题：奇数（Odd）偶数（Even）链表"><a href="#练习3：「力扣」第-328-题：奇数（Odd）偶数（Even）链表" class="headerlink" title="练习3：「力扣」第 328 题：奇数（Odd）偶数（Even）链表"></a>练习3：「力扣」第 328 题：奇数（Odd）偶数（Even）链表</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">328. Odd Even Linked List</a> ，中文网址：<a href="https://leetcode-cn.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">328. 奇偶链表</a> 。</p><blockquote><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</code></pre><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul></blockquote><p>思路：题目要求<strong>原地算法</strong>完成，那么就一定得“穿针引线”了。</p><ul><li>方法1：可以使用 <a href="https://liweiwei1419.github.io/leetcode-solution/leetcode-0086-partition-list/" target="_blank" rel="noopener">LeetCode 第 86 题题解思路 2 </a>完成。</li><li>方法2：同样使用两个指针，一次跳过一个节点完成“穿针引线”，特别注意要一些边界情况的判断。</li></ul><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/328-1.jpg" alt="LeetCode 第 328 题：奇数（Odd）偶数（Even）链表"></p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type head: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> None <span class="token operator">or</span> head<span class="token punctuation">.</span>next <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> head        <span class="token comment" spellcheck="true"># odd 奇数</span>        odd_head <span class="token operator">=</span> head        even_head <span class="token operator">=</span> head<span class="token punctuation">.</span>next        odd_cur <span class="token operator">=</span> odd_head        even_cur <span class="token operator">=</span> even_head        <span class="token keyword">while</span> even_cur <span class="token operator">and</span> even_cur<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            odd_cur<span class="token punctuation">.</span>next <span class="token operator">=</span> odd_cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            even_cur<span class="token punctuation">.</span>next <span class="token operator">=</span> even_cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next            odd_cur <span class="token operator">=</span> odd_cur<span class="token punctuation">.</span>next            even_cur <span class="token operator">=</span> even_cur<span class="token punctuation">.</span>next        odd_cur<span class="token punctuation">.</span>next <span class="token operator">=</span> even_head        <span class="token keyword">return</span> odd_head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我还写过一个题解在<a href="https://liweiwei1419.github.io/leetcode-solution/leetcode-0328-odd-even-linked-list/" target="_blank" rel="noopener">这里</a>，可以参考一下。</p><h3 id="练习4：「力扣」第-2-题：两个数相加"><a href="#练习4：「力扣」第-2-题：两个数相加" class="headerlink" title="练习4：「力扣」第 2 题：两个数相加"></a>练习4：「力扣」第 2 题：两个数相加</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">2. Add Two Numbers</a>  ，中文网址：<a href="https://leetcode-cn.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">2. 两数相加</a>  。</p><blockquote><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre></blockquote><p>思路：需要考虑的问题：</p><p>1、数字中是否有前置的 $0$（除了 $0$ 以外，没有前置的 $0$）；</p><p>2、负数是否考虑。</p><p>编码过程中需要思考的问题：</p><p>1、如何分别获得这个数组的个位、十位、百位、千位；</p><p>2、分别相加，如果大于 $10$，进一。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        """</span>        <span class="token keyword">if</span> l1 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> l2        <span class="token keyword">if</span> l2 <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> l1        dummy_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        cur_node <span class="token operator">=</span> dummy_node        s <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 只要二者之一非空，就加下去</span>        <span class="token keyword">while</span> l1 <span class="token operator">or</span> l2<span class="token punctuation">:</span>            <span class="token keyword">if</span> l1<span class="token punctuation">:</span>                s <span class="token operator">+=</span> l1<span class="token punctuation">.</span>val                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next            <span class="token keyword">if</span> l2<span class="token punctuation">:</span>                s <span class="token operator">+=</span> l2<span class="token punctuation">.</span>val                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next            cur_node<span class="token punctuation">.</span>next <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>s <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span>            s <span class="token operator">//=</span> <span class="token number">10</span>            cur_node <span class="token operator">=</span> cur_node<span class="token punctuation">.</span>next        <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            cur_node<span class="token punctuation">.</span>next <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dummy_node<span class="token punctuation">.</span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习5：「力扣」第-445-题：两个数相加"><a href="#练习5：「力扣」第-445-题：两个数相加" class="headerlink" title="练习5：「力扣」第 445 题：两个数相加"></a>练习5：「力扣」第 445 题：两个数相加</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">445. Add Two Numbers II</a>  ，中文网址：<a href="https://leetcode-cn.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">445. 两数相加 II</a>  。</p><blockquote><p>给定两个<strong>非空</strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>进阶:</strong></p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p><strong>示例:</strong></p><pre><code>输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</code></pre></blockquote><p>思路：需要考虑的问题是如果不允许修改输入的链表该怎么办；使用一个辅助的数据结构来完成。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        """</span>        stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        p1 <span class="token operator">=</span> l1        p2 <span class="token operator">=</span> l2        <span class="token keyword">while</span> p1<span class="token punctuation">:</span>            stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p1<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next        <span class="token keyword">while</span> p2<span class="token punctuation">:</span>            stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p2<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        s <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> stack1 <span class="token operator">or</span> stack2<span class="token punctuation">:</span>            <span class="token keyword">if</span> stack1<span class="token punctuation">:</span>                s <span class="token operator">+=</span> stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> stack2<span class="token punctuation">:</span>                s <span class="token operator">+=</span> stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span>            s <span class="token operator">//=</span> <span class="token number">10</span>        <span class="token keyword">if</span> s <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        head <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>res<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        cur_node <span class="token operator">=</span> head        <span class="token keyword">while</span> len<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">:</span>            cur_node<span class="token punctuation">.</span>next <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>res<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            cur_node <span class="token operator">=</span> cur_node<span class="token punctuation">.</span>next        <span class="token keyword">return</span> head<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「链表」专题 1：在链表中穿针引线</title>
      <link href="/leetcode-algo/2017/07/16/leetcode-solution/linked-list-1/"/>
      <url>/leetcode-algo/2017/07/16/leetcode-solution/linked-list-1/</url>
      
        <content type="html"><![CDATA[<h2 id="「链表」专题-1：在链表中穿针引线"><a href="#「链表」专题-1：在链表中穿针引线" class="headerlink" title="「链表」专题 1：在链表中穿针引线"></a>「链表」专题 1：在链表中穿针引线</h2><p>准备算法面试一定不能忽略基础，算法面试中链表的问题是经常出现的。</p><p>链表是一种特殊的线性结构，由于不能像数组一样进行随机的访问，所以和链表相关的问题有他自身的特点。我将之称为穿针引线。我们在这一章，就来看一看，如何在链表中穿针引线。</p><h3 id="例1：「力扣」第-206-题：反转链表"><a href="#例1：「力扣」第-206-题：反转链表" class="headerlink" title="例1：「力扣」第 206 题：反转链表"></a>例1：「力扣」第 206 题：反转链表</h3><p>传送门：<a href="https://leetcode-cn.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">反转链表</a>。</p><blockquote><p>反转一个单链表。</p><p><strong>示例:</strong></p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p></blockquote><p>分析：分析这道问题的时候写的草稿。</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/206-1.jpg" alt="LeetCode 第 206 题：反转链表"></p><p>题目的要求是节点是不动的，而应该改变的是节点的 next 指针的方向。而不应该是去修改链表的值，使得这个新的链表看起来是反向的。指针变化的过程其实并不复杂，关键是我们把图画出来，需要多少个临时变量，指针变化过程也就一目了然了。我们可以看到，reverseList 的参数是一个 ListNode 类型的对象，即对象的头结点。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 1、结合自己画的图并不难写出逻辑，把图画出来，迭代的思路就已经有了     * 2、借助三个指针：pre、current、next 完成链表的反转     * 3、     * @param head     * @return     */</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化上一个指针</span>        ListNode pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 初始化当前指针</span>        ListNode current <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 第 1 步：先把 next 存起来，下一轮迭代要用到</span>            ListNode next <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第 2 步：实现当前节点的 next 指针的反转</span>            current<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第 3 步：重新定义下一轮迭代的循环变量</span>            pre <span class="token operator">=</span> current<span class="token punctuation">;</span>            current <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 遍历完成以后，原来的最后一个节点就成为了 pre</span>        <span class="token comment" spellcheck="true">// 这个 pre 就是反转以后的新的链表的头指针</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看代码是不是很简单。这个解法的时间复杂度是 $O(n)$，因为它仅仅遍历了一次链表，空间复杂度是$O(1)$，因为这里仅仅使用了有限个的“指针”，帮助我们完成了链表的反转操作。</p><p>补充：如果不使用“穿针引线”，还可以用递归完成。</p><h3 id="练习1：「力扣」第-92-题：反转从位置-m-到-n-的链表，k-个组进行一次反转"><a href="#练习1：「力扣」第-92-题：反转从位置-m-到-n-的链表，k-个组进行一次反转" class="headerlink" title="练习1：「力扣」第 92 题：反转从位置 m 到 n 的链表，k 个组进行一次反转"></a>练习1：「力扣」第 92 题：反转从位置 m 到 n 的链表，k 个组进行一次反转</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="noopener">92. Reverse Linked List II</a>  ，中文网址：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="noopener">92. 反转链表 II</a>  。</p><blockquote><p>反转一个单链表。</p><p><strong>示例:</strong></p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/414598-f83685e15724a1d7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="LeetCode 第 92 题：反转从位置 m 到 n 的链表，k 个组进行一次反转-1"></p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个虚拟的结点（dummy）</span>        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>k <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// tail 是尾巴的意思</span>        ListNode tail <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>k <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode temp <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            tail<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// pre 指针向后移动</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// System.out.println(pre.val);</span>        ListNode p <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode curNode<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curNode <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> curNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            curNode<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> curNode<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置 dummyNode 是这一类问题的一般做法</span>    ListNode dummyNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dummyNode<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode pre <span class="token operator">=</span> dummyNode<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode cur <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    ListNode next<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        next<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dummyNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种解法：来自“小吴”的动图，比较自然，但是代码写起来不够简洁。</p><p>图示：</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/0092.gif" alt="LeetCode 第 92 题：反转从位置 m 到 n 的链表，k 个组进行一次反转-2"></p><p>Python 代码：<br><img src="https://liweiwei1419.gitee.io/images/leetcode-solution/0092.png" alt="LeetCode 第 92 题：反转从位置 m 到 n 的链表，k 个组进行一次反转-3"></p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 6：链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 167 题：两数之和 II - 输入有序数组</title>
      <link href="/leetcode-algo/2017/07/07/leetcode-algo/search-insert-position/"/>
      <url>/leetcode-algo/2017/07/07/leetcode-algo/search-insert-position/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-167-题：两数之和-II-输入有序数组"><a href="#「力扣」第-167-题：两数之和-II-输入有序数组" class="headerlink" title="「力扣」第 167 题：两数之和 II - 输入有序数组"></a>「力扣」第 167 题：两数之和 II - 输入有序数组</h2><p>题解地址：<a href="">双指针对撞 + 二分法（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a>。</p><blockquote><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h2 id="双指针对撞-二分法（Python-代码、Java-代码）"><a href="#双指针对撞-二分法（Python-代码、Java-代码）" class="headerlink" title="双指针对撞 + 二分法（Python 代码、Java 代码）"></a>双指针对撞 + 二分法（Python 代码、Java 代码）</h2><h3 id="方法一：指针对撞"><a href="#方法一：指针对撞" class="headerlink" title="方法一：指针对撞"></a>方法一：指针对撞</h3><p><strong>思路分析</strong>：</p><p>这个思路我感觉比较“显然”，甚至说不出什么道理来。</p><p><strong>参考代码</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def twoSum(self, numbers: List[int], target: int) -> List[int]:        size = len(numbers)        left = 0        right = size - 1        while left < right:            if numbers[left] + numbers[right] > target:                right -= 1            elif numbers[left] + numbers[right] < target:                left += 1            else:                return [left + 1, right + 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public int[] twoSum(int[] numbers, int target) {        int left = 0;        int right = numbers.length - 1;        while (left < right) {            int sum = numbers[left] + numbers[right];            if (sum == target) {                return new int[]{left + 1, right + 1};            } else if (sum > target) {                right--;            } else {                left++;            }        }        throw new RuntimeException("在数组中没有找到这样的两个数，使得它们的和为指定值");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，这里 $N$ 表示数组中的元素的大小。</li><li>空间复杂度：$O(1)$，只使用了常数个变量。</li></ul><p>既然是有序数组，不妨考虑使用二分查找。</p><h3 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h3><p><strong>思路分析</strong>：</p><p>二分查找，起点得固定，因此，外面要套上一层循环。</p><p><strong>参考代码</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def twoSum(self, numbers: List[int], target: int) -> List[int]:        size = len(numbers)        for left in range(size - 1):            right = self.__binary_search(numbers, left + 1, size - 1, target - numbers[left])            if right != -1:                return [left + 1, right + 1]    def __binary_search(self, numbers, left, right, target):        # 在子区间 [left, right] 找 target        while left < right:            mid = (left + right) >> 1            if numbers[mid] < target:                left = mid + 1            else:                right = mid        return left if numbers[left] == target else -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public int[] twoSum(int[] numbers, int target) {        int len = numbers.length;        // 最后一个数不会成为起始的数字        for (int left = 0; left < numbers.length - 1; left++) {            // 挨个二分查找            int right = binarySearch(numbers, left + 1, len - 1, target - numbers[left]);            if (right != -1) {                return new int[]{left + 1, right + 1};            }        }        throw new RuntimeException("在数组中没有找到这样的两个数，使得它们的和为指定值");    }    public int binarySearch(int[] nums, int left, int right, int target) {        while (left < right) {            int mid = (left + right) >>>  1;            if (nums[mid] < target) {                left = mid + 1;            } else {                right = mid;            }        }        if (nums[left] == target) {            return left;        }        return -1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N \log N)$，这里 $N$ 表示数组中的元素的大小，外层循环是线性时间复杂度，内层循环是对数级别的时间复杂度。</li><li>空间复杂度：$O(1)$，只使用了常数个变量。</li></ul><hr><h3 id="「力扣」-第-167-题：两数之和-II-输入有序数组"><a href="#「力扣」-第-167-题：两数之和-II-输入有序数组" class="headerlink" title="「力扣」 第 167 题：两数之和 II - 输入有序数组"></a>「力扣」 第 167 题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="noopener">两数之和 II - 输入有序数组</a></h3><p>传送门：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a>。</p><p>题解：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/shuang-zhi-zhen-dui-zhuang-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">双指针对撞 + 二分法（Python 代码、Java 代码）</a></p><blockquote><p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><pre><code>输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</code></pre></blockquote><p>分析：看到有序，第 1 想到「二分查找」，但是我们这题，用「指针对撞」更合适。当然用哈希表也是可以的，不过哈希表的方法没有用到数组的有序性。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numbers<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type numbers: List[int]        :type target: int        :rtype: List[int]        """</span>        <span class="token comment" spellcheck="true"># 有序数组，index1 必须小于 index2，用指针对撞是最合适的</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            <span class="token keyword">if</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> res<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span>  <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"输入数据有误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LeetCode-第-167-题：两数之和-II-输入有序数组"><a href="#LeetCode-第-167-题：两数之和-II-输入有序数组" class="headerlink" title="LeetCode 第 167 题：两数之和 II - 输入有序数组"></a>LeetCode 第 167 题：两数之和 II - 输入有序数组</h3><p>传送门：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a>。</p><blockquote><p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><pre><code>输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</code></pre></blockquote><p>分析：看到有序，第 1 想到“二分查找”，但是我们这题，用“指针对撞”更合适。当然用哈希表也是可以的，不过哈希表的方法没有用到数组的有序性。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numbers<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type numbers: List[int]        :type target: int        :rtype: List[int]        """</span>        <span class="token comment" spellcheck="true"># 有序数组，index1 必须小于 index2，用指针对撞是最合适的</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            <span class="token keyword">if</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> res<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span>  <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"输入数据有误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 5：双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 125 题：验证回文串</title>
      <link href="/leetcode-algo/2017/07/06/leetcode-solution/0125-valid-palindrome/"/>
      <url>/leetcode-algo/2017/07/06/leetcode-solution/0125-valid-palindrome/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-125-题：验证回文串"><a href="#「力扣」第-125-题：验证回文串" class="headerlink" title="「力扣」第 125 题：验证回文串"></a>「力扣」第 125 题：验证回文串</h2><p>传送门：英文网址：<a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">125. Valid Palindrome</a> ，中文网址：<a href="https://leetcode-cn.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">125. 验证回文串</a> 。</p><blockquote><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;race a car&quot;输出: false</code></pre></blockquote><p>Python 代码：注意编码的细节</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: bool        """</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            left <span class="token operator">+=</span> <span class="token number">1</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Leetcode-第-125-题：验证回文串"><a href="#Leetcode-第-125-题：验证回文串" class="headerlink" title="Leetcode 第 125 题：验证回文串"></a>Leetcode 第 125 题：验证回文串</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">125. Valid Palindrome</a> ，中文网址：<a href="https://leetcode-cn.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">125. 验证回文串</a> 。</p><blockquote><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;race a car&quot;输出: false</code></pre></blockquote><p>Python 代码：注意一写编码的细节</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: bool        """</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            left <span class="token operator">+=</span> <span class="token number">1</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 5：双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> partition </tag>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 88 题：合并两个有序数组</title>
      <link href="/leetcode-algo/2017/07/05/leetcode-solution/0088-merge-sorted-array/"/>
      <url>/leetcode-algo/2017/07/05/leetcode-solution/0088-merge-sorted-array/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-88-题：合并两个有序数组"><a href="#「力扣」第-88-题：合并两个有序数组" class="headerlink" title="「力扣」第 88 题：合并两个有序数组"></a>「力扣」第 88 题：合并两个有序数组</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/si-xiang-mei-you-chuang-xin-de-di-fang-zhu-yao-ti-/" target="_blank" rel="noopener">思路没有创新的地方，主要提供逻辑清楚的代码和编码细节（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a>。</p><blockquote><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]</p></blockquote><h2 id="思路没有创新的地方，主要提供逻辑清楚的代码和编码细节（Python-代码、Java-代码）"><a href="#思路没有创新的地方，主要提供逻辑清楚的代码和编码细节（Python-代码、Java-代码）" class="headerlink" title="思路没有创新的地方，主要提供逻辑清楚的代码和编码细节（Python 代码、Java 代码）"></a>思路没有创新的地方，主要提供逻辑清楚的代码和编码细节（Python 代码、Java 代码）</h2><p><strong>思路分析</strong>：</p><p>合并两个有序数组是归并排序的子过程。学习过归并排序的朋友们，解决这个问题一定不在话下。</p><p><img src="https://pic.leetcode-cn.com/a5e5b52070e7fb4aaef2a7f4eff293590fca47a5728dff3ffa0fcaa9803cca0b-0088-from-left-to-right.gif" alt="0088-from-left-to-right.gif"></p><p>这道题的说明：</p><blockquote><p>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p></blockquote><p>就暗示我们其实可以从后向前归并。</p><p><img src="https://pic.leetcode-cn.com/a31928e6a54cb8593e5a652a5abd96ca1f3f2d89358eaa146c4eb7a3aee4ef4e-0088-from-right-to-left.gif" alt="0088-from-right-to-left.gif"></p><p>思想并不难，主要在编码上要注意一些细节。</p><p><strong>编码细节</strong>：</p><ul><li>下面的代码使用 <code>for</code> 循环表示我们一个一个确定归并以后的数；</li><li>在 <code>for</code> 循环内用 <code>if elseif else</code> 结构，保证一次只会执行一个分支；</li><li>为保证逻辑清晰，个人不建议写 <code>nums[i++]</code> 这样的代码，一行代码只执行一个逻辑，另外我看到 <code>i++</code> 或者 <code>++i</code> 脑子里还要先想一想，位于数组索引位置的时候到底是先加还是后加，我们不应该且没有必要给别人阅读代码造成理解上的一点点小麻烦，不过本人尊重任何个人的编码风格和习惯；</li><li>分支里面先写其中一个指针遍历完成的逻辑，否则会发生数组下标越界：<strong>把 <code>i</code> 先用完，<code>j</code> 先用完的逻辑写在开头是为了防止数组下标越界，这一点不论是从前向后归并还是从后向前归并来说都是一致的</strong>；</li><li><strong>从后向前归并的时候，如果 nums2 数组用完了，可以直接结束算法，因为算法如果执行下去，也是数组 nums1 自己给自己赋值，还要执行相应的判断</strong>，<strong>没有必要</strong>。  </li></ul><h3 id="方法一：从头到尾归并"><a href="#方法一：从头到尾归并" class="headerlink" title="方法一：从头到尾归并"></a>方法一：从头到尾归并</h3><p><strong>参考代码 1</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:        """        Do not return anything, modify nums1 in-place instead.        """        # 只需要把 nums1 的有效个元素复制到 nums3 就可以了        nums3 = nums1[:m]        i = 0        j = 0        # 从前向后归并，比较 nums3 和 nums2 前端的元素哪个小，谁小谁出列，覆盖 nums1        for k in range(m + n):            # 注意：要把 nums3 和 nums2 归并完成的逻辑写在前面，否则会出现数组下标越界异常            if i == m:                nums1[k] = nums2[j]                j += 1            elif j == n:                nums1[k] = nums3[i]                i += 1            elif nums3[i] < nums2[j]:                nums1[k] = nums3[i]                i += 1            else:                nums1[k] = nums2[j]                j += 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public void merge(int[] nums1, int m, int[] nums2, int n) {        int[] nums3 = new int[m];        // 只需要把 nums1 的有效个元素复制到 nums3 就可以了        System.arraycopy(nums1, 0, nums3, 0, m);        // 数组3        int i = 0;        // 数组2        int j = 0;        int length = m + n;        // 从前向后归并，比较 nums3 和 nums2 前端的元素哪个小，谁小谁出列，覆盖 nums1        for (int k = 0; k < length; k++) {            // 注意：要把 nums3 和 nums2 归并完成的逻辑写在前面，否则会出现数组下标越界异常            if (i == m) {                nums1[k] = nums2[j];                j++;            } else if (j == n) {                nums1[k] = nums3[i];                i++;            } else if (nums3[i] < nums2[j]) {                nums1[k] = nums3[i];                i++;            } else {                nums1[k] = nums2[j];                j++;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(M + N)$，这里 $M$ 是数组 nums1 的长度，$N$ 是数组 nums2 的长度。</li><li>空间复杂度：$O(M)$，这里 $M$ 是 nums1 的长度。</li></ul><h3 id="方法二：从尾到头归并（更省空间，并且可以提前终止归并）"><a href="#方法二：从尾到头归并（更省空间，并且可以提前终止归并）" class="headerlink" title="方法二：从尾到头归并（更省空间，并且可以提前终止归并）"></a>方法二：从尾到头归并（更省空间，并且可以提前终止归并）</h3><p>注意 1：从后向前归并，先写数组下标用完的逻辑，否则会出现数组下标异常；</p><p>注意 2：当 nums2 数组所有的数都看完的时候，算法终止。</p><p><strong>参考代码 2</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:        """        Do not return anything, modify nums1 in-place instead.        """        i = m - 1        j = n - 1        # 从后向前归并，比较 nums1 和 nums2 末尾的元素哪个大，谁大谁出列，覆盖 nums1        for k in range(m + n - 1, -1, -1):            # 注意：同样要把 nums1 和 nums2 归并完成的逻辑写在前面，否则会出现数组下标越界异常            if i == -1:                # 这里直接把 nuns2 还没看的元素复制到 nums1 即可                # 我们可以在循环中完成，在 Java 中有更好的方法                nums1[k] = nums2[j]                j -= 1            elif j == -1:                # 注意：这里直接 break 掉就可以了                # 因为 nums2 遍历完成以后，nums1 剩下的元素虽然还没有看，但一定是排定以后的那个样子                break            elif nums1[i] > nums2[j]:                nums1[k] = nums1[i]                i -= 1            else:                nums1[k] = nums2[j]                j -= 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Arrays;/** * 题目中说了，nums1 够用，我可以从后向前归并 * 这道题真正想考查的应该是这种实现方式，我们不能太死板，按照教科书的方式从头归并 * https://leetcode-cn.com/problems/merge-sorted-array/description/ * * @author liwei */public class Solution {    public void merge(int[] nums1, int m, int[] nums2, int n) {        int len = m + n;        int i = m - 1;        int j = n - 1;        // 从后向前归并，比较 nums1 和 nums2 末尾的元素哪个大，谁大谁出列，覆盖 nums1        for (int k = len - 1; k >= 0; k--) {            if (i == -1) {                // 注意：同样要把 nums1 和 nums2 归并完成的逻辑写在前面，否则会出现数组下标越界异常                // 此时 j 位于数组 nums2 的末尾索引位置，还未看的数组 nums2 的长度为 j + 1                // 复制完 break 掉即可                System.arraycopy(nums2, 0, nums1, 0, j + 1);                break;            } else if (j == -1) {                // 注意：这里直接 break 掉就可以了                // 因为 nums2 遍历完成以后，nums1 剩下的元素虽然还没有看，但一定是排定以后的那个样子                break;            } else if (nums1[i] >= nums2[j]) {                // 谁大谁出列                nums1[k] = nums1[i];                i--;            } else {                assert nums1[i] < nums2[j];                nums1[k] = nums2[j];                j--;            }        }    }    public static void main(String[] args) {        int[] nums1 = {1, 2, 3, 0, 0, 0};        int m = 3;        int[] nums2 = {2, 5, 6};        int n = 3;        Solution solution = new Solution();        solution.merge(nums1, m, nums2, n);        System.out.println(Arrays.toString(nums1));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(M + N)$，这里 $M$ 是数组 nums1 的长度，$N$ 是数组 nums2 的长度。</li><li>空间复杂度：$O(1)$，该算法没有使用额外的存储空间，仅使用了常数个临时变量用于比较。</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/si-xiang-mei-you-chuang-xin-de-di-fang-zhu-yao-ti-/" target="_blank" rel="noopener">从后向前归并（Java、Python）</a></li></ul><h3 id="「力扣」第-88-题：合并两个有序数组-1"><a href="#「力扣」第-88-题：合并两个有序数组-1" class="headerlink" title="「力扣」第 88 题：合并两个有序数组"></a>「力扣」第 88 题：合并两个有序数组</h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">88. Merge Sorted Array</a> ，中文网址：<a href="https://leetcode-cn.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">88. 合并两个有序数组</a> 。</p><blockquote><p>给定两个有序整数数组 <em>nums1</em> 和 <em>nums2*，将 *nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使得 <em>num1</em> 成为一个有序数组。</p><p><strong>说明:</strong></p><ul><li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li><li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m + n*）来保存 *nums2</em> 中的元素。</li></ul><p><strong>示例:</strong></p><pre><code>输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6],       n = 3输出: [1,2,2,3,5,6]</code></pre></blockquote><p>分析：其实就是归并排序，不过从后向前归并是这道题的考点。注意分 4 种情况，代码的写法其实是相对固定的。</p><h3 id="方法一：可以使用标准的归并排序来做"><a href="#方法一：可以使用标准的归并排序来做" class="headerlink" title="方法一：可以使用标准的归并排序来做"></a>方法一：可以使用标准的归并排序来做</h3><p>Python 代码：从前向后写</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> m<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums1: List[int]        :type m: int        :type nums2: List[int]        :type n: int        :rtype: void Do not return anything, modify nums1 in-place instead.        """</span>        nums3 <span class="token operator">=</span> nums1<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        i <span class="token operator">=</span> <span class="token number">0</span>        j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">==</span> m<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># i 用完了</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> j <span class="token operator">==</span> n<span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums3<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums3<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums3<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：从后向前归并两个有序数组"><a href="#方法二：从后向前归并两个有序数组" class="headerlink" title="方法二：从后向前归并两个有序数组"></a>方法二：从后向前归并两个有序数组</h3><p>考虑到这道题的特殊性，即 <code>nums1</code> 有足够的空间，因此，我们可以从后向前归并，每次从两个数组的末尾选出最大的元素放在 nums1 的末尾，而不使用额外的数组空间。</p><p>你可能会担心，nums1 之前有效的元素会不会被覆盖掉，但在这题中，这种情况是不可能出现的。在实现的时候，还是要特别注意一些边界条件。</p><p>Python 代码：从后向前写</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> m<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums1: List[int]        :type m: int        :type nums2: List[int]        :type n: int        :rtype: void Do not return anything, modify nums1 in-place instead.        """</span>        i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span>        j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                 nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<code>range(m + n - 1, -1, -1)</code> 表示索引的最大值是 <code>m + n - 1</code> ，最小值是 <code>0</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 5：双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 16 题：最接近的三数之和</title>
      <link href="/leetcode-algo/2017/07/04/leetcode-solution/0016-3sum-closest/"/>
      <url>/leetcode-algo/2017/07/04/leetcode-solution/0016-3sum-closest/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-16-题：最接近的三数之和"><a href="#「力扣」第-16-题：最接近的三数之和" class="headerlink" title="「力扣」第 16 题：最接近的三数之和"></a>「力扣」第 16 题：最接近的三数之和</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/3sum-closest/solution/shuang-zhi-zhen-dui-zhuang-python-dai-ma-java-dai-/" target="_blank" rel="noopener">双指针对撞（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a>。</p><blockquote><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p><p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p></blockquote><h2 id="双指针对撞（Python-代码、Java-代码）"><a href="#双指针对撞（Python-代码、Java-代码）" class="headerlink" title="双指针对撞（Python 代码、Java 代码）"></a>双指针对撞（Python 代码、Java 代码）</h2><p><strong>思路分析</strong>：本题是<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">「力扣」第 15 题：三数之和</a>的扩展问题。求最接近的三数之和，采用双指针对撞的思路。因为题目要求不能出现重复答案，因此首先要对数组排序。</p><p>编码的注意事项和细节已经体现在“参考代码”的注释中。</p><p><strong>参考代码</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def threeSumClosest(self, nums: List[int], target: int) -> int:        size = len(nums)        # 特判        if size < 3:            return []        # 初始化，因为找最小值，因此把初始值设置成实数的最大值        diff = float('inf')        # 排序是前提        nums.sort()        for i in range(size - 2):            # 常见的剪枝操作            if i > 0 and nums[i] == nums[i - 1]:                continue            # 双指针：指针对撞            left = i + 1            right = size - 1            while left < right:                s = nums[i] + nums[left] + nums[right]                if abs(s - target) < diff:                    diff = abs(s - target)                    res = s                # 不管是变小还是变大，尝试的作用是让 s 与 target 更接近                # 即 s 与 target 的绝对值之差越来越小                if s > target:                    # 如果大了，尝试右边界收缩一格，让 target 变小                    right -= 1                elif s < target:                    # 如果小了，尝试左边界收缩一格，让 target 变大                    left += 1                else:                    # 如果已经等于 target 的话, 肯定是最接近的，根据题目要求，返回这三个数的和                    return target        return resif __name__ == '__main__':    nums = [-1, 2, 1, -4]    target = 0    solution = Solution()    result = solution.threeSumClosest(nums, target)    print(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Arrays;public class Solution {    public int threeSumClosest(int[] nums, int target) {        int len = nums.length;        // 特判        if (len < 3) {            throw new IllegalArgumentException("参数错误");        }        // 初始化，因为找最小值，因此把初始值设置成实数的最大值        int diff = Integer.MAX_VALUE;        int res = nums[0] + nums[1] + nums[len - 1];        // 排序是前提，很关键        Arrays.sort(nums);        // len-3 len-2 len-1        for (int i = 0; i < len - 2; i++) {            // 常见的剪枝操作            if (i > 0 && nums[i] == nums[i - 1]) {                continue;            }            // 双指针：指针对撞            int left = i + 1;            int right = len - 1;            while (left < right) {                int sum = nums[i] + nums[left] + nums[right];                // 不管是变小还是变大，尝试的作用是让 sum 与 target 更接近                // 即 s 与 target 的绝对值之差越来越小                if (sum > target) {                    // 如果大了，尝试右边界收缩一格，让 target 变小                    right--;                } else if (sum < target) {                    // 如果小了，尝试左边界收缩一格，让 target 变大                    left++;                } else {                    // 如果已经等于 target 的话, 肯定是最接近的，根据题目要求，返回这三个数的和                    assert sum == target;                    return target;                }                if (Math.abs(sum - target) < diff) {                    diff = Math.abs(sum - target);                    res = sum;                }            }        }        return res;    }    public static void main(String[] args) {        int[] nums = {-1, 2, 1, -4};        int target = 1;        Solution solution = new Solution();        int threeSumClosest = solution.threeSumClosest(nums, target);        System.out.println(threeSumClosest);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N^2)$，这里 $N$ 是数组的长度，排序的时间复杂度是 $O(N \log N)$，外层循环遍历 <code>i</code> ，内层循环指针对撞，时间复杂度是 $O(N^2)$。</li><li>空间复杂度：$O(1)$，指针对撞和保存结果及中间变量的空间都为常数个。</li></ul><Vssue title="3sum-closest"/>]]></content>
      
      
      <categories>
          
          <category> 专题 5：双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 15 题：三数之和</title>
      <link href="/leetcode-algo/2017/07/03/leetcode-algo/0015-3sum/"/>
      <url>/leetcode-algo/2017/07/03/leetcode-algo/0015-3sum/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-15-题：三数之和"><a href="#「力扣」第-15-题：三数之和" class="headerlink" title="「力扣」第 15 题：三数之和"></a>「力扣」第 15 题：三数之和</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum</a></li></ul><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例：</p><pre><code>给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 专题 5：双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 11 题：盛最多水的容器（双指针、贪心算法）</title>
      <link href="/leetcode-algo/2017/07/02/leetcode-solution/0011-container-with-most-water/"/>
      <url>/leetcode-algo/2017/07/02/leetcode-solution/0011-container-with-most-water/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-11-题：盛最多水的容器"><a href="#「力扣」第-11-题：盛最多水的容器" class="headerlink" title="「力扣」第 11 题：盛最多水的容器"></a>「力扣」第 11 题：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">盛最多水的容器</a></h2><p>传送门：英文网址：<a href="https://leetcode.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">11. Container With Most Water</a> ，中文网址：<a href="https://leetcode-cn.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">11. 盛最多水的容器</a> 。</p><blockquote><p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt=""></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例:</strong></p><pre><code>输入: [1,8,6,2,5,4,8,3,7]输出: 49</code></pre></blockquote><p>思路：贪心算法，总是贪心先固定容器的宽度。根据木桶原理（盛水的高度由最短的那块木板决定），<strong>高的那块木板往里面走，只可能让盛水越来越少，但是短板往里面走，却有可能让盛水越来越多</strong>。  </p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type height: List[int]        :rtype: int        """</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            min_h <span class="token operator">=</span> min<span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">*</span> min_h<span class="token punctuation">)</span>            <span class="token keyword">if</span> min_h <span class="token operator">==</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    height <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>maxArea<span class="token punctuation">(</span>height<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 指针对撞、贪心思想</span>    <span class="token comment" spellcheck="true">// 参考解答：https://www.cnblogs.com/zichi/p/5745992.html</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 0 或者 1 的时候，不能形成区间，所以不能形成容器</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这里其实就是木桶原理，取决于最短的那根木板</span>            <span class="token comment" spellcheck="true">// [1,2,3] 3 和 1 之间的长度就是 (3-1=)2</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// height[l] >= height[r]</span>                r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 暴力解法，时间复杂度太高，我们应该使用指针对撞的方法</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考资料：<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/。" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/solution/。</a></p><h3 id="Leetcode-第-11-题：盛最多水的容器"><a href="#Leetcode-第-11-题：盛最多水的容器" class="headerlink" title="Leetcode 第 11 题：盛最多水的容器"></a>Leetcode 第 11 题：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">盛最多水的容器</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">11. Container With Most Water</a> ，中文网址：<a href="https://leetcode-cn.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">11. 盛最多水的容器</a> 。</p><blockquote><p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="http://upload-images.jianshu.io/upload_images/414598-de40fd0f2f3dedee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例:</strong></p><pre><code>输入: [1,8,6,2,5,4,8,3,7]输出: 49</code></pre></blockquote><p>思路：贪心算法，总是贪心先固定容器的宽度。根据木桶原理（盛水的高度由最短的那块木板决定），高的那块木板往里面走，只可能让盛水越来越少，但是短板往里面走，却有可能让盛水越来越多。  </p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 指针对撞、贪心思想</span>    <span class="token comment" spellcheck="true">// 参考解答：https://www.cnblogs.com/zichi/p/5745992.html</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 0 或者 1 的时候，不能形成区间，所以不能形成容器</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这里其实就是木桶原理，取决于最短的那根木板</span>            <span class="token comment" spellcheck="true">// [1,2,3] 3 和 1 之间的长度就是 (3-1=)2</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// height[l] >= height[r]</span>                r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 暴力解法，时间复杂度太高，我们应该使用指针对撞的方法</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type height: List[int]        :rtype: int        """</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            min_h <span class="token operator">=</span> min<span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">*</span> min_h<span class="token punctuation">)</span>            <span class="token keyword">if</span> min_h <span class="token operator">==</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    height <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>maxArea<span class="token punctuation">(</span>height<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考资料：<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/。" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/solution/。</a></p>]]></content>
      
      
      <categories>
          
          <category> 专题 5：双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「双指针」专题：概述与经典问题</title>
      <link href="/leetcode-algo/2017/07/01/leetcode-solution/two-pointers/"/>
      <url>/leetcode-algo/2017/07/01/leetcode-solution/two-pointers/</url>
      
        <content type="html"><![CDATA[<h3 id="「排序算法」专题-5：双指针"><a href="#「排序算法」专题-5：双指针" class="headerlink" title="「排序算法」专题 5：双指针"></a>「排序算法」专题 5：双指针</h3><p>在 LeetCode 上，专门有一个标签，名为“双指针”，有数组中的“双指针”，也有单链表中的“双指针”。</p><p><img src="http://upload-images.jianshu.io/upload_images/414598-bb8f290e58bc7a3f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="LeetCode 上的&quot;双指针&quot;问题"></p><h3 id="例题1：LeetCode-第-167-题：两数之和-II-输入有序数组"><a href="#例题1：LeetCode-第-167-题：两数之和-II-输入有序数组" class="headerlink" title="例题1：LeetCode 第 167 题：两数之和 II - 输入有序数组"></a>例题1：LeetCode 第 167 题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="noopener">两数之和 II - 输入有序数组</a></h3><p>传送门：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a>。</p><blockquote><p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul><p><strong>示例:</strong></p><pre><code>输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</code></pre></blockquote><p>分析：看到有序，第 1 想到“二分查找”，但是我们这题，用“指针对撞”更合适。当然用哈希表也是可以的，不过哈希表的方法没有用到数组的有序性。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> numbers<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type numbers: List[int]        :type target: int        :rtype: List[int]        """</span>        <span class="token comment" spellcheck="true"># 有序数组，index1 必须小于 index2，用指针对撞是最合适的</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            <span class="token keyword">if</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> numbers<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> res<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span>  <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"输入数据有误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习1：Leetcode-第-125-题：验证回文串"><a href="#练习1：Leetcode-第-125-题：验证回文串" class="headerlink" title="练习1：Leetcode 第 125 题：验证回文串"></a>练习1：Leetcode 第 125 题：<a href="https://leetcode-cn.com/problems/valid-palindrome" target="_blank" rel="noopener">验证回文串</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">125. Valid Palindrome</a> ，中文网址：<a href="https://leetcode-cn.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">125. 验证回文串</a> 。</p><blockquote><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;race a car&quot;输出: false</code></pre></blockquote><p>Python 代码：注意编码的细节</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: bool        """</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> <span class="token operator">not</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">False</span>            left <span class="token operator">+=</span> <span class="token number">1</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习2：Leetcode-第-344-题：反转字符串"><a href="#练习2：Leetcode-第-344-题：反转字符串" class="headerlink" title="练习2：Leetcode 第 344 题：反转字符串"></a>练习2：Leetcode 第 344 题：<a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">反转字符串</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/reverse-string/description/" target="_blank" rel="noopener">344. Reverse String</a> ，中文网址：<a href="https://leetcode-cn.com/problems/reverse-string/description/" target="_blank" rel="noopener">344. 反转字符串</a> 。</p><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII" target="_blank" rel="noopener">ASCII</a> 码表中的可打印字符。</p><p><strong>示例 1：</strong></p><pre><code>输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: str        """</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> s        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        l <span class="token operator">=</span> list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 重合在一个就没有交换的必要了，因此是 left &lt; right</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            l<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            left <span class="token operator">+=</span> <span class="token number">1</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习3：Leetcode-第-345-题：反转字符串中的元音字母"><a href="#练习3：Leetcode-第-345-题：反转字符串中的元音字母" class="headerlink" title="练习3：Leetcode 第 345 题：反转字符串中的元音字母"></a>练习3：Leetcode 第 345 题：<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string" target="_blank" rel="noopener">反转字符串中的元音字母</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">345. Reverse Vowels of a String</a> ，中文网址：<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">345. 反转字符串中的元音字母</a> 。</p><blockquote><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;hello&quot;输出: &quot;holle&quot;</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;leetcode&quot;输出: &quot;leotcede&quot;</code></pre><p><strong>说明:</strong><br>元音字母不包含字母”y”。</p></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseVowels</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: str        """</span>        vowels <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token string">'O'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> vowels<span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> vowels<span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="练习4：Leetcode-第-11-题：盛最多水的容器"><a href="#练习4：Leetcode-第-11-题：盛最多水的容器" class="headerlink" title="练习4：Leetcode 第 11 题：盛最多水的容器"></a>练习4：Leetcode 第 11 题：<a href="https://leetcode-cn.com/problems/container-with-most-water" target="_blank" rel="noopener">盛最多水的容器</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">11. Container With Most Water</a> ，中文网址：<a href="https://leetcode-cn.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">11. 盛最多水的容器</a> 。</p><blockquote><p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt=""></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例:</strong></p><pre><code>输入: [1,8,6,2,5,4,8,3,7]输出: 49</code></pre></blockquote><p>思路：贪心算法，总是贪心先固定容器的宽度。根据木桶原理（盛水的高度由最短的那块木板决定），<strong>高的那块木板往里面走，只可能让盛水越来越少，但是短板往里面走，却有可能让盛水越来越多</strong>。  </p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type height: List[int]        :rtype: int        """</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            min_h <span class="token operator">=</span> min<span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">*</span> min_h<span class="token punctuation">)</span>            <span class="token keyword">if</span> min_h <span class="token operator">==</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">:</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    height <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>maxArea<span class="token punctuation">(</span>height<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 指针对撞、贪心思想</span>    <span class="token comment" spellcheck="true">// 参考解答：https://www.cnblogs.com/zichi/p/5745992.html</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 0 或者 1 的时候，不能形成区间，所以不能形成容器</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这里其实就是木桶原理，取决于最短的那根木板</span>            <span class="token comment" spellcheck="true">// [1,2,3] 3 和 1 之间的长度就是 (3-1=)2</span>            <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> area<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// height[l] >= height[r]</span>                r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 暴力解法，时间复杂度太高，我们应该使用指针对撞的方法</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考资料：<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/。" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/solution/。</a></p><p>（本节完）</p><p>在 LeetCode 上，专门有一个标签，名为「双指针」，有数组中的「双指针」，也有单链表中的「双指针」。</p><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><p>「力扣」第 11 题：盛最多水的容器</p><p>「力扣」第 42 题：<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></p><p>题解：<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/bao-li-jie-fa-yi-kong-jian-huan-shi-jian-zhi-zhen-/" target="_blank" rel="noopener">暴力解法、优化、双指针、单调栈</a></p>]]></content>
      
      
      <categories>
          
          <category> 专题 5：双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 438 题：找到字符串中所有字母异位词</title>
      <link href="/leetcode-algo/2017/06/24/leetcode-algo/0438-find-all-anagrams-in-a-string/"/>
      <url>/leetcode-algo/2017/06/24/leetcode-algo/0438-find-all-anagrams-in-a-string/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-438-题：找到字符串中所有字母异位词"><a href="#「力扣」第-438-题：找到字符串中所有字母异位词" class="headerlink" title="「力扣」第 438 题：找到字符串中所有字母异位词"></a>「力扣」第 438 题：找到字符串中所有字母异位词</h2><ul><li>中文网址：<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/description/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a> ；</li><li>英文网址：<a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/description/" target="_blank" rel="noopener">438. Find All Anagrams in a String</a> 。</li></ul><blockquote><p>给定一个字符串 <strong>s</strong> 和一个非空字符串 <strong>p</strong>，找到 <strong>s</strong> 中所有是 <strong>p</strong> 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 <strong>s</strong> 和 <strong>p</strong> 的长度都不超过 20100。</p><p><strong>说明：</strong></p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序。</li></ul><p><strong>示例 1:</strong></p><pre><code>输入:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;输出:[0, 6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</code></pre><p> <strong>示例 2:</strong></p><pre><code>输入:s: &quot;abab&quot; p: &quot;ab&quot;输出:[0, 1, 2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</code></pre></blockquote><p>说明：这是一道使用<strong>滑动窗口</strong>解决的典型问题。虽然标记为简单，但是也不好做。</p><p>思路1：滑动窗口的右边界划过的时候，map 对应的次数减少，左边界划过的时候，map 对应的次数增加。设置一个 distance 变量，表示二者的差距。</p><p>Python 代码：在理解的基础上，记住这个解法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :type p: str 模式串        :rtype: List[int]        """</span>        <span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict        hash <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 滑动窗口的长度</span>        plen <span class="token operator">=</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 预处理</span>        <span class="token keyword">for</span> alpha <span class="token keyword">in</span> p<span class="token punctuation">:</span>            hash<span class="token punctuation">[</span>alpha<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 滑动窗口的左边界</span>        l <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 滑动窗口的右边界</span>        r <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 可以认为是两者的差距</span>        distance <span class="token operator">=</span> plen        <span class="token keyword">while</span> r <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>                distance <span class="token operator">-=</span> <span class="token number">1</span>            hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>            r <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> distance <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l<span class="token punctuation">)</span>            <span class="token keyword">if</span> r <span class="token operator">-</span> l <span class="token operator">==</span> plen<span class="token punctuation">:</span>                <span class="token keyword">if</span> hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    distance <span class="token operator">+=</span> <span class="token number">1</span>                hash<span class="token punctuation">[</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> <span class="token string">"cbaebabacd"</span>    p <span class="token operator">=</span> <span class="token string">"abc"</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>findAnagrams<span class="token punctuation">(</span>s<span class="token punctuation">,</span> p<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：（参考）给 p 做字母频率统计，扫过以后，全部一样，就表示找到一个字母异位词。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :type p: str        :rtype: List[int]        """</span>        plen <span class="token operator">=</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span>        slen <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        scnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">26</span>        pcnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">26</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> alpha <span class="token keyword">in</span> p<span class="token punctuation">:</span>            pcnt<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>alpha<span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> end <span class="token keyword">in</span> range<span class="token punctuation">(</span>slen<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> end <span class="token operator">>=</span> plen<span class="token punctuation">:</span>                scnt<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>end <span class="token operator">-</span> plen<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>            scnt<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> scnt <span class="token operator">==</span> pcnt<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>end <span class="token operator">-</span> plen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> <span class="token string">"cbaebabacd"</span>    p <span class="token operator">=</span> <span class="token string">"abc"</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>findAnagrams<span class="token punctuation">(</span>s<span class="token punctuation">,</span> p<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：与上一版代码等价</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :type p: str        :rtype: List[int]        """</span>        <span class="token comment" spellcheck="true"># 滑动窗口的大小</span>        plen <span class="token operator">=</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span>        slen <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        scnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">26</span>        pcnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">26</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> alpha <span class="token keyword">in</span> p<span class="token punctuation">:</span>            pcnt<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>alpha<span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> end <span class="token keyword">in</span> range<span class="token punctuation">(</span>slen<span class="token punctuation">)</span><span class="token punctuation">:</span>            scnt<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> end <span class="token operator">>=</span> plen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> scnt <span class="token operator">==</span> pcnt<span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>end <span class="token operator">-</span> plen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                scnt<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>end <span class="token operator">-</span> plen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution5</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这种解法从语义上更好理解一些</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">findAnagrams</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cntp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cnts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> plen <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> slen <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 数组 cntp 在预处理以后是不会</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> plen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cntp<span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 数 0 的个数</span>        <span class="token keyword">int</span> same <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cntp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                same<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> slen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 右边界进来的时候全部加 1</span>            <span class="token keyword">char</span> curChar <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            cnts<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cnts<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> cntp<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 右边界进来的时候，正好相等，则两个数组相同的数量加 1</span>                same<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cnts<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> cntp<span class="token punctuation">[</span>curChar <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 右边界进来的时候，s 数组比 p 数组相应位置多 1，也就是说，二者不等，所以相同的数量减 1</span>                same<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> plen<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 计算左边界</span>                <span class="token keyword">int</span> deleteIndex <span class="token operator">=</span> i <span class="token operator">-</span> plen<span class="token punctuation">;</span>                <span class="token keyword">char</span> deleteChar <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>deleteIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 左边界出来的时候，全部减 1</span>                cnts<span class="token punctuation">[</span>deleteChar <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cnts<span class="token punctuation">[</span>deleteChar <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> cntp<span class="token punctuation">[</span>deleteChar <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 滑出去以后相等，所以加 1</span>                    same<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cnts<span class="token punctuation">[</span>deleteChar <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> cntp<span class="token punctuation">[</span>deleteChar <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 滑出去以后，比数组 p 少 1，所以减 1</span>                    same<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>same <span class="token operator">==</span> <span class="token number">26</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i <span class="token operator">-</span> plen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 4：滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 239 题：滑动窗口的最大值</title>
      <link href="/leetcode-algo/2017/06/23/leetcode-algo/0239-sliding-window-maximum/"/>
      <url>/leetcode-algo/2017/06/23/leetcode-algo/0239-sliding-window-maximum/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-239-题：滑动窗口的最大值"><a href="#「力扣」第-239-题：滑动窗口的最大值" class="headerlink" title="「力扣」第 239 题：滑动窗口的最大值"></a>「力扣」第 239 题：滑动窗口的最大值</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/zui-da-suo-yin-dui-shuang-duan-dui-lie-cun-suo-yin/" target="_blank" rel="noopener">最大索引堆 + 双端队列存索引值的思路分析（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a>。</p><blockquote><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口最大值。</p><p>示例:</p><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p><p> 滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br>1 [3  -1  -3] 5  3  6  7       3<br>1  3 [-1  -3  5] 3  6  7       5<br>1  3  -1 [-3  5  3] 6  7       5<br>1  3  -1  -3 [5  3  6] 7       6<br>1  3  -1  -3  5 [3  6  7]      7<br>注意：</p><p>你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p></blockquote><h2 id="最大索引堆-双端队列存索引值的思路分析（Python-代码、Java-代码）"><a href="#最大索引堆-双端队列存索引值的思路分析（Python-代码、Java-代码）" class="headerlink" title="最大索引堆 + 双端队列存索引值的思路分析（Python 代码、Java 代码）"></a>最大索引堆 + 双端队列存索引值的思路分析（Python 代码、Java 代码）</h2><p>这道问题最直接的想法就是“通过切片操作得到滑动窗口”，“切片”是 Python 中的一个操作，即截取一个序列，可以是字符串也可以是列表，中的<strong>连续</strong>子序列，再从中得到最大值，这是暴力解法。</p><ul><li><p>动态得到“滑动窗口”的最大值，有一个数据结构是容易想到的，那就是“堆”（“优先队列”），特别地，应该使用“索引堆”。</p></li><li><p>根据<a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">「力扣」第 155 题：最小栈</a>这个问题的思路，我们想到需要一个辅助的数据结构，当“滑动窗口”在移动的时候，我们直接看这个数据结构，就可以很快知道此时“滑动窗口”的最大值。</p></li></ul><p>面试的时候，写“双端队列”，我肯定两个思路都回答。不写“索引堆”是因为代码量太多，并且“堆”我是写过很多遍，但是还是会写不好的，更别说“索引堆”了。</p><p>“双端队列存索引值”是我参考了众多优秀的题解之后总结出来的，希望我能够解释出使用“双端队列”的合理性。在编写本题解的过程中，由于要解释大佬们是如何想到“双端队列”的，我又想到了“索引堆”，以前学习“索引堆”的时候被这个东西“折磨”过，所以印象比较深，不过我个人觉得“索引堆”的思想更自然直接。</p><h3 id="方法一：双端队列存索引值"><a href="#方法一：双端队列存索引值" class="headerlink" title="方法一：双端队列存索引值"></a>方法一：双端队列存索引值</h3><p>如果不使用“索引堆”要定位要更新的元素的索引，还是有一定技巧的，当然挖掘题目中的已知条件可以帮助我们找到解决方案。</p><p>（1）根据<a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">「力扣」第 155 题：最小栈</a>这个问题的思路，我们想到需要一个辅助的数据结构，当“滑动窗口”在移动的时候，我们直接看这个数据结构，就可以很快知道此时“滑动窗口”的最大值；</p><p>下面这一点是很关键的！</p><blockquote><p>如果“当前考虑的数”比之前来的数还要大，那么之前的数（如果还没有划出“滑动窗口”）就一定不会是“滑动窗口”的最大值，应该把它们移除，因为它们“永远不会有出头之日”。</p></blockquote><p>（2）根据上面的分析，之前的数离开，后来的数加进来，感觉这个数据结构可能是“队列”，但是之前可能还有的数比“当前考虑的数”还要大，还不能出“队列”，感觉这个数据结构还有可能是“栈”（不好意思，又把你绕晕了，不妨先看后面）。又感觉是“队列”，又感觉是“栈”的，我们先停一下，还有一个问题没有解决：左边界出“滑动窗口”的时候怎么办？。</p><p>（3）“左边界出滑动窗口的时候”只有 1 种情况需要考虑，那就是：</p><blockquote><p><strong>左边界恰好就是上一轮循环的滑动窗口的最大值，在这一轮“滑动窗口”右移，它必须被移出</strong>。</p></blockquote><p>“左边界出滑动窗口”，左边界一定比当前考虑的数先进这个辅助的数据结构， 再结合 3（2），我们可以分析出这个辅助的数据结构即要是队列（先进先出），也要是栈（后进先出），因此“双端队列”是首选，因为要检测到左边界移除，左边界的索引很重要，知道索引也就知道了具体的值，<strong>因此“双端队列”里存的应该是数组的索引</strong>。</p><p><strong>参考代码 1</strong>：“滑动窗口”存放的是数组的索引值。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listfrom collections import dequeclass Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:        size = len(nums)        # 特判        if size == 0:            return []        # 结果集        res = []        # 滑动窗口，注意：保存的是索引值        window = deque()        for i in range(size):            # 当元素从左边界滑出的时候，如果它恰恰好是滑动窗口的最大值            # 那么将它弹出            if i >= k and i - k == window[0]:                window.popleft()            # 如果滑动窗口非空，新进来的数比队列里已经存在的数还要大            # 则说明已经存在数一定不会是滑动窗口的最大值（它们毫无出头之日）            # 将它们弹出            while window and nums[window[-1]] <= nums[i]:                window.pop()            window.append(i)            # 队首一定是滑动窗口的最大值的索引            if i >= k - 1:                res.append(nums[window[0]])        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.ArrayDeque;import java.util.ArrayList;import java.util.List;public class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        int len = nums.length;        // 特判        if (len == 0) {            return new int[]{};        }        // 结果集        List<Integer> res = new ArrayList<>();        // 滑动窗口，注意：保存的是索引值        ArrayDeque<Integer> deque = new ArrayDeque<>(k);        for (int i = 0; i < len; i++) {            // 当元素从左边界滑出的时候，如果它恰恰好是滑动窗口的最大值            // 那么将它弹出            if (i >= k && i - k == deque.getFirst()) {                deque.pollFirst();            }            // 如果滑动窗口非空，新进来的数比队列里已经存在的数还要大            // 则说明已经存在数一定不会是滑动窗口的最大值（它们毫无出头之日）            // 将它们弹出            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {                deque.pollLast();            }            deque.add(i);            // 队首一定是滑动窗口的最大值的索引            if (i >= k - 1) {                res.add(nums[deque.peekFirst()]);            }        }        int size = res.size();        int[] result = new int[size];        for (int i = 0; i < size; i++) {            result[i] = res.get(i);        }        return result;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：使用最大索引堆"><a href="#方法二：使用最大索引堆" class="headerlink" title="方法二：使用最大索引堆"></a>方法二：使用最大索引堆</h3><p>动态得到“滑动窗口”的最大值，有一个数据结构是容易想到的，那就是“堆”（“优先队列”），但是问题来了。<strong>当“滑动窗口”要把左边界移除的时候，我们虽然左边界是哪个元素，但是没有从一个堆中移除非最堆顶元素的操作</strong>，于是我就想“索引堆”可不可以呢？找到即将要滑出边界的那个索引，更新一下它的值就好，那么索引值如何更新呢？在纸上写一写，你就会发现规律：<strong>新进来的那个数的索引，把自己这个索引对 $k$ 取模的那个索引更新一下就好了</strong>。</p><blockquote><p>使用“索引堆”的原因：“索引堆”有一个更新操作，可以针对某个索引更新它的值，然后索引发生调整，使得索引数组组成最大堆。<strong>因为能方便地定位到某个元素，因此可以在新进来一个数的时候，使用更新操作，把马上要出“滑动窗口”的那个索引位置上的值更新成新进来的这个数的值就可以了（说起来很拗口，看代码会简洁很多）。</strong></p></blockquote><p><img src="https://pic.leetcode-cn.com/48079c3b0136326886cf00ccf0b70c37f5a6dc4756cdcee6e1fc6e9d79a4b781-239-1.png" alt="239-1.png"></p><p>不过很纠结的是 Python 和 Java 都没有现成的“索引堆”，需要自己编写，请见“参考代码 2”。</p><ul><li>对“索引堆”感兴趣的朋友，可以参考我的学习笔记<a href="https://www.liwei.party/2019/01/12/algorithms-and-data-structures/index-heap/" target="_blank" rel="noopener">《【算法日积月累】11-索引堆》</a>，注意文中提到的“索引数组”和“反向查找”技巧是值得借鉴的，文后还给出了示例代码和参考资料。</li></ul><p><strong>参考代码 2</strong>：“最大索引堆”得自己写，正好就利用了 LeetCode 的测试用例检验一下自己有没有写对。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:        size = len(nums)        # 特判        if size == 0:            return []        # 初始化最大索引堆，其容量是滑动窗口的大小        index_max_heap = Solution.IndexMaxHeap(k)        # 首先先把前 k 个元素加进去        for i in range(k):            index_max_heap.insert(i, nums[i])        # 结果集        res = []        # 然后就是产生滑动窗口的过程，先输出最大值，        # 而后把当前考虑的数插入到将要滑出的左边界的索引位置        for i in range(k, size):            res.append(index_max_heap.peek_max_value())            index_max_heap.change(i % k, nums[i])        # 因为最大索引堆更新了最后 1 个数，因此最后还要看一眼最大值        res.append(index_max_heap.peek_max_value())        return res    class IndexMaxHeap:        def __init__(self, capacity):            self.data = [None for _ in range(capacity + 1)]            # 初值设置为 0 ，表示该位置还没有放置元素            self.indexes = [0 for _ in range(capacity + 1)]            self.reverse = [0 for _ in range(capacity + 1)]            self.count = 0            self.capacity = capacity        def size(self):            return self.count        def is_empty(self):            return self.count == 0        # 此时 insert 要给一个索引位置        def insert(self, i, item):            if self.count + 1 > self.capacity:                raise Exception('堆的容量不够了')            i += 1            self.data[i] = item            # 这一步很关键，在内部索引数组的最后设置索引数组的索引            self.indexes[self.count + 1] = i            self.reverse[i] = self.count + 1            self.count += 1            self.__shift_up(self.count)        def __shift_up(self, k):            while k > 1 and self.data[self.indexes[k // 2]] < self.data[self.indexes[k]]:                self.indexes[k // 2], self.indexes[k] = self.indexes[k], self.indexes[k // 2]                self.reverse[self.indexes[k // 2]] = k // 2                self.reverse[self.indexes[k]] = k                k //= 2        def extract_max(self):            if self.count == 0:                raise Exception('堆里没有可以取出的元素')            ret = self.data[self.indexes[1]]            self.indexes[1], self.indexes[self.count] = self.indexes[self.count], self.indexes[1]            self.reverse[self.indexes[1]] = 1            self.reverse[self.indexes[self.count]] = self.count            self.reverse[self.indexes[self.count]] = 0            self.count -= 1            self.__shift_down(1)            return ret        def __shift_down(self, k):            while 2 * k <= self.count:                j = 2 * k                if j + 1 <= self.count and self.data[self.indexes[j + 1]] > self.data[self.indexes[j]]:                    j = j + 1                if self.data[self.indexes[k]] >= self.data[self.indexes[j]]:                    break                self.indexes[k], self.indexes[j] = self.indexes[j], self.indexes[k]                self.reverse[self.indexes[k]] = k                self.reverse[self.indexes[j]] = j                k = j        # 新增方法        def extract_max_index(self):            assert self.count > 0            # 减 1 是为了符合用户视角            ret = self.indexes[1] - 1            self.indexes[1], self.indexes[self.count] = self.indexes[self.count], self.indexes[1]            self.count -= 1            self.__shift_down(1)            return ret        # 新增方法        def get_item(self, i):            # 内部数组的索引比用户视角多 1            return self.data[i + 1]        # 新增方法        def change(self, i, new_item):            # 把用户视角改成内部索引            i += 1            self.data[i] = new_item            # 重点：下面这一步是找原来数组中索引是 i 的元素            # 在索引数组中的索引是几，这是一个唯一值，找到即返回            # 优化：可以引入反向查找技术优化            j = self.reverse[i]            self.__shift_down(j)            self.__shift_up(j)        # 为 LeetCode 第 239 题新增的方法，看一眼此时索引堆的最大索引是多少（没用上，我想多了，留到以后用吧）        def peek_max_index(self):            if self.count == 0:                raise Exception('堆里没有可以取出的元素')            # 注意：与用户认为的索引值有一个偏差            return self.indexes[1] - 1        # 为 LeetCode 第 239 题新增的方法，看一眼此时索引堆的最大值是多少        def peek_max_value(self):            if self.count == 0:                raise Exception('堆里没有可以取出的元素')            return self.data[self.indexes[1]]if __name__ == '__main__':    solution = Solution()    nums = [1, 3, -1, -3, 5, 3, 6, 7]    k = 3    res = solution.maxSlidingWindow(nums, k)    print(res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Arrays;/** * @author liwei * @date 2019/7/10 9:27 AM */public class Solution2 {    public int[] maxSlidingWindow(int[] nums, int k) {        int len = nums.length;        if (len == 0) {            return new int[]{};        }        // 初始化最大索引堆，其容量是滑动窗口的大小        IndexMaxHeap indexMaxHeap = new IndexMaxHeap(k);        // 首先先把前 k 个元素加进去        for (int i = 0; i < k; i++) {            indexMaxHeap.insert(i, nums[i]);        }        // 结果集        int[] res = new int[len - k + 1];        // 然后就是产生滑动窗口的过程，先输出最大值，        // 而后把当前考虑的数插入到将要滑出的左边界的索引位置        for (int i = k; i < len; i++) {            res[i - k] = indexMaxHeap.peekMaxValue();            indexMaxHeap.change(i % k, nums[i]);        }        // 因为最大索引堆更新了最后 1 个数，因此最后还要看一眼最大值        res[len - k] = indexMaxHeap.peekMaxValue();        return res;    }    class IndexMaxHeap {        private int[] data;        private int count;        private int capacity;        private int[] indexes;        private int[] reverse;        // 使用了反向查找技术的最大索引堆        public IndexMaxHeap(int capacity) {            data = new int[capacity + 1];            indexes = new int[capacity + 1];            reverse = new int[capacity + 1];            count = 0;            this.capacity = capacity;        }        public int getSize() {            return count;        }        public boolean isEmpty() {            return count == 0;        }        public void insert(int i, int item) {            assert count + 1 <= capacity;            assert i + 1 >= 1 && i + 1 <= capacity;            i += 1;            data[i] = item;            indexes[count + 1] = i;            reverse[i] = indexes[count + 1];            count++;            shiftUp(count);        }        private void shiftUp(int k) {            while (k > 1 && data[indexes[k / 2]] < data[indexes[k]]) {                swap(indexes, k / 2, k);                // 注意分析这行代码，即使上一行 indexes 的两个元素交换了位置，但是并没有改变他们的值                // 每一次交换了 indexes 索引以后，还要把 reverse 索引也交换                swap(reverse, indexes[k / 2], indexes[k]);                k /= 2;            }        }        private void shiftUp1(int k) {            while (k > 1 && data[indexes[k / 2]] < data[indexes[k]]) {                swapIndexes(k / 2, k);                k /= 2;            }        }        private void swapIndexes(int index1, int index2) {            if (index1 == index2) {                return;            }            int temp = indexes[index1];            indexes[index1] = indexes[index2];            indexes[index2] = temp;            reverse[indexes[index1]] = index2;            reverse[indexes[index2]] = index1;        }        private void swap(int[] data, int index1, int index2) {            if (index1 == index2) {                return;            }            int temp = data[index1];            data[index1] = data[index2];            data[index2] = temp;        }        /**         * @return         */        public int extractMax() {            // 将此时二叉堆中的最大的那个数据删除（出队），返回的是数据，不是返回索引            assert count > 0;            int ret = data[indexes[1]];            // 只要设计交换的操作，就一定是索引数组交换            // 每一次交换了 indexes 索引以后，还要把 reverse 索引也交换            swap(indexes, 1, count);            swap(reverse, indexes[1], indexes[count]);            count--;            shiftDown(1);            return ret;        }        /**         * @return         */        public int extractMax1() {            // 将此时二叉堆中的最大的那个数据删除（出队），返回的是数据，不是返回索引            assert count > 0;            int ret = data[indexes[1]];            // 只要设计交换的操作，就一定是索引数组交换            // 每一次交换了 indexes 索引以后，还要把 reverse 索引也交换            swapIndexes(1, count);            count--;            shiftDown(1);            return ret;        }        private void shiftDown(int k) {            while (2 * k <= count) {                int j = 2 * k;                if (j + 1 <= count && data[indexes[j + 1]] > data[indexes[j]]) {                    j = j + 1;                }                if (data[indexes[k]] >= data[indexes[j]]) {                    break;                }                // 每一次交换了 indexes 索引以后，还要把 reverse 索引也交换                swap(indexes, k, j);                swap(reverse, indexes[k], indexes[j]);                k = j;            }        }        private void shiftDown1(int k) {            while (2 * k <= count) {                int j = 2 * k;                if (j + 1 <= count && data[indexes[j + 1]] > data[indexes[j]]) {                    j = j + 1;                }                if (data[indexes[k]] >= data[indexes[j]]) {                    break;                }                // 每一次交换了 indexes 索引以后，还要把 reverse 索引也交换                swapIndexes(k, j);                k = j;            }        }        public int extractMaxIndex() {            assert count > 0;            int ret = indexes[1] - 1;            // 每一次交换了 indexes 索引以后，还要把 reverse 索引也交换            swap(indexes, 1, count);            swap(reverse, indexes[1], indexes[count]);            count--;            shiftDown(1);            return ret;        }        public int extractMaxIndex1() {            assert count > 0;            int ret = indexes[1] - 1;            // 每一次交换了 indexes 索引以后，还要把 reverse 索引也交换            swapIndexes(1, count);            count--;            shiftDown(1);            return ret;        }        public int getItem(int i) {            return data[i + 1];        }        public void change(int i, int item) {            i = i + 1;            data[i] = item;            // 原先遍历的操作，现在就变成了这一步，是不是很酷            int j = reverse[i];            shiftDown(j);            shiftUp(j);        }        /**         * 为 LeetCode 第 239 题新增的方法，         * 看一眼此时索引堆的最大索引是多少（没用上，我想多了，留到以后用吧）         *         * @return         */        public int peekMaxIndex() {            if (this.count == 0) {                throw new RuntimeException("堆里没有可以取出的元素");            }            // 注意：与用户认为的索引值有一个偏差            return indexes[1] - 1;        }        /**         * 为 LeetCode 第 239 题新增的方法，         * 看一眼此时索引堆的最大索引是多少（没用上，我想多了，留到以后用吧）         *         * @return         */        public int peekMaxValue() {            if (this.count == 0) {                throw new RuntimeException("堆里没有可以取出的元素");            }            return data[indexes[1]];        }    }    public static void main(String[] args) {        Solution2 solution2 = new Solution2();        int[] nums = {1, 3, -1, -3, 5, 3, 6, 7};        int k = 3;        int[] res = solution2.maxSlidingWindow(nums, k);        System.out.println(Arrays.toString(res));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><Vssue title="sliding-window-maximum"/>]]></content>
      
      
      <categories>
          
          <category> 专题 4：滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 220 题：存在重复元素 III</title>
      <link href="/leetcode-algo/2017/06/22/leetcode-algo/0209-minimum-size-subarray-sum/"/>
      <url>/leetcode-algo/2017/06/22/leetcode-algo/0209-minimum-size-subarray-sum/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-220-题：存在重复元素-III"><a href="#「力扣」第-220-题：存在重复元素-III" class="headerlink" title="「力扣」第 220 题：存在重复元素 III"></a>「力扣」第 220 题：存在重复元素 III</h2><p>题解地址：<a href="">滑动窗口 + 二叉搜索树找上下边界（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. 存在重复元素 III</a>。</p><blockquote><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</p><p>示例 1:</p><p>输入: nums = [1,2,3,1], k = 3, t = 0<br>输出: true<br>示例 2:</p><p>输入: nums = [1,0,1,1], k = 1, t = 2<br>输出: true<br>示例 3:</p><p>输入: nums = [1,5,9,1,5,9], k = 2, t = 3<br>输出: false</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/contains-duplicate-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="滑动窗口-二叉搜索树找上下边界（Python-代码、Java-代码）"><a href="#滑动窗口-二叉搜索树找上下边界（Python-代码、Java-代码）" class="headerlink" title="滑动窗口 + 二叉搜索树找上下边界（Python 代码、Java 代码）"></a>滑动窗口 + 二叉搜索树找上下边界（Python 代码、Java 代码）</h2><p><strong>思路分析</strong>：</p><p>1、存在性问题，找到符合题意的数据对即可，所有可能的情况看完以后才返回 <code>false</code>；</p><p>2、题目给出了两个限制条件，分别是针对数（<code>nums [i]</code> 和 <code>nums [j]</code> 的差的绝对值最大为 <code>t</code>）和对应的索引（<code>i</code> 和 <code>j</code> 之间的差的绝对值最大为 <code>ķ</code>）的。</p><blockquote><p><strong>由于索引方便定位，因此我们将索引的差值固定，于是问题转化为固定长度（长度为 $k+1$）的窗口内，是否存在两个值的差距不超过 <code>t</code>，即问题转化为一个“滑动窗口”问题</strong>。</p></blockquote><p>由于转化成了“滑动窗口”问题，因此，两个限制条件只剩下一个，即：<code>nums [i]</code> 和 <code>nums [j]</code> 的差的绝对值最大为 <code>t</code>。下面这一点是针对这个限制条件的分析。</p><p>3、“数组”和“滑动窗口”问题，我们通常都得遍历，在遍历的过程中，我们试图在“已经出现、但还未滑出滑动窗口”的所有数中查找是否有一个数与当前出现的这个数的差的绝对值最大为 <code>t</code>，这件事情我们换一个说法：</p><blockquote><p>我们在数轴上标出 <code>nums[i]</code> 的位置，然后以 <code>t</code> 为半径画圆，这个圆与 <code>nums[i]</code> 的左边相交于 <code>nums[i] - t</code>，与 <code>nums[i]</code> 的y右边相交于 <code>nums[i] + t</code>，如果我们在遍历中发现，“滑动窗口”内有元素落在 <code>[nums[i] - t, nums[i] + t]</code> 这个区间内，那么根据第 1 点，直接返回 <code>true</code> 即可。</p></blockquote><p><img src="https://pic.leetcode-cn.com/e7b5ec71ff3a7addc6ad099eb6037dbe28b758fbeba0f7aeebd568ebb24ef774-image.png" alt="image.png"></p><p>再想想，在“滑动窗口”滑动的过程中，我们需要做什么？</p><blockquote><p>在“滑动窗口”中查找落在 <code>[nums[i] - t, nums[i] + t]</code> 这个区间内的元素，存在一个即可。</p></blockquote><p>对于查找问题，我们有什么？顺序查找、二分查找，二叉搜索树，哈希表。</p><ul><li>“顺序查找”可行，“滑动窗口”每滑动一次，就得遍历一遍这个窗口内的元素，效率太低；</li><li>“二分查找”不满足前提条件“数组有序”，故不适用；</li><li>“哈希表”时间复杂度最低，“滑动窗口”每滑动一次，能高效处理添加和删除元素，但我们要找范围，要比较大小，而“哈希表”中的元素丢失了顺序性。</li></ul><p>只能下“二叉搜索树”了，看看它能不能胜任：</p><p>1、“二叉搜索树”能够“动态地”存储和删除数据，符合“滑动窗口”元素是动态变化，虽然它没有哈希表那么高效；</p><p>2、“二叉搜索树”的顺序性就正好符合我们要查找落在 <code>[nums[i] - t, nums[i] + t]</code> 这个区间内的元素这个任务。</p><p>这时要用到的两个与我们的任务相关的 API 有：</p><ul><li><code>ceiling(key)</code> 函数：返回大于等于 <code>key</code> 的最小元素，如果不存在，返回空。下面的是这个函数的文档（通过 Intellij IDEA 查看）。</li></ul><pre class="line-numbers language-Java"><code class="language-Java">/**  * Returns the least key greater than or equal to the given key,  * or {@code null} if there is no such key.  *  * @param key the key  * @return the least key greater than or equal to {@code key},  *         or {@code null} if there is no such key  * @throws ClassCastException if the specified key cannot be compared  *         with the keys currently in the map  * @throws NullPointerException if the specified key is null  *         and this map does not permit null keys  */K ceilingKey(K key);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>floor(key)</code> 函数：返回小于等于 <code>key</code> 的最大元素，如果不存在，返回空。下面的是这个函数的文档（通过 Intellij IDEA 查看）。</li></ul><pre class="line-numbers language-Java"><code class="language-Java">/**  * Returns the greatest key less than or equal to the given key,  * or {@code null} if there is no such key.  *  * @param key the key  * @return the greatest key less than or equal to {@code key},  *         or {@code null} if there is no such key  * @throws ClassCastException if the specified key cannot be compared  *         with the keys currently in the map  * @throws NullPointerException if the specified key is null  *         and this map does not permit null keys  */K floorKey(K key);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是，我们可以</p><p>1、在 <code>nums[i]</code> 的左边找一下 <code>ceiling(nums[i] - t)</code>，即大于等于 <code>nums[i] - t</code> 的元素是否存在；</p><p>2、在 <code>nums[i]</code> 的右边找一下 <code>floor(nums[i] + t)</code>，即小于等于 <code>nums[i] + t</code> 的元素是否存在。</p><p><strong>参考代码</strong>：</p><p>说明：<br>1、在 Java 中，“二叉搜索树”是用红黑树实现的，并且也提供了 <code>ceiling</code> 和 <code>floor</code> 实现，这道题用 Java 语言实现比较方便；</p><p>2、由于 Python 中没有“二叉搜索树”实现，以下 Python 示例代码使用了我自己编写的 <code>BST</code> 实现，由于水平有限，没有实现自平衡，故性能较差，供各位参考。</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.TreeSet;public class Solution {    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {        int len = nums.length;        // 特判        if (len == 0 || k <= 0 || t < 0) {            return false;        }        // 泛型类型为 Long 是提交失败以后看到测试用例以后改的        TreeSet<Long> set = new TreeSet<>();        // 一个一个加进去        for (int i = 0; i < len; i++) {            // 检测逻辑 1：以当前数为中心，向左边扩展，看看 set 里有没有大于等于 nums[i] - t 的元素            // 大于等于 nums[i] - t ，在这个数上面，故使用天花板函数 ceiling            Long ceiling = set.ceiling((long) nums[i] - t);            // 在 nums[i] 为中心，半径为 t 的左边有元素，因此直接返回 true 即可            if (ceiling != null && ceiling <= nums[i]) {                return true;            }            // 检测逻辑 2：以当前数为中心，向左边扩展，看看 set 里有没有小于等于 nums[i] + t 的元素            // 小于等于 nums[i] + t ，在这个数下面，故使用地板函数 floor            Long floor = set.floor((long) nums[i] + t);            // 在 nums[i] 为中心，半径为 t 的右边有元素，因此直接返回 true 即可            if (floor != null && floor >= nums[i]) {                return true;            }            set.add((long) nums[i]);            // 当 k = 3 时，[0,1,2,3,4]，i = 3 的时候就要把 i = 0 删掉了            if (i >= k) {                set.remove((long) nums[i - k]);            }        }        // 遍历以后都找不到符合题意的数据对，就只能返回 False        return false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:        size = len(nums)        # 特判        if size == 0 or k <= 0 or t < 0:            return False        # 初始化自定义的 bst        bst = Solution.BST()        # 一个一个加进去        for i in range(size):            # 检测逻辑 1：以当前数为中心，向左边扩展，看看 set 里有没有大于等于 nums[i] - t 的元素            # 大于等于 nums[i] - t ，在这个数上面，故使用天花板函数 ceiling            ceiling = bst.ceiling(nums[i] - t)            # 在 nums[i] 为中心，半径为 t 的左边有元素，因此直接返回 true 即可            if ceiling is not None and ceiling <= nums[i]:                return True            # 检测逻辑 2：以当前数为中心，向左边扩展，看看 set 里有没有小于等于 nums[i] + t 的元素            # 小于等于 nums[i] + t ，在这个数下面，故使用地板函数 floor            floor = bst.floor(nums[i] + t)            if floor is not None and nums[i] <= floor:                return True            bst.insert(nums[i])            # 当 k = 3 时，[0,1,2,3,4]，i = 3 的时候就要把 i = 0 删掉了            if i >= k:                bst.remove(nums[i - k])        return False    # 以下是自定义的 BST 实现，未实现自平衡，性能较差    class TreeNode:        def __init__(self, x):            self.val = x            self.left = None            self.right = None    class BST:        def __init__(self):            self.root = None        def __str__(self):            # 中序遍历 bst            s = ''            if self.root is None:                return ''            stack = [(1, self.root)]            while stack:                type, node = stack.pop()                if type == 0:                    s += str(node.val) + ','                else:                    if node.right:                        stack.append((1, node.right))                    stack.append((0, node))                    if node.left:                        stack.append((1, node.left))            return s[:-1]        def insert(self, val):            """            将 val 插入 bst            :param val:            :return:            """            self.root = self.__insert(self.root, val)        def __insert(self, node, val):            # 在以 node 为根结点的 bst 中，插入 val            if node is None:                return Solution.TreeNode(val)            if val < node.val:                # 注意：不要写成 return self.__insert(node.left, val)                node.left = self.__insert(node.left, val)                return node            elif val > node.val:                # 注意：不要写成 return self.__insert(node.right, val)                node.right = self.__insert(node.right, val)                return node            node.val = val            # 注意：要把 node 返回回去            return node        def remove(self, val):            """            删除 bst 中等于 val 的结点            :param val:            :return:            """            if self.root:                self.root = self.__remove(self.root, val)        def __remove(self, node, val):            if node is None:                return None            if val < node.val:                node.left = self.__remove(node.left, val)                return node            if val > node.val:                node.right = self.__remove(node.right, val)                return node            if node.left is None:                new_root = node.right                node.right = None                return new_root            if node.right is None:                new_root = node.left                node.left = None                return new_root            # 用前驱结点 precursor 代替被删除结点            precursor = self.__maximum(node.left)            precursor_copy = Solution.TreeNode(precursor.val)            precursor_copy.left = self.__remove_max(node.left)            precursor_copy.right = node.right            node.left = None            node.right = None            return precursor_copy        def __maximum(self, node):            while node.right:                node = node.right            return node        def __remove_max(self, node):            if node.right is None:                new_root = node.left                node.left = None                return new_root            node.right = self.__remove_max(node.right)            return node        def floor(self, val):            return self.__floor(self.root, val)        def __floor(self, node, val):            if node is None:                return None            if node.val == val:                return node.val            if val < node.val:                return self.__floor(node.left, val)            temp_val = self.__floor(node.right, val)            if temp_val:                return temp_val            return node.val        def ceiling(self, val):            return self.__ceiling(self.root, val)        def __ceiling(self, node, val):            if node is None:                return None            if node.val == val:                return node.val            if val > node.val:                return self.__ceiling(node.right, val)            temp_val = self.__ceiling(node.left, val)            if temp_val:                return temp_val            return node.val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><Vssue title="contains-duplicate-iii"/>]]></content>
      
      
      <categories>
          
          <category> 专题 4：滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 209 题：长度最小的子数组</title>
      <link href="/leetcode-algo/2017/06/21/leetcode-algo/0209-minimum-size-subarray-sum/"/>
      <url>/leetcode-algo/2017/06/21/leetcode-algo/0209-minimum-size-subarray-sum/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-209-题：长度最小的子数组"><a href="#「力扣」第-209-题：长度最小的子数组" class="headerlink" title="「力扣」第 209 题：长度最小的子数组"></a>「力扣」第 209 题：长度最小的子数组</h2><ul><li><p>中文网址：<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/description/" target="_blank" rel="noopener">209. 长度最小的子数组</a> ；</p></li><li><p>英文网址：<a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/" target="_blank" rel="noopener">209. Minimum Size Subarray Sum</a> 。</p></li></ul><blockquote><p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s ，</strong>找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的连续子数组<strong>。</strong>如果不存在符合条件的连续子数组，返回 0。</p><p><strong>示例:</strong> </p><pre><code>输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</code></pre><p><strong>进阶:</strong></p><p>如果你已经完成了<em>O</em>(<em>n</em>) 时间复杂度的解法, 请尝试 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度的解法。</p></blockquote><p>思路1：使用滑动窗口的技巧来完成，要看过一遍整个数组的元素，时间复杂度是 $O(n)$。要求满足区间和 &gt;= s 的最小子区间的长度，因此，我们从左向右进行扫描。</p><p>情况1：当区间和小于 s 的时候，右区间的端点向右扩展，这一点依赖外层循环的遍历就可以完成；</p><p>情况2：一旦区间和大于等于 s，尝试一步一步缩小左区间端点，看看是否能得到一个更短的区间，满足区间和 &gt;=s，这一步通过一个内层循环实现。</p><p>Python 代码1：在理解的基础上，记住下面这个写法，右指针也是用于遍历的指针</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: int        :type nums: List[int]        :rtype: int        """</span>        <span class="token comment" spellcheck="true"># 滑动窗口</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 特判</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        l <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 既然是求最小的长度，初始值应该设置成一个不可能达到的上限</span>        res <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">1</span>        cur_sum <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            cur_sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># 此时 cur_sum >= s</span>            <span class="token keyword">while</span> cur_sum <span class="token operator">>=</span> s<span class="token punctuation">:</span>                res <span class="token operator">=</span> min<span class="token punctuation">(</span>res<span class="token punctuation">,</span> i <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                cur_sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 如果全部数组元素加起来都 &lt; s ，即 res 的值没有被更新，根据题意返回 0</span>        <span class="token keyword">if</span> res <span class="token operator">==</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码2：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: int        :type nums: List[int]        :rtype: int        """</span>        <span class="token comment" spellcheck="true"># 滑动窗口</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 特判</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        sum <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>            <span class="token keyword">if</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">and</span> sum <span class="token operator">&lt;</span> s<span class="token punctuation">:</span>                r <span class="token operator">+=</span> <span class="token number">1</span>                sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> sum <span class="token operator">>=</span> s<span class="token punctuation">:</span>                res <span class="token operator">=</span> min<span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> res <span class="token operator">==</span> size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：使用滑动窗口</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minSubArrayLen <span class="token operator">=</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> segmentSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            segmentSum <span class="token operator">+=</span> num<span class="token punctuation">;</span>            r<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 注意：根据题意"找出该数组中满足其和 ≥ s 的长度最小的子数组"</span>            <span class="token comment" spellcheck="true">// 注意这个边界条件</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>segmentSum <span class="token operator">>=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                minSubArrayLen <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minSubArrayLen<span class="token punctuation">,</span> r <span class="token operator">-</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>                segmentSum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minSubArrayLen <span class="token operator">==</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> minSubArrayLen<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：二分法，利用“数组是正整数”这个条件，构造前缀和数组，这个前缀和数组一定是严格增加的。 任意区间和可以通过前缀和数组得到，这是我们常见的一种做法。 起点固定的时候，区间越长，区间和越大。</p><p>Java 代码：构造前缀和数组，使用二分查找法，要考虑一些边界条件，编码易出错，了解即可</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 构造前缀和数组</span>        <span class="token comment" spellcheck="true">// 因为 nums 全都是正整数，因此 preSum 严格单调增加</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preSum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        preSum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 因为前缀和数组严格单调增加，因此我们可以使用二分查找算法</span>        <span class="token comment" spellcheck="true">// 最后一位没有下一位了，所以外层遍历到最后一位的前一位就可以了</span>        <span class="token keyword">int</span> ret <span class="token operator">=</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 计算区间和</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">int</span> r <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置成一个比较大的数，但是这个数有下界</span>            <span class="token comment" spellcheck="true">// i 的最大值是 len - 2,</span>            <span class="token comment" spellcheck="true">// ans - i + 1 >= len + 1</span>            <span class="token comment" spellcheck="true">// ans >= i + len = 2 * len -2</span>            <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> len <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// int ans = 2 * len - 1; 能通过</span>            <span class="token comment" spellcheck="true">// int ans = 2 * len - 3; 不能通过</span>            <span class="token comment" spellcheck="true">// 退出循环的条件是 l > r</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 计算一下区间和，找一个位置，使得这个位置到索引 i 的区间和为 s</span>                <span class="token comment" spellcheck="true">// 13 14 15 17 19 20</span>                <span class="token keyword">int</span> segmentSum <span class="token operator">=</span> preSum<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> preSum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>segmentSum <span class="token operator">>=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ans <span class="token operator">=</span> mid<span class="token punctuation">;</span>                    r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            ret <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 4：滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 76 题：最小覆盖子串</title>
      <link href="/leetcode-algo/2017/06/20/leetcode-algo/0076-minimum-window-substring/"/>
      <url>/leetcode-algo/2017/06/20/leetcode-algo/0076-minimum-window-substring/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-76-题：最小覆盖子串"><a href="#「力扣」第-76-题：最小覆盖子串" class="headerlink" title="「力扣」第 76 题：最小覆盖子串"></a>「力扣」第 76 题：最小覆盖子串</h2><ul><li><p>中文网址：<a href="https://leetcode-cn.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">76. 最小覆盖子串</a> ；</p></li><li><p>英文网址：<a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">76. Minimum Window Substring</a> 。</p></li></ul><blockquote><p>给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。</p><p><strong>示例：</strong></p><pre><code>输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;输出: &quot;BANC&quot;</code></pre><p><strong>说明：</strong></p><ul><li>如果 S 中不存这样的子串，则返回空字符串 <code>&quot;&quot;</code>。</li><li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li></ul></blockquote><p>说明：这道题被 LeetCode 标记为「困难」。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashSet<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 参考资料：https://blog.csdn.net/feliciafay/article/details/44535301</span>    <span class="token comment" spellcheck="true">// 先复习第 438 题再做这题可能会好些</span>    <span class="token comment" spellcheck="true">// 滑动窗口，这个问题有一些难</span>    <span class="token keyword">public</span> String <span class="token function">minWindow</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cntS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cntT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>Character<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// cntT 赋值了以后，就成为了用于比对的对象，不更新</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> ct <span class="token operator">:</span> t<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cntT<span class="token punctuation">[</span>ct<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ct<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> minSub <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        String res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 滑动窗口左边界</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 滑动窗口右边界</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 逻辑：右边界进来的时候，数组 s 的次数都加 1</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> rc <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>rc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 不在字典里面，但是右边界同样要扩充，所以 right++</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cntS<span class="token punctuation">[</span>rc<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 理解这里是关键：加上以后，小于等于，count 才 ++，</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cntS<span class="token punctuation">[</span>rc<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> cntT<span class="token punctuation">[</span>rc<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// count++; 这件事情说明滑动窗口里面的有效字符，向目标字符又近了一步</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 下面这一段可以写得更精简一些，但是为了语义上的清晰，我就写得冗长一些</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 接下来，考虑左边界移出滑动窗口</span>                <span class="token comment" spellcheck="true">// 不在字典中，或者多了的时候，直接划掉就可以了</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">char</span> deleteChar <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>deleteChar<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        left<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cntS<span class="token punctuation">[</span>deleteChar<span class="token punctuation">]</span> <span class="token operator">></span> cntT<span class="token punctuation">[</span>deleteChar<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        cntS<span class="token punctuation">[</span>deleteChar<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                        left<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;</span> minSub<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    minSub <span class="token operator">=</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span>                    res <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minSub <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String S <span class="token operator">=</span> <span class="token string">"ADOBECODEBANC"</span><span class="token punctuation">;</span>        String T <span class="token operator">=</span> <span class="token string">"ABC"</span><span class="token punctuation">;</span>        String minWindow <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">minWindow</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考资料：<a href="https://blog.csdn.net/feliciafay/article/details/44535301" target="_blank" rel="noopener">https://blog.csdn.net/feliciafay/article/details/44535301</a></p><p><a href="https://blog.csdn.net/u013115610/article/details/70257445" target="_blank" rel="noopener">https://blog.csdn.net/u013115610/article/details/70257445</a></p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 4：滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「滑动窗口」专题：概述与经典问题</title>
      <link href="/leetcode-algo/2017/06/19/leetcode-algo/search-insert-position/"/>
      <url>/leetcode-algo/2017/06/19/leetcode-algo/search-insert-position/</url>
      
        <content type="html"><![CDATA[<h2 id="「滑动窗口」专题-：滑动窗口的基本思想"><a href="#「滑动窗口」专题-：滑动窗口的基本思想" class="headerlink" title="「滑动窗口」专题 ：滑动窗口的基本思想"></a>「滑动窗口」专题 ：滑动窗口的基本思想</h2><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 4：滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 461 题：汉明距离</title>
      <link href="/leetcode-algo/2017/06/17/leetcode-algo/0416-hamming-distance/"/>
      <url>/leetcode-algo/2017/06/17/leetcode-algo/0416-hamming-distance/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-461-题：汉明距离"><a href="#「力扣」第-461-题：汉明距离" class="headerlink" title="「力扣」第 461 题：汉明距离"></a>「力扣」第 461 题：汉明距离</h2><p>链接：<a href="https://leetcode-cn.com/problems/hamming-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hamming-distance</a></p><blockquote><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p><p>注意：<br>0 ≤ x, y &lt; 231.</p><p>示例：</p><pre><code>输入: x = 1, y = 4输出: 2解释：1   (0 0 0 1)4   (0 1 0 0)       ↑   ↑上面的箭头指出了对应二进制位不同的位置。</code></pre></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder xx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder yy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>xx<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> yy<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            StringBuilder temp <span class="token operator">=</span> xx<span class="token punctuation">;</span>            xx <span class="token operator">=</span> yy<span class="token punctuation">;</span>            yy <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> diff <span class="token operator">=</span> yy<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> xx<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> diff<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            xx<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> yy<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>xx<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> yy<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hammingDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder xx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder yy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> bothNegative <span class="token operator">=</span> x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bothNegative<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 始终让 xx 是长度比较小的那个字符串，这样补齐总是在 x 的前面补 0</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>xx<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> yy<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                StringBuilder temp <span class="token operator">=</span> xx<span class="token punctuation">;</span>                xx <span class="token operator">=</span> yy<span class="token punctuation">;</span>                yy <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> diff <span class="token operator">=</span> yy<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> xx<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> diff<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                xx<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> yy<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>xx<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> yy<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 448 题：找到所有数组中消失的数字</title>
      <link href="/leetcode-algo/2017/06/16/leetcode-algo/0448-find-all-numbers-disappeared-in-an-array/"/>
      <url>/leetcode-algo/2017/06/16/leetcode-algo/0448-find-all-numbers-disappeared-in-an-array/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-448-题：找到所有数组中消失的数字"><a href="#「力扣」第-448-题：找到所有数组中消失的数字" class="headerlink" title="「力扣」第 448 题：找到所有数组中消失的数字"></a>「力扣」第 448 题：找到所有数组中消失的数字</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/tong-pai-xu-ji-yu-yi-huo-yun-suan-jiao-huan-liang-/" target="_blank" rel="noopener">桶排序 + 基于“异或运算”交换两个变量的值（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a>。</p><blockquote><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p>示例:</p><p>输入:<br>[4,3,2,7,8,2,3,1]</p><p>输出:<br>[5,6]</p></blockquote><h2 id="桶排序-基于“异或运算”交换两个变量的值（Python-代码、Java-代码）"><a href="#桶排序-基于“异或运算”交换两个变量的值（Python-代码、Java-代码）" class="headerlink" title="桶排序 + 基于“异或运算”交换两个变量的值（Python 代码、Java 代码）"></a>桶排序 + 基于“异或运算”交换两个变量的值（Python 代码、Java 代码）</h2><p><strong>思路分析</strong>：</p><ul><li>比较容易想到的思路是“桶排序”，“桶排序”的思想很简单，“一个萝卜一个坑”，但这道题比较让人头疼的是“不使用额外空间”。</li></ul><p>“桶排序”的思想，有些地方也把它叫做“抽屉原理”，以下介绍来自“百度百科”之<a href="https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776?fr=aladdin" target="_blank" rel="noopener">“抽屉原理”</a>词条：</p><blockquote><p>抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有 n + 1 个元素放到 n 个集合中去，其中必定有一个集合里至少有两个元素。” 抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理。</p></blockquote><ul><li>“桶排序”的子步骤是“交换数组中两个位置的元素”，<strong>如果不使用额外的空间，可以使用“异或运算”代替</strong>。</li></ul><h3 id="方法一：桶排序-基于“异或运算”交换两个变量的值"><a href="#方法一：桶排序-基于“异或运算”交换两个变量的值" class="headerlink" title="方法一：桶排序 + 基于“异或运算”交换两个变量的值"></a>方法一：桶排序 + 基于“异或运算”交换两个变量的值</h3><p>交换两个整数，有两种比较 tricky 的做法。下面给出结论。</p><p>“基于异或运算”是因为利用了“异或运算”是不进位的二进制加法。它有如下性质：</p><blockquote><p>如果 <code>a ^ b = c</code> ，那么 <code>a ^ c = b</code> 与 <code>b ^ c = a</code> 同时成立，利用这一条，可以用于交换两个变量的值。</p></blockquote><p>于是，交换两个变量的值，例如 <code>a</code> 和 <code>b</code>，不使用第三个变量，有两种不同的方法：</p><table><thead><tr><th>基于异或运算</th><th>基于加减法</th></tr></thead><tbody><tr><td><code>a = a ^ b</code><br><code>b = a ^ b</code><br><code>a = a ^ b</code></td><td><code>a = a + b</code><br/><code>b = a - b</code><br/><code>a = a - b</code></td></tr></tbody></table><p>我理解的方式就是自己在纸上写几个例子，并且记住这个结论。个人觉得“基于异或运算”交换两个变量的值好记一些，因为右边都一样，左边依次是 <code>a</code>、<code>b</code>、<code>a</code>。</p><p><strong>参考代码 1</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:        size = len(nums)        for i in range(size):            while nums[i] != i + 1:                if nums[i] != nums[nums[i] - 1]:                    self.__swap(nums, i, nums[i] - 1)                else:                    break        res = []        for i in range(size):            if nums[i] != i + 1:                res.append(i + 1)        return res    def __swap(self, nums, index1, index2):        nums[index1] = nums[index1] ^ nums[index2]        nums[index2] = nums[index1] ^ nums[index2]        nums[index1] = nums[index1] ^ nums[index2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class Solution {    public List<Integer> findDisappearedNumbers(int[] nums) {        int len = nums.length;        for (int i = 0; i < len; i++) {            while (nums[i] != i + 1 && nums[nums[i] - 1] != nums[i]) {                swap(nums, i, nums[i] - 1);            }        }        // System.out.println("桶排序以后的数组：" + Arrays.toString(nums));        List<Integer> res = new ArrayList<>();        for (int i = 0; i < nums.length; i++) {            if (nums[i] != i + 1) {                res.add(i + 1);            }        }        return res;    }    private void swap(int[] nums, int i, int j) {        nums[i] = nums[i] ^ nums[j];        nums[j] = nums[i] ^ nums[j];        nums[i] = nums[i] ^ nums[j];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，这里 $N$ 是数组的长度。</li><li>空间复杂度：$O(1)$，这里没有使用额外的空间。</li></ul><p>说明：同样的思路和技巧，可以解决<a href="https://leetcode-cn.com/problems/first-missing-positive" target="_blank" rel="noopener">「力扣」第 41 题：缺失的第一个正数</a>。</p><h3 id="方法二：位图（使用了-1-个额外空间，不符合题意，该方法仅作了解）"><a href="#方法二：位图（使用了-1-个额外空间，不符合题意，该方法仅作了解）" class="headerlink" title="方法二：位图（使用了 1 个额外空间，不符合题意，该方法仅作了解）"></a>方法二：位图（使用了 1 个额外空间，不符合题意，该方法仅作了解）</h3><p><strong>参考代码 2</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:        size = len(nums)        # 位图        map = 1 << (size)        # 调试代码        # print(bin(map))        for num in nums:            map |= 1 << (num - 1)            # 调试代码            # print(bin(map))        res = []        for index in range(size):            if (map >> index) & 1 == 0:                res.append(index + 1)        return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.ArrayList;import java.util.List;public class Solution {    public List<Integer> findDisappearedNumbers(int[] nums) {        int len = nums.length;        int map = 1 << len;        // 调试代码        // System.out.println(Integer.toBinaryString(map));        for (int num : nums) {            map |= 1 << (num - 1);            // 调试代码            // System.out.println(Integer.toBinaryString(map));        }        List<Integer> res = new ArrayList<>();        for (int i = 0; i < len; i++) {            if (((map >> i) & 1) == 0) {                res.add(i + 1);            }        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，这里 $N$ 是数组的长度。</li><li>空间复杂度：$O(1)$，这里使用了 1 个额外的空间。</li></ul><Vssue title="find-all-numbers-disappeared-in-an-array"/>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 原地哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 26 题：删除排序数组中的重复项</title>
      <link href="/leetcode-algo/2017/06/15/leetcode-algo/0345-reverse-vowels-of-a-string/"/>
      <url>/leetcode-algo/2017/06/15/leetcode-algo/0345-reverse-vowels-of-a-string/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-345-题：反转字符串中的元音字母"><a href="#「力扣」第-345-题：反转字符串中的元音字母" class="headerlink" title="「力扣」第 345 题：反转字符串中的元音字母"></a>「力扣」第 345 题：反转字符串中的元音字母</h2><ul><li><p>中文网址：<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">345. 反转字符串中的元音字母</a> ；</p></li><li><p>英文网址：<a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">345. Reverse Vowels of a String</a> 。</p></li></ul><blockquote><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p>示例 1：</p><pre><code>输入: &quot;hello&quot;输出: &quot;holle&quot;</code></pre><p>示例 2：</p><pre><code>输入: &quot;leetcode&quot;输出: &quot;leotcede&quot;</code></pre><p>说明：<br>元音字母不包含字母”y”。</p></blockquote><p>分析：</p><ul><li>使用指针对撞，遇到元音字符的时候就听下来交换，交换以后指针继续向前；</li><li>这样的代码其实是套路，多写几遍就不会忘记了，我们在基础算法的学习中，曾经也有遇到过。</li></ul><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 写多了就知道，这是套路了     *     * @param s     * @return     */</span>    <span class="token keyword">public</span> String <span class="token function">reverseVowels</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> chars<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果走到最后一位都不符号要求的话，就不能再前进了。代码实现如下</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">checkVowels</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">checkVowels</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index1 <span class="token operator">==</span> index2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> temp <span class="token operator">=</span> chars<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        chars<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        chars<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">checkVowels</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'a'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'e'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'i'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'o'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'u'</span> <span class="token operator">||</span>                c <span class="token operator">==</span> <span class="token string">'A'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'E'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'I'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'O'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">'U'</span>   <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//String result1 = solution.reverseVowels("hello");</span>        <span class="token comment" spellcheck="true">//System.out.println(result1);</span>        <span class="token comment" spellcheck="true">//String result2 = solution.reverseVowels("leetcode");</span>        <span class="token comment" spellcheck="true">//System.out.println(result2);</span>        String result3 <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">reverseVowels</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseVowels</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: str        """</span>        vowels <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token string">'O'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> vowels<span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> vowels<span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="要注意的地方"><a href="#要注意的地方" class="headerlink" title="要注意的地方"></a>要注意的地方</h3><ul><li>极端的情况要考虑到：<code>if (s.length() == 0) return &quot;&quot;;</code>；</li><li>还有一种极端的情况要考虑到，就是 i 和 j 可以一直走到底的情况，翻译成大白话就是：如果走到最后一位都不符号要求的话，就不能再前进了。代码实现如下：</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">checkVowels</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">checkVowels</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码特别容易忽略掉：<code>i &lt; chars.length</code> 和 <code>j &gt;= 0</code> 这两个前提条件。</p><p>（本节完）</p><h3 id="Leetcode-第-345-题：反转字符串中的元音字母"><a href="#Leetcode-第-345-题：反转字符串中的元音字母" class="headerlink" title="Leetcode 第 345 题：反转字符串中的元音字母"></a>Leetcode 第 345 题：<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string" target="_blank" rel="noopener">反转字符串中的元音字母</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">345. Reverse Vowels of a String</a> ，中文网址：<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">345. 反转字符串中的元音字母</a> 。</p><blockquote><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;hello&quot;输出: &quot;holle&quot;</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;leetcode&quot;输出: &quot;leotcede&quot;</code></pre><p><strong>说明:</strong><br>元音字母不包含字母”y”。</p></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseVowels</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: str        """</span>        vowels <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token string">'O'</span><span class="token punctuation">,</span> <span class="token string">'U'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> vowels<span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">not</span> <span class="token keyword">in</span> vowels<span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                left <span class="token operator">+=</span> <span class="token number">1</span>                right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 26 题：删除排序数组中的重复项</title>
      <link href="/leetcode-algo/2017/06/14/leetcode-algo/0344-reverse-string/"/>
      <url>/leetcode-algo/2017/06/14/leetcode-algo/0344-reverse-string/</url>
      
        <content type="html"><![CDATA[<h3 id="「力扣」第-344-题：反转字符串"><a href="#「力扣」第-344-题：反转字符串" class="headerlink" title="「力扣」第 344 题：反转字符串"></a>「力扣」第 344 题：反转字符串</h3><ul><li>中文网址：<a href="https://leetcode-cn.com/problems/reverse-string/description/" target="_blank" rel="noopener">344. 反转字符串</a> ；</li><li>英文网址：<a href="https://leetcode.com/problems/reverse-string/description/" target="_blank" rel="noopener">344. Reverse String</a> 。</li></ul><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII" target="_blank" rel="noopener">ASCII</a> 码表中的可打印字符。</p><p><strong>示例 1：</strong></p><pre><code>输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre></blockquote><h3 id="方法一：使用-Java-语言提供的反转-API-完成"><a href="#方法一：使用-Java-语言提供的反转-API-完成" class="headerlink" title="方法一：使用 Java 语言提供的反转 API 完成"></a>方法一：使用 Java 语言提供的反转 API 完成</h3><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">reverseString</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder reverse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            reverse<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> reverse<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Given s = "hello", return "olleh".</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String reverseString <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">reverseString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reverseString<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：使用指针对撞"><a href="#方法二：使用指针对撞" class="headerlink" title="方法二：使用指针对撞"></a>方法二：使用指针对撞</h3><p>Java 代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">reverseString</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cArray <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> cArray<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>cArray<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>cArray<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index1 <span class="token operator">==</span> index2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> temp <span class="token operator">=</span> s<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        s<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        s<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String result <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">reverseString</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: str        """</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> s        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        l <span class="token operator">=</span> list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 重合在一个就没有交换的必要了，因此是 left &lt; right</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            l<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            left <span class="token operator">+=</span> <span class="token number">1</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p><h3 id="Leetcode-第-344-题：反转字符串"><a href="#Leetcode-第-344-题：反转字符串" class="headerlink" title="Leetcode 第 344 题：反转字符串"></a>Leetcode 第 344 题：<a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">反转字符串</a></h3><p>传送门：英文网址：<a href="https://leetcode.com/problems/reverse-string/description/" target="_blank" rel="noopener">344. Reverse String</a> ，中文网址：<a href="https://leetcode-cn.com/problems/reverse-string/description/" target="_blank" rel="noopener">344. 反转字符串</a> 。</p><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII" target="_blank" rel="noopener">ASCII</a> 码表中的可打印字符。</p><p><strong>示例 1：</strong></p><pre><code>输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: str        """</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> s        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        l <span class="token operator">=</span> list<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 重合在一个就没有交换的必要了，因此是 left &lt; right</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            l<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> l<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            left <span class="token operator">+=</span> <span class="token number">1</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 215 题：数组第 k 大的元素</title>
      <link href="/leetcode-algo/2017/06/13/leetcode-algo/0215-kth-largest-element-in-an-array/"/>
      <url>/leetcode-algo/2017/06/13/leetcode-algo/0215-kth-largest-element-in-an-array/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-215-题：数组第-k-大的元素"><a href="#「力扣」第-215-题：数组第-k-大的元素" class="headerlink" title="「力扣」第 215 题：数组第 k 大的元素"></a>「力扣」第 215 题：数组第 k 大的元素</h2><ul><li>中文网址：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a> ；</li><li>英文网址：<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">215. Kth Largest Element in an Array</a> 。</li></ul><blockquote><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p><strong>示例 1:</strong></p><pre><code>输入: [3,2,1,5,6,4] 和 k = 2输出: 5</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4</code></pre><p><strong>说明:</strong></p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p></blockquote><p>思路1：排序，然后返回倒数第 $k$ 个元素，索引是 $n - k$；  </p><p>思路2：partition ，逐渐减少搜索的范围，partition 的核心是大于等于的放过，小于的才做操作，<strong>因为要让小于的挪到前面去，还能保证元素的相对位置不变</strong>；  注意一些边边角角的细节，<code>+1</code> 和 <code>-1</code> 要特别小心。</p><p>Python 代码：partition 的过程一定要在理解的基础上，熟记</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 215. 数组中的第 K 个最大元素</span><span class="token comment" spellcheck="true"># 在未排序的数组中找到第 k 个最大的元素。</span><span class="token comment" spellcheck="true"># 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 数组中的第 K 个最大元素</span>    <span class="token comment" spellcheck="true"># 数组中第 k 大的元素，它的索引是 len(nums) - k</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'程序出错'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># [0,1,2,3,4,5]</span>        <span class="token comment" spellcheck="true"># 第 k 大元素的索引是 len(nums) - k</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            index <span class="token operator">=</span> self<span class="token punctuation">.</span>__partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span>            <span class="token keyword">if</span> index <span class="token operator">></span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">:</span>                right <span class="token operator">=</span> index <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        partition 是必须要会的子步骤，一定要非常熟练        在 [left, right] 这个区间执行 partition        遇到比第一个元素大的或等于的，就放过，遇到小的，就交换        :param nums:        :param left:        :param right:        :return:        """</span>        pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        k <span class="token operator">=</span> left        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>                k <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        <span class="token keyword">return</span> k<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>findKthLargest<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路3：使用堆。</p><p>Python 代码1：使用容量为 k 的小顶堆，元素个数小于 k 的时候，放进去就是了；元素个数大于 k 的时候，小于堆顶元素，就扔掉，大于堆顶元素，就替换。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> k <span class="token operator">></span> size<span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'程序出错'</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 堆有序数组</span>        h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>h<span class="token punctuation">,</span> num<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token operator">&lt;</span> h<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">pass</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>h<span class="token punctuation">,</span> num<span class="token punctuation">)</span>        <span class="token keyword">return</span> h<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码2：与 Python 代码1 等价的写法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token comment" spellcheck="true"># 还可以参考：https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/167837/Python-or-tm</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 默认是最小堆</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>L<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            top <span class="token operator">=</span> L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> top<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 看一看堆顶的元素，只要比堆顶元素大，就替换堆顶元素</span>                heapq<span class="token punctuation">.</span>heapreplace<span class="token punctuation">(</span>L<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 最后堆顶中的元素就是堆中最小的，整个数组中的第 k 大元素</span>        <span class="token keyword">return</span> L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码3：使用大顶堆，全部放进去以后，再往外 pop</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span>num<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span> l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<strong>Python 中的 heapq 可以传入 tuple，heapq 会根据 tuple 的 0 号索引元素进行堆的操作</strong>。</p><p>Python 代码4：与 Python 代码 3 等价的写法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span>num<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            _<span class="token punctuation">,</span> res <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p><hr><p>题解：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/" target="_blank" rel="noopener">通过 partition 减治 + 优先队列（Java、C++、Python）</a></p><p>传送门：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a>。</p><p>传送门：英文网址：<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">215. Kth Largest Element in an Array</a> ，中文网址：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a> 。</p><blockquote><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p><strong>示例 1:</strong></p><pre><code>输入: [3,2,1,5,6,4] 和 k = 2输出: 5</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4</code></pre><p><strong>说明:</strong></p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p></blockquote><p>这道题应该说是无比重要的高频考题，是一定要掌握的。</p><p>两种思路分别使用了很基础的数据结构（优先队列）和算法（partition）。</p><h3 id="方法一：使用快速排序-partition-的思路"><a href="#方法一：使用快速排序-partition-的思路" class="headerlink" title="方法一：使用快速排序 partition 的思路"></a>方法一：使用快速排序 partition 的思路</h3><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 数组中的第 K 个最大元素</span>    <span class="token comment" spellcheck="true"># 数组中第 k 大的元素，它的索引是 len(nums) - k</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            index <span class="token operator">=</span> self<span class="token punctuation">.</span>__partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span>            <span class="token keyword">if</span> index <span class="token operator">></span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">:</span>                right <span class="token operator">=</span> index <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        partition 是必须要会的子步骤，一定要非常熟练        典型的例子就是：[3,7,8,1,2,4]        遇到比第一个元素大的或等于的，就放过，遇到小的，就交换        在 [left,right] 这个区间执行 partition        :param nums:        :param left:        :param right:        :return:        """</span>        pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        k <span class="token operator">=</span> left        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>                k <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        <span class="token keyword">return</span> k<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>findKthLargest<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解法2：使用优先队列"><a href="#解法2：使用优先队列" class="headerlink" title="解法2：使用优先队列"></a>解法2：使用优先队列</h3><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 默认是最小堆</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>L<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            top <span class="token operator">=</span> L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> top<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 看一看堆顶的元素，只要比堆顶元素大，就替换堆顶元素</span>                heapq<span class="token punctuation">.</span>heapreplace<span class="token punctuation">(</span>L<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 最后堆顶中的元素就是堆中最小的，整个数组中的第 k 大元素</span>        <span class="token keyword">return</span> L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>findKthLargest<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>思路1：排序，然后返回倒数第 $k$ 个元素，索引是 $n - k$；  </p><p>思路2：partition ，逐渐减少搜索的范围，partition 的核心是大于等于的放过，小于的才做操作，<strong>因为要让小于的挪到前面去，还能保证元素的相对位置不变</strong>；  注意一些边边角角的细节，<code>+1</code> 和 <code>-1</code> 要特别小心。</p><p>Python 代码：partition 的过程一定要在理解的基础上，熟记</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 215. 数组中的第 K 个最大元素</span><span class="token comment" spellcheck="true"># 在未排序的数组中找到第 k 个最大的元素。</span><span class="token comment" spellcheck="true"># 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 数组中的第 K 个最大元素</span>    <span class="token comment" spellcheck="true"># 数组中第 k 大的元素，它的索引是 len(nums) - k</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'程序出错'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># [0,1,2,3,4,5]</span>        <span class="token comment" spellcheck="true"># 第 k 大元素的索引是 len(nums) - k</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            index <span class="token operator">=</span> self<span class="token punctuation">.</span>__partition<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>            <span class="token keyword">if</span> index <span class="token operator">==</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">:</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span>            <span class="token keyword">if</span> index <span class="token operator">></span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">:</span>                right <span class="token operator">=</span> index <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        partition 是必须要会的子步骤，一定要非常熟练        在 [left, right] 这个区间执行 partition        遇到比第一个元素大的或等于的，就放过，遇到小的，就交换        :param nums:        :param left:        :param right:        :return:        """</span>        pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        k <span class="token operator">=</span> left        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>                k <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>        nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        <span class="token keyword">return</span> k<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>findKthLargest<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路3：使用堆。</p><p>Python 代码1：使用容量为 k 的小顶堆，元素个数小于 k 的时候，放进去就是了；元素个数大于 k 的时候，小于堆顶元素，就扔掉，大于堆顶元素，就替换。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> k <span class="token operator">></span> size<span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'程序出错'</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 堆有序数组</span>        h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">:</span>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>h<span class="token punctuation">,</span> num<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> num <span class="token operator">&lt;</span> h<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">pass</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    heapq<span class="token punctuation">.</span>heappushpop<span class="token punctuation">(</span>h<span class="token punctuation">,</span> num<span class="token punctuation">)</span>        <span class="token keyword">return</span> h<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码2：与 Python 代码1 等价的写法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token comment" spellcheck="true"># 还可以参考：https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/167837/Python-or-tm</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 默认是最小堆</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>L<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            top <span class="token operator">=</span> L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> top<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 看一看堆顶的元素，只要比堆顶元素大，就替换堆顶元素</span>                heapq<span class="token punctuation">.</span>heapreplace<span class="token punctuation">(</span>L<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 最后堆顶中的元素就是堆中最小的，整个数组中的第 k 大元素</span>        <span class="token keyword">return</span> L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码3：使用大顶堆，全部放进去以后，再往外 pop</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span>num<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span> l<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<strong>Python 中的 heapq 可以传入 tuple，heapq 会根据 tuple 的 0 号索引元素进行堆的操作</strong>。</p><p>Python 代码4：与 Python 代码 3 等价的写法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> heapq<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type k: int        :rtype: int        """</span>        l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span>num<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">]</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>            _<span class="token punctuation">,</span> res <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 137 题：只出现一次的数字 II</title>
      <link href="/leetcode-algo/2017/06/12/leetcode-algo/0137-single-number-ii/"/>
      <url>/leetcode-algo/2017/06/12/leetcode-algo/0137-single-number-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-137-题：只出现一次的数字-II"><a href="#「力扣」第-137-题：只出现一次的数字-II" class="headerlink" title="「力扣」第 137 题：只出现一次的数字 II"></a>「力扣」第 137 题：只出现一次的数字 II</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/single-number-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number-ii</a></li></ul><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1：</p><pre><code>输入: [2,2,3,2]输出: 3</code></pre><p>示例 2：</p><pre><code>输入: [0,1,0,1,0,1,99]输出: 99</code></pre></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res <span class="token operator">|=</span> mask<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            mask <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 136 题： 只出现一次的数字</title>
      <link href="/leetcode-algo/2017/06/11/leetcode-algo/0136-single-number/"/>
      <url>/leetcode-algo/2017/06/11/leetcode-algo/0136-single-number/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-136-题：-只出现一次的数字"><a href="#「力扣」第-136-题：-只出现一次的数字" class="headerlink" title="「力扣」第 136 题： 只出现一次的数字"></a>「力扣」第 136 题： 只出现一次的数字</h2><ul><li>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number</a></li></ul><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1：</p><pre><code>输入: [2,2,1]输出: 1</code></pre><p>示例 2：</p><pre><code>输入: [4,1,2,1,2]输出: 4</code></pre></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">^=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> singleNumber <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">singleNumber</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>singleNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"数组元素为空，没有只出现一次的数字"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res <span class="token operator">^=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 125 题：验证回文串</title>
      <link href="/leetcode-algo/2017/06/10/leetcode-algo/0125-valid-palindrome/"/>
      <url>/leetcode-algo/2017/06/10/leetcode-algo/0125-valid-palindrome/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-125-题：验证回文串"><a href="#「力扣」第-125-题：验证回文串" class="headerlink" title="「力扣」第 125 题：验证回文串"></a>「力扣」第 125 题：验证回文串</h2><p>链接：<a href="https://leetcode-cn.com/problems/valid-palindrome" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome</a></p><blockquote><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。</p><p>示例 1：</p><pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;输出: true</code></pre><p>示例 2：</p><pre><code>输入: &quot;race a car&quot;输出: false</code></pre></blockquote><p>思路：使用指针对撞的思想：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * "A man, a plan, a canal: Panama"     *     * @param s     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index_j <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>index_i <span class="token operator">&lt;=</span> index_j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            String i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index_i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>            String j <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index_j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>i<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"[0-9a-zA-Z]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                index_i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>j<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">"[0-9a-zA-Z]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                index_j<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>j<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                index_i<span class="token operator">++</span><span class="token punctuation">;</span>                index_j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提交以后发现，才击败了 0.85% 的 Java 开发者。<br>下面改了一版，击败了 19.22% 的 Java 开发者。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * "A man, a plan, a canal: Panama"     *     * @param s     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 去掉非数字和字母</span>        <span class="token comment" spellcheck="true">// 全部转换为小写</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"[^0-9a-zA-Z]"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder reverse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            reverse<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>reverse<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s <span class="token operator">=</span> <span class="token string">"A man, a plan, a canal: Panama"</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> palindrome <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>palindrome<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 88 题：从后向前归并两个有序数组</title>
      <link href="/leetcode-algo/2017/06/09/leetcode-algo/0088-merge-sorted-array/"/>
      <url>/leetcode-algo/2017/06/09/leetcode-algo/0088-merge-sorted-array/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-88-题：从后向前归并两个有序数组"><a href="#「力扣」第-88-题：从后向前归并两个有序数组" class="headerlink" title="「力扣」第 88 题：从后向前归并两个有序数组"></a>「力扣」第 88 题：从后向前归并两个有序数组</h2><p>传送门：英文网址：<a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">88. Merge Sorted Array</a> ，中文网址：<a href="https://leetcode-cn.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">88. 合并两个有序数组</a> 。</p><blockquote><p>给定两个有序整数数组 <em>nums1</em> 和 <em>nums2*，将 *nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使得 <em>num1</em> 成为一个有序数组。</p><p><strong>说明:</strong></p><ul><li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li><li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m + n*）来保存 *nums2</em> 中的元素。</li></ul><p><strong>示例:</strong></p><pre><code>输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6],       n = 3输出: [1,2,2,3,5,6]</code></pre></blockquote><p>分析：其实就是归并排序，不过从后向前归并是这道题的考点。注意分 4 种情况，代码的写法其实是相对固定的。</p><p>思路1：可以使用标准的归并排序来做。</p><p>Python 代码：从前向后写</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> m<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums1: List[int]        :type m: int        :type nums2: List[int]        :type n: int        :rtype: void Do not return anything, modify nums1 in-place instead.        """</span>        nums3 <span class="token operator">=</span> nums1<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        i <span class="token operator">=</span> <span class="token number">0</span>        j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">==</span> m<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># i 用完了</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> j <span class="token operator">==</span> n<span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums3<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums3<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums3<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：考虑到这道题的特殊性，即 <code>nums1</code> 有足够的空间，因此，我们可以从后向前归并，每次从两个数组的末尾选出最大的元素放在 nums1 的末尾，而不使用额外的数组空间。</p><p>你可能会担心，nums1 之前有效的元素会不会被覆盖掉，但在这题中，这种情况是不可能出现的。在实现的时候，还是要特别注意一些边界条件。</p><p>Python 代码：从后向前写</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">,</span> m<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums1: List[int]        :type m: int        :type nums2: List[int]        :type n: int        :rtype: void Do not return anything, modify nums1 in-place instead.        """</span>        i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span>        j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                 nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                nums1<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">-=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<code>range(m + n - 1, -1, -1)</code> 表示索引的最大值是 <code>m + n - 1</code> ，最小值是 <code>0</code>。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 80 题 ：删除排序数组中的重复项 II</title>
      <link href="/leetcode-algo/2017/06/08/leetcode-algo/0080-remove-duplicates-from-sorted-array-ii/"/>
      <url>/leetcode-algo/2017/06/08/leetcode-algo/0080-remove-duplicates-from-sorted-array-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-80-题-：删除排序数组中的重复项-II"><a href="#「力扣」第-80-题-：删除排序数组中的重复项-II" class="headerlink" title="「力扣」第 80 题 ：删除排序数组中的重复项 II"></a>「力扣」第 80 题 ：删除排序数组中的重复项 II</h2><ul><li><p>中文网址：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="noopener">80. 删除排序数组中的重复项 II</a> ；</p></li><li><p>英文网址：<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="noopener">80. Remove Duplicates from Sorted Array II</a> 。</p></li></ul><blockquote><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><pre><code>给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2:</strong></p><pre><code>给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);}</code></pre></blockquote><p>思路1：删除重复的元素，要求重复的元素至多保留两个。利用排序数组这个条件。设置一个额外的 <code>current_num</code> 用于比较就可以了。同样要注意到 <code>nums = []</code> 的情况。</p><p>这道题调试了很久，最终还是独立解出来了，主要是忽略了一个细节，在重复次数为 $1$ 的时候，挪动指针位置的时候，同时也要赋值，刚开始做的时候我忘记赋值了。</p><p>Python 代码：第 1 次作答</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 重复元素至多保留 2 个</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        j <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># j 始终保存着下一个要更新的元素的索引</span>        current_num <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        duplicates_times <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> current_num<span class="token punctuation">:</span>                duplicates_times <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">if</span> duplicates_times <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 这一步赋值是非常关键的</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> current_num                    j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> current_num<span class="token punctuation">:</span>                current_num <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                duplicates_times <span class="token operator">=</span> <span class="token number">0</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：使用一个 <code>counter</code> 变量向前“数”，这个写法把它记住就好。<strong>关键之处： <code>counter</code> 变量控制着新数组的写入，<code>counter</code> 指向着下一个要写入的元素的索引，它也代表了新数组的个数 。</strong></p><p>例如：<code>nums = [0, 0, 1, 1, 1, 1, 2, 3, 3]</code>。</p><p><img src="http://upload-images.jianshu.io/upload_images/414598-74ba9dfae8da9065.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LeetCode 第 80 题 ：删除排序数组中的重复项 II"></p><p>Python 代码：在理解的基础上记住下面这个写法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> l        counter <span class="token operator">=</span> <span class="token number">2</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>counter <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>counter<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                counter <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> counter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 75 题：颜色分类</title>
      <link href="/leetcode-algo/2017/06/07/leetcode-algo/0075-sort-colors/"/>
      <url>/leetcode-algo/2017/06/07/leetcode-algo/0075-sort-colors/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-75-题：颜色分类"><a href="#「力扣」第-75-题：颜色分类" class="headerlink" title="「力扣」第 75 题：颜色分类"></a>「力扣」第 75 题：颜色分类</h2><p>传送门：<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a>。</p><blockquote><p>给定一个包含红色、白色和蓝色，一共 <em>n</em> 个元素的数组，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><p><strong>示例:</strong></p><pre><code>输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2]</code></pre><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul></blockquote><p>说明：三路快排的 partition 是非常基础且重要的算法，一定要掌握。</p><p>Python 代码1：分别统计个数，然后逐个赋值，感觉有些麻烦，但是思路还是很清晰的</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: void Do not return anything, modify nums in-place instead.        """</span>        counter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            counter<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>counter<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>counter<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>counter<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>            i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码2：与上一个版本等价</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: void Do not return anything, modify nums in-place instead.        """</span>        counter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            counter<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span> count <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> idx                i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码3：三路快排，不用借助额外的存储空间，直接遍历一遍数组，通过交换元素的位置就完成了排序</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 循环不变量的定义：</span>        <span class="token comment" spellcheck="true"># [0, zero] 中的元素全部等于 0</span>        <span class="token comment" spellcheck="true"># (zero, i) 中的元素全部等于 1</span>        <span class="token comment" spellcheck="true"># [two, l - 1] 中的元素全部等于 2</span>        zero <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        two <span class="token operator">=</span> l        i <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 马上要看的位置</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> two<span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                zero <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>zero<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>zero<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                two <span class="token operator">-=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>two<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>two<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/lw_power/article/details/104067001" target="_blank" rel="noopener">「力扣」第 75 题：颜色分类（循环不变式设计）</a></li><li><a href="https://leetcode-cn.com/problems/sort-colors/solution/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan/" target="_blank" rel="noopener">快速排序 partition 过程（重点在设计循环不变量）</a></li></ul><h2 id="「力扣」第-75-题：颜色分类-1"><a href="#「力扣」第-75-题：颜色分类-1" class="headerlink" title="「力扣」第 75 题：颜色分类"></a>「力扣」第 75 题：颜色分类</h2><p>传送门：<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a>。</p><blockquote><p>给定一个包含红色、白色和蓝色，一共 <em>n</em> 个元素的数组，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p><p><strong>示例:</strong></p><pre><code>输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2]</code></pre><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul></blockquote><p>说明：三路快排的 partition 是非常基础且重要的算法，一定要掌握。</p><p>Python 代码 1：分别统计个数，然后逐个赋值，感觉有些麻烦，但是思路还是很清晰的</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: void Do not return anything, modify nums in-place instead.        """</span>        counter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            counter<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>counter<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>counter<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>counter<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>            i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码 2：与上一个版本等价</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: void Do not return anything, modify nums in-place instead.        """</span>        counter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>            counter<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span> count <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> idx                i <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码3：三路快排，不用借助额外的存储空间，直接遍历一遍数组，通过交换元素的位置就完成了排序</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 循环不变量的定义：</span>        <span class="token comment" spellcheck="true"># [0, zero] 中的元素全部等于 0</span>        <span class="token comment" spellcheck="true"># (zero, i) 中的元素全部等于 1</span>        <span class="token comment" spellcheck="true"># [two, l - 1] 中的元素全部等于 2</span>        zero <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        two <span class="token operator">=</span> l        i <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 马上要看的位置</span>        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> two<span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                zero <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>zero<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>zero<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                two <span class="token operator">-=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>two<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>two<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三路快排：<a href="https://www.liwei.party/2019/01/09/algorithms-and-data-structures/quick-sort-3/。" target="_blank" rel="noopener">https://www.liwei.party/2019/01/09/algorithms-and-data-structures/quick-sort-3/。</a></p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 67 题：二进制加法</title>
      <link href="/leetcode-algo/2017/06/06/leetcode-algo/0067-add-binary/"/>
      <url>/leetcode-algo/2017/06/06/leetcode-algo/0067-add-binary/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-67-题：二进制加法"><a href="#「力扣」第-67-题：二进制加法" class="headerlink" title="「力扣」第 67 题：二进制加法"></a>「力扣」第 67 题：二进制加法</h2><ul><li><p>链接：<a href="https://leetcode-cn.com/problems/add-binary" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-binary</a></p></li><li><p>题解链接：<a href="https://leetcode-cn.com/problems/add-binary/solution/mo-shi-er-jin-zhi-shu-shi-jia-fa-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-binary/solution/mo-shi-er-jin-zhi-shu-shi-jia-fa-by-liweiwei1419/</a></p></li></ul><blockquote><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p>示例 1：</p><pre><code>输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot;</code></pre><p>示例 2：</p><pre><code>输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot;</code></pre><p>提示：</p><ul><li>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。</li><li>1 &lt;= a.length, b.length &lt;= 10^4</li><li>字符串如果不是 “0” ，就都不含前导零。</li></ul></blockquote><p>思路：从尾巴开始加。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">addBinary</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type a: str        :type b: str        :rtype: str        """</span>        res <span class="token operator">=</span> <span class="token string">''</span>        <span class="token comment" spellcheck="true"># 分别表示两个数从后向前的索引，后对齐</span>        i <span class="token operator">=</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        j <span class="token operator">=</span> len<span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 表示进位标志</span>        carry <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">or</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>            s <span class="token operator">=</span> carry            <span class="token keyword">if</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>                s <span class="token operator">+=</span> ord<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>                i <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">if</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>                s <span class="token operator">+=</span> ord<span class="token punctuation">(</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>                j <span class="token operator">-=</span> <span class="token number">1</span>            res <span class="token operator">=</span> str<span class="token punctuation">(</span>s <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> res            carry <span class="token operator">=</span> s <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">if</span> carry <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token string">'1'</span> <span class="token operator">+</span> res        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 66 题：加 1</title>
      <link href="/leetcode-algo/2017/06/05/leetcode-algo/0066-plus-one/"/>
      <url>/leetcode-algo/2017/06/05/leetcode-algo/0066-plus-one/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-66-题：加-1"><a href="#「力扣」第-66-题：加-1" class="headerlink" title="「力扣」第 66 题：加 1"></a>「力扣」第 66 题：加 1</h2><p>链接：<a href="https://leetcode-cn.com/problems/plus-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one</a></p><blockquote><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1：</p><pre><code>输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。</code></pre><p>示例 2：</p><pre><code>输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。</code></pre></blockquote><p>思路：注意可以<strong>提前终止</strong>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> digits<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> carry<span class="token punctuation">;</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果不产生进位，马上就可以返回了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>carry <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> digits<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>carry <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> digits<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> digits<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">plusOne</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type digits: List[int]        :rtype: List[int]        """</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>digits<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token comment" spellcheck="true"># 从后向前</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">:</span>                digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">return</span> digits            <span class="token keyword">else</span><span class="token punctuation">:</span>                digits<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> digits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 41 题：缺失的第一个正数</title>
      <link href="/leetcode-algo/2017/06/04/leetcode-solution-new/first-missing-positive/"/>
      <url>/leetcode-algo/2017/06/04/leetcode-solution-new/first-missing-positive/</url>
      
        <content type="html"><![CDATA[<h1 id="「力扣」第-41-题：缺失的第一个正数"><a href="#「力扣」第-41-题：缺失的第一个正数" class="headerlink" title="「力扣」第 41 题：缺失的第一个正数"></a>「力扣」第 41 题：缺失的第一个正数</h1><p>题解地址：<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">桶排序 + 基于“异或运算”交换两个变量的值（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a>。</p><blockquote><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p><p>示例 1:</p><p>输入: [1,2,0]<br>输出: 3<br>示例 2:</p><p>输入: [3,4,-1,1]<br>输出: 2<br>示例 3:</p><p>输入: [7,8,9,11,12]<br>输出: 1<br>说明:</p><p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</p></blockquote><h2 id="桶排序-基于“异或运算”交换两个变量的值（Python-代码、Java-代码）"><a href="#桶排序-基于“异或运算”交换两个变量的值（Python-代码、Java-代码）" class="headerlink" title="桶排序 + 基于“异或运算”交换两个变量的值（Python 代码、Java 代码）"></a>桶排序 + 基于“异或运算”交换两个变量的值（Python 代码、Java 代码）</h2><p>这道题使用桶排序的思路，即 “一个萝卜一个坑”。在学习“排序算法”的时候，可能会忽略“桶排序”的作用，但它的思想的确可以解决一些特定问题。</p><p>“桶排序”的思想，有些地方也把它叫做“抽屉原理”，以下介绍来自[“百度百科”之“抽屉原理”词条]：</p><blockquote><p>抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有 n + 1 个元素放到 n 个集合中去，其中必定有一个集合里至少有两个元素。” 抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理。</p></blockquote><p><strong>思路分析</strong>：可以就使用题目中的例子，在纸上写写画画，就能得出思路，只不过在编码上需要注意一些细节。</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0041/41-0.png" alt="41.png"></p><p>下面是“桶排序”过程。</p><p>（温馨提示：下面的幻灯片中，有几页上有较多的文字，可能需要您停留一下，可以点击右下角的后退 “|◀” 或者前进 “▶|” 按钮控制幻灯片的播放。）</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0041/new/0041.gif" alt=""></p><p>如图所示：我们可以把数组进行一次“排序”，“排序”的规则是：<strong>如果这个数字 <code>i</code> 落在“区间范围里”，<code>i</code> 就应该放在索引为 <code>i - 1</code> 的位置上</strong>，下面具体解释。</p><p>1、数字 <code>i</code> 落在“区间范围里”；</p><p>例如：<code>[3, 4, -1, 1]</code>，一共 4 个数字，那么如果这个数组中出现 “1”、“2”、“3”、“4”，就是我们重点要关注的数字了；<br>又例如：<code>[7, 8, 9, 11, 12]</code> 一共 5 个数字，每一个都不是 “1”、“2”、“3”、“4”、“5” 中的一个，因此我们无须关注它们；</p><p>2、<code>i</code> 就应该放在索引为<code>i - 1</code> 的位置上；</p><p>这句话也可以这么说 “<strong>索引为 <code>i</code> 的位置上应该存放的数字是 <code>i  + 1</code></strong>”。</p><p>就看上面那张图，数字 $1$ 应该放在索引为 $0$ 的位置上，数字 $3$ 应该放在索引为 $2$ 的位置上，数字 $4$ 应该放在索引为 $3$ 的位置上。一个数字放在它应该放的位置上，我们就认为这个位置是“和谐”的，看起来“顺眼”的。</p><p>按照以上规则排好序以后，缺失的第 $1$ 个正数一下子就看出来了，那么“最不和谐”的数字的索引 $+ 1$，就为所求。那如果所有的数字都不“和谐”，数组的长度 $+ 1$ 就为所求。</p><p><strong>参考代码 1</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> size<span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 如果已经在合适的位置上，就不用交换了</span>                    <span class="token keyword">break</span>                <span class="token comment" spellcheck="true"># 这里我单独把交换数组两个位置的方法封装起来，是为了不让自己出错，这一行代码有点绕</span>                <span class="token comment" spellcheck="true"># 就要把它放到合适的位置上，i 应该放在索引为 i - 1 的位置上</span>                self<span class="token punctuation">.</span>__swap<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i <span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 从头到尾看一遍</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> size <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__swap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> index1<span class="token punctuation">,</span> index2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> index1 <span class="token operator">==</span> index2<span class="token punctuation">:</span>            <span class="token keyword">return</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 关键字：桶排序，什么数字就要放在对应的索引上，其它空着就空着</span>    <span class="token comment" spellcheck="true">// 最好的例子：[3,4,-1,1]</span>    <span class="token comment" spellcheck="true">// 整理好应该是这样：[1,-1,3,4]，</span>    <span class="token comment" spellcheck="true">// 这里 1，3，4 都在正确的位置上，</span>    <span class="token comment" spellcheck="true">// -1 不在正确的位置上，索引是 1 ，所以返回 2</span>    <span class="token comment" spellcheck="true">// [4,3,2,1] 要变成 [1,2,3,4]，*** Offer 上有类似的问题。</span>    <span class="token comment" spellcheck="true">// 这里负数和大于数组长度的数都是"捣乱项"。</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 前两个是在判断是否成为索引</span>            <span class="token comment" spellcheck="true">// 后一个是在判断，例如 3 在不在索引 2 上</span>            <span class="token comment" spellcheck="true">// 即 nums[i] ?= nums[nums[i]-1] 这里要特别小心</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> len <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 第 3 个条件不成立的索引的部分是 i 和 nums[i]-1</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 调试代码</span>        <span class="token comment" spellcheck="true">// System.out.println(Arrays.toString(nums));</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// [1,-2,3,4]</span>            <span class="token comment" spellcheck="true">// 除了 -2 其它都满足： i+1 = num[i]</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index1 <span class="token operator">==</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// int[] nums = {3, 4, -1, 5};</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> firstMissingPositive <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">firstMissingPositive</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstMissingPositive<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，这里 $N$ 是数组的长度，其实只要看这个数组一遍，就可以知道每个数字应该放在哪个位置，所以时间复杂度是 $O(N)$。</li><li>空间复杂度：$O(1)$，桶排序在原地进行，没有使用额外的存储空间。</li></ul><hr><p><strong>补充内容</strong>：</p><p>交换两个整数，有两种比较 tricky 的做法。下面只给出结论，不给出解释（我也解释不了）。</p><blockquote><p>交换两个变量的值，例如 a 和 b，不使用第三个变量，有两种不同的方法：</p></blockquote><table><thead><tr><th>基于异或运算</th><th>基于加减法</th></tr></thead><tbody><tr><td><code>a = a ^ b</code><br><code>b = a ^ b</code><br><code>a = a ^ b</code></td><td><code>a = a + b</code><br/><code>b = a - b</code><br/><code>a = a - b</code></td></tr></tbody></table><p>我理解的方式就是自己在纸上写几个例子，并且记住这个结论。个人觉得“基于异或运算”交换两个变量的值好记一些，因为右边都一样，左边是 <code>a</code>、<code>b</code>、<code>a</code>。</p><p><strong>参考代码 2</strong>：基于异或运算交换两个变量的值。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 题目中给出的例子，就是最好的例子</span>        <span class="token comment" spellcheck="true"># [3,4,-1,1]</span>        <span class="token comment" spellcheck="true"># [-1,4,3,1]</span>        <span class="token comment" spellcheck="true"># [-1,1,3,4]</span>        <span class="token comment" spellcheck="true"># 3 应该放在索引为 2 的地方</span>        <span class="token comment" spellcheck="true"># 4 应该放在索引为 3 的地方</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># nums[i] > 0 and nums[i] &lt;= size 的意思是：只要是符合索引的数字</span>            <span class="token comment" spellcheck="true"># 这里的索引应该认为从 1 开始</span>            <span class="token comment" spellcheck="true"># 就要把它放到正确的地方上去，这一步叫 hash</span>            <span class="token comment" spellcheck="true"># nums[i] == nums[nums[i]-1]，叫放到了正确的地方</span>            <span class="token comment" spellcheck="true"># 例如，3 应该放在索引为 2 的地方，如果不理解，这句话多读几遍</span>            <span class="token comment" spellcheck="true"># 所以，先判断这个数字是不是索引</span>            <span class="token comment" spellcheck="true"># 然后判断这个数字是不是放在了正确的地方</span>            <span class="token keyword">while</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> size <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 交换</span>                self<span class="token punctuation">.</span>__swap<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># print(nums)</span>        <span class="token comment" spellcheck="true"># 再遍历一次，没有放对的就是你要找的</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># value： [1,2,3,4]</span>            <span class="token comment" spellcheck="true"># index： [0,1,2,3]</span>            <span class="token keyword">if</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> size <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__swap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> index1<span class="token punctuation">,</span> index2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># nums[index1], nums[index2] = nums[index2], nums[index1]</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">^</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span>        nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">^</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">^</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 关键字：桶排序，什么数字就要放在对应的索引上，其它空着就空着</span>    <span class="token comment" spellcheck="true">// 最好的例子：[3,4,-1,1]</span>    <span class="token comment" spellcheck="true">// 整理好应该是这样：[1,-1,3,4]，</span>    <span class="token comment" spellcheck="true">// 这里 1，3，4 都在正确的位置上，</span>    <span class="token comment" spellcheck="true">// -1 不在正确的位置上，索引是 1 ，所以返回 2</span>    <span class="token comment" spellcheck="true">// [4,3,2,1] 要变成 [1,2,3,4]，*** Offer 上有类似的问题。</span>    <span class="token comment" spellcheck="true">// 这里负数和大于数组长度的数都是"捣乱项"。</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 前两个是在判断是否成为索引</span>            <span class="token comment" spellcheck="true">// 后一个是在判断，例如 3 在不在索引 2 上</span>            <span class="token comment" spellcheck="true">// 即 nums[i] ?= nums[nums[i]-1] 这里要特别小心</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> len <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 第 3 个条件不成立的索引的部分是 i 和 nums[i]-1</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 调试代码</span>        <span class="token comment" spellcheck="true">// System.out.println(Arrays.toString(nums));</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// [1,-2,3,4]</span>            <span class="token comment" spellcheck="true">// 除了 -2 其它都满足： i+1 = num[i]</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">^</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">^</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">^</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution2 solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// int[] nums = {3, 4, -1, 5};</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> firstMissingPositive <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">firstMissingPositive</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstMissingPositive<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p><hr><table><thead><tr><th>题目地址</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">LeetCode 第 41 题：缺失的第一个正数</a></td><td><a href="https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">桶排序（Python 代码、Java 代码）</a></td></tr></tbody></table><ul><li>提示：点击上面的题解链接，可以看到我制作的幻灯片轮播图。</li></ul><p>这道题使用桶排序的思路，即 “一个萝卜一个坑”，就可以解决。可以就使用题目中的例子，在纸上写写画画，就能得出思路，只不过在编码上需要注意一些细节。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/41-9.png" alt="LeetCode 第 41 题：缺失的第一个正数"></p><p>下面是“桶排序”过程。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/LeetCode-0041.gif" alt="LeetCode 第 41 题：缺失的第一个正数"></p><hr><p>以下是上面 gif 图的静态图。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/41-1.png" alt="LeetCode 第 41 题：缺失的第一个正数-1"></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/41-2.png" alt="LeetCode 第 41 题：缺失的第一个正数-2"></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/41-3.png" alt="LeetCode 第 41 题：缺失的第一个正数-3"></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/41-4.png" alt="LeetCode 第 41 题：缺失的第一个正数-4"></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/41-5.png" alt="LeetCode 第 41 题：缺失的第一个正数-5"></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/41-6.png" alt="LeetCode 第 41 题：缺失的第一个正数-6"></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/41-7.png" alt="LeetCode 第 41 题：缺失的第一个正数-7"></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/41-8.png" alt="LeetCode 第 41 题：缺失的第一个正数-8"></p><p>如图所示：我们可以把数组进行一次“排序”，“排序”的规则是：<strong>如果这个数字 <code>i</code> 落在“区间范围里”，<code>i</code> 就应该放在索引为 <code>i - 1</code> 的位置上</strong>，下面具体解释。</p><p>1、数字 <code>i</code> 落在“区间范围里”；</p><p>例如：<code>[3, 4, -1, 1]</code>，一共 4 个数字，那么如果这个数组中出现 “1”、“2”、“3”、“4”，就是我们重点要关注的数字了；<br>又例如：<code>[7, 8, 9, 11, 12]</code> 一共 5 个数字，每一个都不是 “1”、“2”、“3”、“4”、“5” 中的一个，因此我们无须关注它们；</p><p>2、<code>i</code> 就应该放在索引为<code>i - 1</code> 的位置上；</p><p>这句话也可以这么说 “<strong>索引为 <code>i</code> 的位置上应该存放的数字是 <code>i  + 1</code></strong>”。</p><p>就看上面那张图，数字 $1$ 应该放在索引为 $0$ 的位置上，数字 $3$ 应该放在索引为 $2$ 的位置上，数字 $4$ 应该放在索引为 $3$ 的位置上。一个数字放在它应该放的位置上，我们就认为这个位置是“和谐”的，看起来“顺眼”的。</p><p>按照以上规则排好序以后，缺失的第 $1$ 个正数一下子就看出来了，那么“最不和谐”的数字的索引 $+ 1$，就为所求。那如果所有的数字都不“和谐”，数组的长度 $+ 1$ 就为所求。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def firstMissingPositive(self, nums: List[int]) -> int:        size = len(nums)        if size == 0:            return 1        for i in range(size):            while nums[i] > 0 and nums[i] <= size:                if nums[nums[i] - 1] == nums[i]:                    # 如果已经在合适的位置上，就不用交换了                    break                # 这里我单独把交换数组两个位置的方法封装起来，是为了不让自己出错，这一行代码有点绕                # 就要把它放到合适的位置上，i 应该放在索引为 i - 1 的位置上                self.__swap(nums, i , nums[i] - 1)        # 从头到尾看一遍        for i in range(size):            if nums[i] != i + 1:                return i + 1        return size + 1    def __swap(self, nums, index1, index2):        if index1 == index2:            return        nums[index1], nums[index2] = nums[index2], nums[index1]  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Arrays;public class Solution {    // 关键字：桶排序，什么数字就要放在对应的索引上，其它空着就空着    // 最好的例子：[3,4,-1,1]    // 整理好应该是这样：[1,-1,3,4]，    // 这里 1，3，4 都在正确的位置上，    // -1 不在正确的位置上，索引是 1 ，所以返回 2    // [4,3,2,1] 要变成 [1,2,3,4]，*** Offer 上有类似的问题。    // 这里负数和大于数组长度的数都是"捣乱项"。    public int firstMissingPositive(int[] nums) {        int len = nums.length;        for (int i = 0; i < len; i++) {            // 前两个是在判断是否成为索引            // 后一个是在判断，例如 3 在不在索引 2 上            // 即 nums[i] ?= nums[nums[i]-1] 这里要特别小心            while (nums[i] > 0 && nums[i] <= len && nums[nums[i] - 1] != nums[i]) {                // 第 3 个条件不成立的索引的部分是 i 和 nums[i]-1                swap(nums, nums[i] - 1, i);            }        }        // 调试代码        // System.out.println(Arrays.toString(nums));        for (int i = 0; i < len; i++) {            // [1,-2,3,4]            // 除了 -2 其它都满足： i+1 = num[i]            if (nums[i] - 1 != i) {                return i + 1;            }        }        return len + 1;    }    private void swap(int[] nums, int index1, int index2) {        if (index1 == index2) {            return;        }        int temp = nums[index1];        nums[index1] = nums[index2];        nums[index2] = temp;    }    public static void main(String[] args) {        Solution solution = new Solution();        // int[] nums = {3, 4, -1, 5};        int[] nums = {4, 3, 2, 1};        int firstMissingPositive = solution.firstMissingPositive(nums);        System.out.println(firstMissingPositive);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(N)$，这里 $N$ 是数组的长度，其实只要看这个数组一遍，就可以知道每个数字应该放在哪个位置，所以时间复杂度是 $O(N)$。</li><li>空间复杂度：$O(1)$，桶排序在原地进行，没有使用额外的存储空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 原地哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 27 题：移动元素</title>
      <link href="/leetcode-algo/2017/06/03/leetcode-algo/0026-remove-duplicates-from-sorted-array/"/>
      <url>/leetcode-algo/2017/06/03/leetcode-algo/0026-remove-duplicates-from-sorted-array/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-27-题：移动元素"><a href="#「力扣」第-27-题：移动元素" class="headerlink" title="「力扣」第 27 题：移动元素"></a>「力扣」第 27 题：移动元素</h2><p>传送门：英文网址：<a href="https://leetcode.com/problems/remove-element/description/" target="_blank" rel="noopener">27. Remove Element</a> ，中文网址：<a href="https://leetcode-cn.com/problems/remove-element/description/" target="_blank" rel="noopener">27. 移除元素</a> 。</p><blockquote><p>给定一个数组 <em>nums</em> 和一个值 <em>val<em>，你需要*</em>原地**移除所有数值等于 *val</em> 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1:</strong></p><pre><code>给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2:</strong></p><pre><code>给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);}</code></pre></blockquote><p>思路：设置一个指针 <code>j</code>，遍历过程中遇到要删除的元素，跳到下一个，遇到保留元素，<code>j</code> 位置赋值，并且 <code>j</code> 索引 <code>+ 1</code>，最后不要忘记遍历完成以后，删除索引 <code>j</code> 后面的所有元素。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :type val: int        :rtype: int        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> val<span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="「力扣」第-27-题：删除元素"><a href="#「力扣」第-27-题：删除元素" class="headerlink" title="「力扣」第 27 题：删除元素"></a>「力扣」第 27 题：删除元素</h3><p>要求：在一个数组里面移除指定元素，并返回新的数组的长度。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 只要遇到与 val 不等的元素，就累加 1</span>            <span class="token comment" spellcheck="true">// 所以，直接返回 j 就可以了</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：就这道问题，我们要考虑的问题是：</p><ul><li>如何定义删除？从数组中删除？还是放在数组的末尾？</li><li>剩余元素的排列是否要保证原来的相对顺序？</li><li>是否有空间复杂度的要求？</li></ul><p>我的解答：有瑕疵，因为在 Java 中数组的长度是固定的。在这个函数中不能移除 Java 数组中的元素。但是居然在 LeetCode 中通过了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Given input array nums = [3,2,2,3], val = 3</span>    <span class="token comment" spellcheck="true">/**     * 题目的要求中说，顺序可以改变     * 不管怎么样，先写出来最要紧     * 难点：Java 中的数组元素怎么删除，这里我没有实现     *     * @param nums     * @param val     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> k<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> removeElementNum <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">removeElement</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>removeElementNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第 2 遍解答，其实本质上是一样的，思路分析：对题目的说明：在一个数组里面移除指定元素，并返回新的数组的长度。<br>解题思路：给出两个指针 i 和 j，其中 i 就想我们平常遍历数组元素一样，是一个普通的循环遍历。<br>和 j 就像是一支笔，我们要借助这支笔，往一个新数组里面写数据。<br>只不过，根据题意，我们恰恰好可以利用原来的数组的空间，这是因为，我们的任务是 Remove Element，新数组的元素个数一定不会超过原数组的元素个数。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 只要遇到与 val 不等的元素，就累加 1</span>            <span class="token comment" spellcheck="true">// 所以，直接返回 j 就可以了</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">removeElement</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 26 题：删除排序数组中的重复项</title>
      <link href="/leetcode-algo/2017/06/02/leetcode-algo/0026-remove-duplicates-from-sorted-array/"/>
      <url>/leetcode-algo/2017/06/02/leetcode-algo/0026-remove-duplicates-from-sorted-array/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-26-题：删除排序数组中的重复项"><a href="#「力扣」第-26-题：删除排序数组中的重复项" class="headerlink" title="「力扣」第 26 题：删除排序数组中的重复项"></a>「力扣」第 26 题：删除排序数组中的重复项</h2><ul><li>中文网址：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a> ；</li><li>英文网址：<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">26. Remove Duplicates from Sorted Array</a> 。</li></ul><blockquote><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><pre><code>给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2:</strong></p><pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);}</code></pre></blockquote><p>思路：注意到排序数组这个条件。并且应该注意到一些特殊的测试用例，例如 <code>nums = []</code> 的时候。注意，题目要求返回新数组的长度。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 只要有重复的元素覆盖就可以了</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 接下来要赋值的那个元素</span>        j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                j <span class="token operator">+=</span> <span class="token number">1</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> j <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>1、首先我们需要一个变量，这里我声明为memory 来保存一个被比较的数。首先，数组的第 1 个元素（index = 0 的那个）被存进去；</p><p>2、接着从数组的第 2 位开始遍历，遇到和 memory 的值一样的，就什么都不做，遇到和 memory 不一样的，把当前值更新到 memory 中，并且 j 加 1 ，在原数组 j 这个索引上也更新这个值。</p><p>分析：利用了 a sorted array 的特点，新数组的元素个数也一定不会超过原来的数组，所以可以不借助额外的空间来完成题目的要求。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> memory <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> memory <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>                memory <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// int[] nums = new int[]{1,1,1,2,2,2,3,3,3,4,5,6,7,7,7,8,9,10,10};</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">removeDuplicates</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一种解法可以参：leet-solution<br>的解答。不借助额外的空间。一开始 j 在 i 后面一格，然后马上比较两个元素的值，如果元素的值一样，则 j 加 1 ，如果元素的值不一样，j 和 i 都加 1 。</p><p>解法2：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 什么都不做</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span><span class="token operator">++</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 返回的是数组的长度，所以要 + 1</span>        <span class="token keyword">return</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：</p><ul><li>要求从一个有序的数组中删除重复的元素。</li><li>思考如何定义删除？是从数组中删除？还是放在数组的末尾？</li><li>剩余元素的排列是否要保证原有的相对顺序？</li><li>是否有空间复杂度的要求？</li><li>这里也用到了循环不变量的定义，要明确才能正确写出代码逻辑。</li></ul><p>思路</p><ol><li>挨个加入到一个 Map 中，判断是否有键值，这个思路没有利用到数组的有序性，故不采纳；</li><li>后一个元素减去前一个元素，如果等于0，就说明重复了（我用这种办法）。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 删除重复的元素，按照 LeetCode 上 Java 对删除数组元素的删除的判定，     * LeetCode 上的规则就是不判定，只要这个数组前面有效索引上的数是正确的就可以了     *     * @param nums     * @return 不重复的元素个数     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 定义 [0,k)是一个没有重复元素的有序数组</span>        <span class="token comment" spellcheck="true">// 从第 1 个元素开始，依次考察前面的元素</span>        <span class="token comment" spellcheck="true">// 特别注意到三个元素连续的情况，例如 [6,6,6,6,7]</span>        <span class="token comment" spellcheck="true">// 判断第 1 个元素该不该进去</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nums<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> k<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//int[] sortedArray = {1, 2};</span>        <span class="token comment" spellcheck="true">//int[] sortedArray = {1, 1};</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sortedArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//int[] sortedArray1 = {1,2,3,2,3,4,5,6,6,6,7,7,8,9};</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> non_duplicates <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">removeDuplicates</span><span class="token punctuation">(</span>sortedArray<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"不重复的元素个数有 => "</span> <span class="token operator">+</span> non_duplicates<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>sortedArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：这一版我写得不好，吃过一次晚饭以后，才得到了 Accepted。总结如下：<br>1、没有考虑极端的情况；<br>2、第 1 个元素必须加入到结果数组中；<br>3、既然我是与前一个元素进行比较，那么我的索引最大值就应该是数组长度-1，边界值问题模糊不清也是我经常犯的错误。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 循环不变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 3 题：无重复字符的最长子串（滑动窗口典型问题）</title>
      <link href="/leetcode-algo/2017/06/01/leetcode-solution/longest-substring-without-repeating-characters/"/>
      <url>/leetcode-algo/2017/06/01/leetcode-solution/longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-3-题：无重复字符的最长子串（滑动窗口典型问题）"><a href="#「力扣」第-3-题：无重复字符的最长子串（滑动窗口典型问题）" class="headerlink" title="「力扣」第 3 题：无重复字符的最长子串（滑动窗口典型问题）"></a>「力扣」第 3 题：无重复字符的最长子串（滑动窗口典型问题）</h2><p>标签（空格分隔）： 动态规划 滑动窗口 散列表</p><p>传送门：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a>。这道题也是《剑指Offer》上第 48 题。</p><ul><li>题解链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/ge-ban-fa-hua-dong-chuang-kou-dong-tai-gui-hua-pyt/" target="_blank" rel="noopener">滑动窗口、哈希表优化 + 动态规划、滚动变量（Python 代码、Java 代码）</a></li></ul><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。  请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre></blockquote><h3 id="方法一：哈希表-隔板法（好几种写法）"><a href="#方法一：哈希表-隔板法（好几种写法）" class="headerlink" title="方法一：哈希表 + 隔板法（好几种写法）"></a>方法一：哈希表 + 隔板法（好几种写法）</h3><p>判断一个元素有没有出现过，使用哈希表是最自然的想法。</p><p>以下面的例子进行说明：</p><table><thead><tr><th>$d$</th><th>$a$</th><th>$b$</th><th>$a$</th><th>$d$</th><th>$c$</th></tr></thead><tbody><tr><td>$0$</td><td>$1$</td><td>$2$</td><td>$3$</td><td>$4$</td><td>$5$</td></tr></tbody></table><p>判断连续区间内是否出现重复元素，可以使用 <code>set</code>，又要存储位置，所以使用 <code>dict</code>。</p><ul><li>到索引为 $3$ 的时候，出现重复，我们可以在 $a$ 的<strong>下一个位置</strong>插一个“小木板”，表示从这个“小木板”到当前位置没有重复。如果出现重复的索引在“小木板”之前，例如到索引 $4$ 的时候，此时“小木板”在索引 $2$ 处，两个 $d$ 之间已经有了两个 $a$ ，可以无视这种情况。</li></ul><p>Python 代码1：（推荐写法）</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzjqewk2p3j312r0u0gns.jpg" alt="image-20190117021730626"></p><p>等价的写法：（我的练习）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        map <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        max_len <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 可以认为是标定的起始</span>        pointer <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> c <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> c <span class="token keyword">in</span> map<span class="token punctuation">:</span>                pointer <span class="token operator">=</span> max<span class="token punctuation">(</span>pointer<span class="token punctuation">,</span> map<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            max_len <span class="token operator">=</span> max<span class="token punctuation">(</span>max_len<span class="token punctuation">,</span> index <span class="token operator">-</span> pointer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 每次遍历都更新当前遍历到的字母的位置</span>            map<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> index        <span class="token keyword">return</span> max_len<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的一点是：只有重复出现的位置大于等于隔板位置的时候，才要更新，更新的位置是当前位置 + 1。即只要出现重复，隔板就向后移动一位，然后每一轮都计算当前与隔板的距离。</p><p>Python 代码2：（不如上面的代码语义清晰）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 特判</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> l        <span class="token comment" spellcheck="true"># 隔板法</span>        <span class="token comment" spellcheck="true"># key:字符，val 出现的索引</span>        map <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        point <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 关键1：map[s[i]] >= point，等于是可以的</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> map <span class="token operator">and</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> point<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 先把隔板向后移动一位</span>                point <span class="token operator">=</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 然后记录最长不重复子串的长度</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> i <span class="token operator">-</span> point <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 关键2：无论如何都更新位置</span>            map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等价的写法：（我的练习）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: int        """</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> l        point <span class="token operator">=</span> <span class="token number">0</span>        map <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> alpha <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> alpha <span class="token keyword">in</span> map <span class="token operator">and</span> map<span class="token punctuation">[</span>alpha<span class="token punctuation">]</span> <span class="token operator">>=</span> point<span class="token punctuation">:</span>                point <span class="token operator">=</span> map<span class="token punctuation">[</span>alpha<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 每次要做两件事：1、计算无重复子串长度</span>            result <span class="token operator">=</span> max<span class="token punctuation">(</span>result<span class="token punctuation">,</span> index <span class="token operator">-</span> point <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 2、更新索引</span>            map<span class="token punctuation">[</span>alpha<span class="token punctuation">]</span> <span class="token operator">=</span> index        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>dp[i]：以 <code>s[i]</code> 结尾的最长不重复子串，这个状态的设置与最长上升子序列、最大连续子数组是一样的。</p><p>下面考虑 <code>dp[i]</code> 和 <code>dp[i - 1]</code> 之间的关系。关键在于 <code>dp [i - 1]</code> 与距离出现相同字符的时候，两个相同字符的距离的比较。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzjqexh1ftj30w40kcjwg.jpg" alt="image-20190110155039515"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzjqexypvdj30u00vjq7o.jpg" alt="image-20190117145651932"></p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 特判</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> l        <span class="token comment" spellcheck="true"># dp[i] 表示以 s[i] 结尾的最长不重复子串的长度</span>        <span class="token comment" spellcheck="true"># 因为自己肯定是不重复子串，所以初始值设置为 1</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">]</span>        map <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        map<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> map<span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">-</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 设置字符与索引键值对</span>            map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token comment" spellcheck="true"># 最后拉通看一遍最大值</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解法3：滑动窗口、双指针"><a href="#解法3：滑动窗口、双指针" class="headerlink" title="解法3：滑动窗口、双指针"></a>解法3：滑动窗口、双指针</h3><p>Python 代码：推荐写法</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 滑动窗口的做法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 特判</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> size        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        counter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 尝试走一步，如果可以走，就计算</span>            <span class="token keyword">if</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">and</span> counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 表示没有重复元素，r 可以加 1</span>                counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                r <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 有重复元素，左边就要减 1</span>                counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：滑动窗口写法2</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 特判</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> size        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        counter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 首先"右指针"不断向右边尝试，走到出现重复的最右边</span>            <span class="token keyword">while</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">and</span> counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 表示没有重复元素，r 可以加 1</span>                counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                r <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 此时，记录不重复子串是"左指针"固定时候最长</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 考虑移动"左指针"</span>            <span class="token comment" spellcheck="true"># 此时 s[r+1] 就是已经扫过的区间里重复的元素，要把它剔除出去</span>            <span class="token keyword">while</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">and</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 有重复元素，左边就要减 1</span>                counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 出了上一个循环以后，还要再把左指针向右移动一格，否则右指针不能向右移动</span>            counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>            l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p><hr><h2 id="「力扣」第-3-题：无重复字符的最长子串"><a href="#「力扣」第-3-题：无重复字符的最长子串" class="headerlink" title="「力扣」第 3 题：无重复字符的最长子串"></a>「力扣」第 3 题：无重复字符的最长子串</h2><p>传送门：英文网址：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters</a> ，中文网址：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a> 。</p><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre></blockquote><p>思路1：使用滑动窗口、“双指针”。</p><p>步骤1：首先试一试“右指针”能不能向右边“扩散”，即尝试“扩散”的元素在已经扫过的元素中还没有出现（字母频率为 $0$），可以向右“扩散”，则频率加 $1$。</p><p>步骤2：如果不能扩散，把“左指针”向右移动一格，相应的字母频率减 $1$。然后继续步骤1。</p><p>在以上两个步骤中，记录下最长不重复的子串的长度。</p><p>Python 代码：滑动窗口、“双指针”典型的写法，在理解的基础上记住它</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: int        """</span>        <span class="token comment" spellcheck="true"># 特判</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> size        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        counter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>            <span class="token keyword">if</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">and</span> counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 表示没有重复元素，r 可以加 1</span>                counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                r <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 有重复元素，左边就要减 1</span>                counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution4</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义成频率数组，刘宇波老师给出的思路，使用滑动窗口的思路</span>    <span class="token comment" spellcheck="true">// 不是很好理解，可以供参考</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> len <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> len<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> freq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 只要左边不越界</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// r + 1 最多到 len-1 表示没有越界</span>            <span class="token comment" spellcheck="true">// freq[s.charAt(r + 1)] == 0 表示下一个字母还没有出现过</span>            <span class="token comment" spellcheck="true">// 【这个分类标准是很关键的，r+1 表示接下来要考察的索引位置，=0 表示在 [l,r] 这个区间里没有出现】</span>            <span class="token comment" spellcheck="true">// 【这个分类标准是很关键的，r+1 表示接下来要考察的索引位置，=0 表示在 [l,r] 这个区间里没有出现】</span>            <span class="token comment" spellcheck="true">// 【这个分类标准是很关键的，r+1 表示接下来要考察的索引位置，=0 表示在 [l,r] 这个区间里没有出现】</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> freq<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 右边第 1 个字母加入频率数组，频数 + 1</span>                freq<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token operator">++</span>r<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果下一个字符已经越界了，或者右边第 1 个字母是频率数组是曾经出现过的</span>                <span class="token comment" spellcheck="true">// 把左边从频数数组中挪掉，即频数减1</span>                freq<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Solution4 solution4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> <span class="token string">"abcabcbb"</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> lengthOfLongestSubstring <span class="token operator">=</span> solution4<span class="token punctuation">.</span><span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>lengthOfLongestSubstring<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：另一种写法，我觉得更直接一些，不过 while 里面还有 while ，看过去不太简洁</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: int        """</span>        <span class="token comment" spellcheck="true"># 特判</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> size        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        counter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> size<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 首先"右指针"不断向右边尝试，走到出现重复的最右边</span>            <span class="token keyword">while</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">and</span> counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 表示没有重复元素，r 可以加 1</span>                counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>                r <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 此时，记录不重复子串是"左指针"固定时候最长</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 考虑移动"左指针"</span>            <span class="token comment" spellcheck="true"># 此时 s[r+1] 就是已经扫过的区间里重复的元素，要把它剔除出去</span>            <span class="token keyword">while</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">and</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 有重复元素，左边就要减 1</span>                counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>                l <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 出了上一个循环以后，还要再把左指针向右移动一格，否则右指针不能向右移动</span>            counter<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>            l <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路2：隔板法</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: int        """</span>        <span class="token comment" spellcheck="true"># 特判</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> l        <span class="token comment" spellcheck="true"># 隔板法</span>        <span class="token comment" spellcheck="true"># key:字符，val 出现的索引</span>        map <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        point <span class="token operator">=</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 关键1：map[s[i]] >= point，等于是可以的</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> map <span class="token operator">and</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>=</span> point<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 先把隔板向后移动一位</span>                point <span class="token operator">=</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 然后记录最长不重复子串的长度</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> i <span class="token operator">-</span> point <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 关键2：无论如何都更新位置</span>            map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路3：还可以使用“动态规划”完成。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type s: str        :rtype: int        """</span>        <span class="token comment" spellcheck="true"># 特判</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> l        <span class="token comment" spellcheck="true"># dp[i] 表示以 s[i] 结尾的最长不重复子串的长度</span>        <span class="token comment" spellcheck="true"># 因为自己肯定是不重复子串，所以初始值设置为 1</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">]</span>        map <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span>        map<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> map<span class="token punctuation">:</span>                <span class="token keyword">if</span> i <span class="token operator">-</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 设置字符与索引键值对</span>            map<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i        <span class="token comment" spellcheck="true"># 最后拉通看一遍最大值</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考资料：<a href="https://www.zybuluo.com/liweiwei1419/note/1394415" target="_blank" rel="noopener">LeetCode 第 3 题：最长不重复字符串</a>。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 4：滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 散列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数组」专题 3：三路快排 partition 的应用</title>
      <link href="/leetcode-algo/2017/05/31/leetcode-solution/array3/"/>
      <url>/leetcode-algo/2017/05/31/leetcode-solution/array3/</url>
      
        <content type="html"><![CDATA[<h2 id="「数组」专题-3：三路快排-partition-的应用"><a href="#「数组」专题-3：三路快排-partition-的应用" class="headerlink" title="「数组」专题 3：三路快排 partition 的应用"></a>「数组」专题 3：三路快排 partition 的应用</h2>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> partition </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 数组专题 2：一些关于数组的问题</title>
      <link href="/leetcode-algo/2017/05/30/leetcode-solution/array2/"/>
      <url>/leetcode-algo/2017/05/30/leetcode-solution/array2/</url>
      
        <content type="html"><![CDATA[<p> （本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数组」专题 1：简单问题汇总</title>
      <link href="/leetcode-algo/2017/05/29/leetcode-solution/array1/"/>
      <url>/leetcode-algo/2017/05/29/leetcode-solution/array1/</url>
      
        <content type="html"><![CDATA[<h2 id="「数组」专题-1：简单问题汇总"><a href="#「数组」专题-1：简单问题汇总" class="headerlink" title="「数组」专题 1：简单问题汇总"></a>「数组」专题 1：简单问题汇总</h2><h3 id="「力扣」第-215-题：数组中的第-K-个最大元素"><a href="#「力扣」第-215-题：数组中的第-K-个最大元素" class="headerlink" title="「力扣」第 215 题：数组中的第 K 个最大元素"></a>「力扣」第 215 题：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array" target="_blank" rel="noopener">数组中的第 K 个最大元素</a></h3><p>1、使用优先队列完成；</p><p>2、使用快速排序完成。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 给定任意一个数组，返回第 k 大的元素，并非索引     *     * @param nums     * @param k     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> p <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 4,3,7,8     *     * @param nums     * @param left     * @param right     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 就找第 1 个元素作为标定点</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [left,i)小于 k</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (j,right]大于 k</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//nums[l]>=k</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                l<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        i<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index1 <span class="token operator">==</span> index2<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        data<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        data<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        solution<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> kthLargest <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">findKthLargest</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"kthLargest = >"</span> <span class="token operator">+</span> kthLargest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="「力扣」第-5-题：最长回文子串"><a href="#「力扣」第-5-题：最长回文子串" class="headerlink" title="「力扣」第 5 题：最长回文子串"></a>「力扣」第 5 题：最长回文子串</h3><p>解法1：中心扩散法； </p><p>解法2：动态规划； </p><p>解法3：著名的马拉车算法。</p><h3 id="「力扣」第-209-题：-长度最小的子数组"><a href="#「力扣」第-209-题：-长度最小的子数组" class="headerlink" title="「力扣」第 209 题： 长度最小的子数组"></a>「力扣」第 209 题： <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">长度最小的子数组</a></h3><p>「力扣」第167 题：两数之和 II - 输入有序数组  </p><h3 id="「力扣」第-438-题：找到字符串中所有字母异位词"><a href="#「力扣」第-438-题：找到字符串中所有字母异位词" class="headerlink" title="「力扣」第 438 题：找到字符串中所有字母异位词"></a>「力扣」第 438 题：找到字符串中所有字母异位词</h3><p>使用<strong>滑动窗口</strong>解决的典型问题。</p><h3 id="「力扣」第-76-题：-最小覆盖子串（困难）"><a href="#「力扣」第-76-题：-最小覆盖子串（困难）" class="headerlink" title="「力扣」第 76 题： 最小覆盖子串（困难）"></a>「力扣」第 76 题： 最小覆盖子串（困难）</h3><h3 id="「力扣」第-630-题：课程调度问题"><a href="#「力扣」第-630-题：课程调度问题" class="headerlink" title="「力扣」第 630 题：课程调度问题"></a>「力扣」第 630 题：课程调度问题</h3><h3 id="「力扣」第-452-题：用最少数量的箭引爆气球。"><a href="#「力扣」第-452-题：用最少数量的箭引爆气球。" class="headerlink" title="「力扣」第 452 题：用最少数量的箭引爆气球。"></a>「力扣」第 452 题：用最少数量的箭引爆气球。</h3><p>关键：画图。<strong>理解按照右端点升序排序的好处。</strong></p><h3 id="「力扣」第-80-题：删除排序数组中的重复项-II"><a href="#「力扣」第-80-题：删除排序数组中的重复项-II" class="headerlink" title="「力扣」第 80 题：删除排序数组中的重复项 II"></a>「力扣」第 80 题：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii" target="_blank" rel="noopener">删除排序数组中的重复项 II</a></h3><p>这个写的比较顺，一下就通过了，但是我的解法只是击败了 35.43% 的选手。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 如果我们允许重复的元素最多出现两次呢？     *     * @param nums     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从[0,k) 这个区间里的所有元素是一个有序数组，并且重复元素最多出现两次</span>        <span class="token keyword">int</span> duplicate_time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 首先考虑极端的情况</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nums<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                duplicate_time<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>duplicate_time <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 重复次数大于等于 2 次，什么都不做</span>                    nums<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// nums[i] - nums[i - 1] > 0</span>                duplicate_time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 把数组的剩余元素赋值为 -1</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> k<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> removeDuplicates <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">removeDuplicates</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"剩余的数组元素的个数 => "</span> <span class="token operator">+</span> removeDuplicates<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="「力扣」第-75-题：颜色分类"><a href="#「力扣」第-75-题：颜色分类" class="headerlink" title="「力扣」第 75 题：颜色分类"></a>「力扣」第 75 题：<a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">颜色分类</a></h3><p>分析：三路快排，不借助额外空间就排好序，背模板。。</p><h3 id="「力扣」第-88-题：合并两个有序数组"><a href="#「力扣」第-88-题：合并两个有序数组" class="headerlink" title="「力扣」第 88 题：合并两个有序数组"></a>「力扣」第 88 题：<a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">合并两个有序数组</a></h3><p>关键：从后向前归并排序，背模板。其实就是归并排序，从后面向前面归并排序，扩展：字符串替换空格。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * @param nums1 一个排好序的数组1     * @param m     * @param nums2 一个排好序的数组2     * @param n     结果放在 nums1 中     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>m <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数组1的第1个元素</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数组2的第1个元素</span>        <span class="token comment" spellcheck="true">// 这种特殊情况要考虑进去</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">+</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 要赋值完 m+n 个元素，就要遍历 m+n 个元素</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">+</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果左边用完了，就一直拿右边的元素</span>                nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">>=</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// temp[left] >= temp[right]</span>                nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        solution<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="「力扣」第-56-题：压缩区间（区间个数变少）"><a href="#「力扣」第-56-题：压缩区间（区间个数变少）" class="headerlink" title="「力扣」第 56 题：压缩区间（区间个数变少）"></a>「力扣」第 56 题：压缩区间（区间个数变少）</h3><p>链接：<a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a>。</p><blockquote><p>给出一个区间的集合，请合并所有重叠的区间。</p><p><strong>示例 1:</strong></p><pre><code>输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</code></pre></blockquote><p>注意：对于 <code>list</code> 对象而言，<code>if l</code> 等价于 <code>if len(l) &gt; 0</code> 而不是 <code>l is not Node</code>。</p><p><img src="http://upload-images.jianshu.io/upload_images/414598-708701bf68919ed9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20190110155739620"></p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Definition for an interval.</span><span class="token keyword">class</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> e<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>start <span class="token operator">=</span> s        self<span class="token punctuation">.</span>end <span class="token operator">=</span> e    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'['</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">']'</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> intervals<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type intervals: List[Interval]        :rtype: List[Interval]        """</span>        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 按照开始端点升序排序</span>        sorted_intervals <span class="token operator">=</span> sorted<span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>start<span class="token punctuation">)</span>        <span class="token keyword">for</span> intv <span class="token keyword">in</span> sorted_intervals<span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">and</span> result<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>end <span class="token operator">>=</span> intv<span class="token punctuation">.</span>start<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 说明当前遍历到的区间和结果集中有交集</span>                result<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>end <span class="token operator">=</span> max<span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">,</span> intv<span class="token punctuation">.</span>end<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>intv<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># [[1, 3], [2, 6], [8, 10], [15, 18]]</span>    i1 <span class="token operator">=</span> Interval<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>    i2 <span class="token operator">=</span> Interval<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>    i3 <span class="token operator">=</span> Interval<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>    i4 <span class="token operator">=</span> Interval<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>    intervals <span class="token operator">=</span> <span class="token punctuation">[</span>i1<span class="token punctuation">,</span> i2<span class="token punctuation">,</span> i3<span class="token punctuation">,</span> i4<span class="token punctuation">]</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> solution<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>intervals<span class="token punctuation">)</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> result<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="「力扣」第-57-题：插入一个区间（区间个数不变）"><a href="#「力扣」第-57-题：插入一个区间（区间个数不变）" class="headerlink" title="「力扣」第 57 题：插入一个区间（区间个数不变）"></a>「力扣」第 57 题：插入一个区间（区间个数不变）</h3><p>链接：<a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">57. 插入区间</a>。</p><blockquote><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p><strong>示例 1:</strong></p><pre><code>输入: intervals = [[1,3],[6,9]], newInterval = [2,5]输出: [[1,5],[6,9]]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出: [[1,2],[3,10],[12,16]]解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</code></pre></blockquote><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Interval</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> start<span class="token punctuation">;</span>    <span class="token keyword">int</span> end<span class="token punctuation">;</span>    <span class="token function">Interval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Interval</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        start <span class="token operator">=</span> s<span class="token punctuation">;</span>        end <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// http://zxi.mytechroad.com/blog/geometry/leetcode-57-insert-interval/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> <span class="token function">insert</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> intervals<span class="token punctuation">,</span> Interval newInterval<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> intervals<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// intervals.sort((Interval a, Interval b) -> a.start - b.start);</span>        intervals<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>Comparator<span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Interval i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> i<span class="token punctuation">.</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Stack<span class="token operator">&lt;</span>Interval<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Interval peekInterval <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Interval curInterval <span class="token operator">=</span> intervals<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>peekInterval<span class="token punctuation">.</span>end <span class="token operator">&lt;</span> curInterval<span class="token punctuation">.</span>start<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// [1,3] [4,6] 这种情况，无论如何也合并不了的</span>                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// [1,3][3,5]</span>                <span class="token comment" spellcheck="true">// [1,3][2,6]</span>                <span class="token comment" spellcheck="true">// 这两种情况就需要合并</span>                peekInterval<span class="token punctuation">.</span>end <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>curInterval<span class="token punctuation">.</span>end<span class="token punctuation">,</span> peekInterval<span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> stack<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span>        Interval interval1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Interval interval2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Interval interval3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Interval interval4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Interval interval5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> intervals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interval1<span class="token punctuation">)</span><span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interval2<span class="token punctuation">)</span><span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interval3<span class="token punctuation">)</span><span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interval4<span class="token punctuation">)</span><span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interval5<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Interval newInterval <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> list <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> newInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Interval interval <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"["</span> <span class="token operator">+</span> interval<span class="token punctuation">.</span>start <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> interval<span class="token punctuation">.</span>end <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> <span class="token function">insert</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> intervals<span class="token punctuation">,</span> Interval newInterval<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newInterval <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> intervals<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 之前的加起来</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> intervals<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>end <span class="token operator">&lt;</span> newInterval<span class="token punctuation">.</span>start<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//</span>        <span class="token comment" spellcheck="true">// intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span>        <span class="token comment" spellcheck="true">// 此时 intervals.get(i).end >= newInterval.start</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> intervals<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>start <span class="token operator">&lt;=</span> newInterval<span class="token punctuation">.</span>end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            newInterval<span class="token punctuation">.</span>start <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">.</span>start<span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>            newInterval<span class="token punctuation">.</span>end <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">.</span>end<span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把剩下的加掉</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span>        Interval interval1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Interval interval2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Interval interval3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Interval interval4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Interval interval5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> intervals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interval1<span class="token punctuation">)</span><span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interval2<span class="token punctuation">)</span><span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interval3<span class="token punctuation">)</span><span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interval4<span class="token punctuation">)</span><span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>interval5<span class="token punctuation">)</span><span class="token punctuation">;</span>        Solution2 solution2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Interval newInterval <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interval</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Interval<span class="token operator">></span> list <span class="token operator">=</span> solution2<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> newInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Interval interval <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"["</span> <span class="token operator">+</span> interval<span class="token punctuation">.</span>start <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> interval<span class="token punctuation">.</span>end <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="「力扣」第-836-题：矩形重叠"><a href="#「力扣」第-836-题：矩形重叠" class="headerlink" title="「力扣」第 836 题：矩形重叠"></a>「力扣」第 836 题：矩形重叠</h3><p>要求：矩形以列表 <code>[x1, y1, x2, y2]</code> 的形式表示，其中 <code>(x1, y1)</code> 为左下角的坐标，<code>(x2, y2)</code> 是右上角的坐标。</p><p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p><p>给出两个矩形，判断它们是否重叠并返回结果。</p><p>分析：</p><p>不是这种坐标系：</p><pre><code>（0,0）（0,1）（0,2）（0,3）（1,0）（1,1）（1,2）（1,3）（2,0）（2,1）（2,2）（2,3）（3,0）（3,1）（3,2）（3,3）</code></pre><p>而是直角坐标系</p><pre><code>（3,0）（3,1）（3,2）（3,3）（2,0）（2,1）（2,2）（2,3）（1,0）（1,1）（1,2）（1,3）（0,0）（0,1）（0,2）（0,3）</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/414598-7e119ec656bb6f8e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image-20190111002624407"></p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 3：数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 704 题：二分查找（简单）</title>
      <link href="/leetcode-algo/2017/05/28/leetcode-algo/0704-binary-search/"/>
      <url>/leetcode-algo/2017/05/28/leetcode-algo/0704-binary-search/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-704-题：二分查找（简单）"><a href="#「力扣」第-704-题：二分查找（简单）" class="headerlink" title="「力扣」第 704 题：二分查找（简单）"></a>「力扣」第 704 题：二分查找（简单）</h2><ul><li><a href="https://leetcode-cn.com/problems/binary-search" target="_blank" rel="noopener">链接</a></li></ul><blockquote><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1：</p><pre><code>输入: nums = [-1, 0, 3, 5, 9, 12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><p>示例 2：</p><pre><code>输入: nums = [-1, 0, 3, 5, 9, 12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1</code></pre><p>提示：</p><p>1、你可以假设 <code>nums</code> 中的所有元素是不重复的。<br>2、<code>n</code> 将在 <code>[1, 10000]</code> 之间。<br>3、<code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code> 之间。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据看到的中间元素的数值，想清楚下一次搜索的区间是什么，进而设置 <code>left</code> 或者 <code>right</code> 的值。</p><h3 id="方法一：在循环的过程中判断目标元素是否存在"><a href="#方法一：在循环的过程中判断目标元素是否存在" class="headerlink" title="方法一：在循环的过程中判断目标元素是否存在"></a>方法一：在循环的过程中判断目标元素是否存在</h3><p>这个版本的二分查找是教科书里经常介绍的写法。</p><ul><li>在循环中做判断，每一轮通过目标元素与中间元素的大小将搜索区间分为 3 个部分；</li><li>有非递归写法和递归写法。</li><li>优点：语义非常清晰，不容易出错；</li></ul><p><strong>参考代码 1</strong>：</p><p>Java 代码：（循环写法）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 在 [left, right] 区间里查找 target</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间：[left, mid - 1]</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 此时：nums[mid] &lt; target</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间：[mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 走到这里，就可以判定输入数组里不存在目标元素，返回 -1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：（递归写法）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先处理递归到底的情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 不能形成区间，返回 -1 表示没有找到</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 找到了，就将目标元素的索引返回</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 既然是有序数组，目标元素的值比中间元素还要小，就应该在中间元素的左边去找</span>            <span class="token keyword">return</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> target<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 既然是有序数组，目标元素的值比中间元素还要大，就应该在中间元素的右边去找</span>            <span class="token keyword">return</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> target<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(\log N)$，这里 $N$ 是数组的元素个数，每次排除当前候选区间一半以上的元素，因此是对数级别的时间复杂度。</li><li>空间复杂度：$O(1)$，只使用了常数个的临时变量。</li></ul><h3 id="方法二：在循环结束以后判断目标元素是否存在"><a href="#方法二：在循环结束以后判断目标元素是否存在" class="headerlink" title="方法二：在循环结束以后判断目标元素是否存在"></a>方法二：在循环结束以后判断目标元素是否存在</h3><p>特点：在循环结束以后判断目标元素是否存在。在循环中，分支只有两个判断更少。</p><p>缺点：如果这个模板写法掌握得不好，容易出错。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间是：[mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 此时 nums[mid] >= target，</span>                <span class="token comment" spellcheck="true">// mid 的右边一定不存在 target，下一轮搜索区间是：[left, mid]</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 不要忘了单独做判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 注意：根据分支逻辑，需要在取中间数的时候，向上取整</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间是：[left, mid - 1]</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 此时 nums[mid] &lt;= target</span>                <span class="token comment" spellcheck="true">// mid 的左边一定不等于目标元素</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间是：[mid, right]</span>                left <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 不要忘了单独做判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><p>看到 <code>left = mid;</code> ，一定要记得将取中间数的行为上取整，即 <code>int mid = (left + right + 1) &gt;&gt;&gt; 1;</code>。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 658 题：找到 K 个最接近的元素</title>
      <link href="/leetcode-algo/2017/05/27/leetcode-algo/0658-find-k-closest-elements/"/>
      <url>/leetcode-algo/2017/05/27/leetcode-algo/0658-find-k-closest-elements/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-658-题：找到-K-个最接近的元素"><a href="#「力扣」第-658-题：找到-K-个最接近的元素" class="headerlink" title="「力扣」第 658 题：找到 K 个最接近的元素"></a>「力扣」第 658 题：找到 K 个最接近的元素</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">排除法（双指针） + 二分法（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素</a>。</p><blockquote><p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。</p><p>示例 1:</p><p>输入: [1,2,3,4,5], k=4, x=3<br>输出: [1,2,3,4]</p><p>示例 2:</p><p>输入: [1,2,3,4,5], k=4, x=-1<br>输出: [1,2,3,4]</p><p>说明:</p><p>k 的值为正数，且总是小于给定排序数组的长度。<br>数组不为空，且长度不超过 104<br>数组里的每个元素与 x 的绝对值不超过 104</p><p>更新(2017/9/19):<br>这个参数 arr 已经被改变为一个整数数组（而不是整数列表）。 请重新加载代码定义以获取最新更改。</p></blockquote><h2 id="排除法（双指针）-二分法（Python-代码、Java-代码）"><a href="#排除法（双指针）-二分法（Python-代码、Java-代码）" class="headerlink" title="排除法（双指针） + 二分法（Python 代码、Java 代码）"></a>排除法（双指针） + 二分法（Python 代码、Java 代码）</h2><p>做这一类题目的思路往往来自于对具体例子的研究，多举几个例子，在草稿纸上写写画画，也有助于我们对边界问题的讨论。</p><p>以下介绍的两种方法，排除法比较容易想到，而<strong>二分法基于排除法的思想</strong>，希望读者能够认真体会，代码虽然简单，但是要做一些分类讨论才能解释得清楚。</p><h3 id="方法一：排除法（双指针）"><a href="#方法一：排除法（双指针）" class="headerlink" title="方法一：排除法（双指针）"></a>方法一：排除法（双指针）</h3><p>以 <code>arr = [1, 2, 3, 4, 5, 6, 7]</code> , <code>x = 5</code>, <code>k = 3</code> 为例。 </p><p><strong>思路分析</strong>：</p><p>1、一个一个删，因为是有序数组，且返回的是连续升序子数组，<strong>所以每一次删除的元素一定是位于边界</strong>；</p><p>2、一共 $7$ 个元素，要保留 $3$ 个元素，因此要删除 $4$ 个元素；</p><p>3、因为要删除的元素都位于边界，于是可以使用<strong>双指针</strong>对撞的方式确定保留区间，即“最优区间”。</p><p>（温馨提示：下面的幻灯片中，有几页上有较多的文字，可能需要您停留一下，可以点击右下角的后退 “|◀” 或者前进 “▶|” 按钮控制幻灯片的播放。）</p><p><img src="https://pic.leetcode-cn.com/7cac52f799ba654e9483f47cd17533706a380dbc15fbb6dbc93a83bce11c45db-658-1.png" alt="658-1.png">),<img src="https://pic.leetcode-cn.com/ab9c789d3c7fc18cdb1dd7d383c3fa984033f4420412ffe91d747cdfe3623994-658-2.png" alt="658-2.png">),<img src="https://pic.leetcode-cn.com/0ae58bb7d22e120a900c8eb7a5735ef5e777373885d17f8f90fe0a172579716a-658-3.png" alt="658-3.png">),<img src="https://pic.leetcode-cn.com/3b003257d123fe2e944f0f06f94d88d1b35cc0f071748dc5ca2f77362c69621e-658-4.png" alt="658-4.png">),<img src="https://pic.leetcode-cn.com/9b971313fa81e97893a9321769478375dac74fa92d8cdc75563386949f18731d-658-5.png" alt="658-5.png"></p><p><strong>参考代码</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> removeNums <span class="token operator">=</span> size <span class="token operator">-</span> k<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>removeNums <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">-</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            removeNums<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> left <span class="token operator">+</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">findClosestElements</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> k<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findClosestElements</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 排除法（双指针）</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 我们要排除掉 size - k 这么多元素</span>        remove_nums <span class="token operator">=</span> size <span class="token operator">-</span> k        <span class="token keyword">while</span> remove_nums<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 调试语句</span>            <span class="token comment" spellcheck="true"># print(left, right, k)</span>            <span class="token comment" spellcheck="true"># 注意：这里等于号的含义，题目中说，距离相等的时候取小的</span>            <span class="token comment" spellcheck="true"># 所以，相等的时候，尽量缩小右边界</span>            <span class="token keyword">if</span> x <span class="token operator">-</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">-</span> x<span class="token punctuation">:</span>                right <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            remove_nums <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">:</span>left <span class="token operator">+</span> k<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，这里 $N$ 是数组的长度。</li><li>空间复杂度：$O(1)$，只使用了常数个额外的辅助空间。</li></ul><hr><p>题目中说有序数组，又易知：  </p><p>1、题目要求返回的是区间，并且是连续区间；  </p><p>2、区间长度是固定的，并且 <code>k</code> 的值为正数，且总是小于给定排序数组的长度，即 <code>k</code> 的值“不违规”；  </p><p>因此，只要我们找到了左边界的索引，从左边界开始数 <code>k</code> 个数，返回就好了。我们把这件事情定义为“寻找最优区间”，“寻找最优区间”等价于“寻找最优区间的左边界”。因此本题使用二分查找法在有序数组中<strong>定位含有 <code>k</code> 个元素的连续子区间的左边界</strong>，即使用二分法找“最优区间的左边界”。</p><h3 id="方法二：二分查找最优区间的左边界"><a href="#方法二：二分查找最优区间的左边界" class="headerlink" title="方法二：二分查找最优区间的左边界"></a>方法二：二分查找最优区间的左边界</h3><p>由排除法，我们知道：</p><p><strong>“排除法”的结论</strong>：（这个结论对于这道问题来说非常重要，可以说是解题的关键）</p><blockquote><p>如果 <code>x</code> 的值就在长度为 size 区间内（不一定相等），要得到 size - 1 个符合题意的最接近的元素，此时看左右边界：</p><p>1、如果左边界距离 <code>x</code> 较近，删除右边界；<br>2、如果右边界距离 <code>x</code> 较近，删除左边界；<br>3、如果左、右边界距离 <code>x</code> 的长度相等，删除右边界。</p></blockquote><p><strong>讨论“最优区间的左边界”的取值范围</strong>：</p><p>首先我们讨论左区间的取值范围，使用具体的例子，就很很清楚地找到规律：  </p><p>1、假设一共有 5 个数，<code>[0,1,2,3,4]</code>，找 3 个数，左边界最多到 2；  </p><p>2、假设一共有 8 个数，<code>[0,1,2,3,4,5,6,7]</code>，找 5 个数，左边界最多到 3。</p><p>因此，“最优区间的左边界”的索引的搜索区间为 <code>[0, size - k]</code>，注意，这个区间的左右都是闭区间，都能取到。</p><p>定位左区间的索引，有一点技巧性，但并不难理解。由排除法的结论，我们先从 <code>[0, size - k]</code> 这个区间的任意一个位置（用二分法就是当前候选区间的中位数）开始，<strong>定位一个长度为 <code>(k + 1)</code> 的区间</strong>，根据这个区间是否包含 <code>x</code> 开展讨论。</p><p>1、如果区间包含 <code>x</code>，我们尝试删除 1 个元素，好让区间发生移动，便于定位“最优区间的左边界”的索引；<br>2、如果区间不包含 <code>x</code>，就更简单了，我们尝试把区间进行移动，以试图包含 <code>x</code>，但也有可能区间移动不了（极端情况下）。</p><p>以下的讨论，对于记号 <code>left</code>、<code>right</code> 和 <code>mid</code> 说明如下：</p><p>1、<code>left</code>、<code>right</code> 是候选区间的左右边界的索引，根据上面的分析，初始时，<code>left = 0</code>，<code>right = size - k</code>；<br>2、而 <code>mid</code> 是候选区间的中位数的索引，它的取值可能是</p><pre><code>mid = left + (right - left) // 2</code></pre><p>也可能是</p><pre><code>mid = left + (right - left + 1) // 2</code></pre><p>之所以我们选择 <code>mid = left + (right - left) // 2</code> ，请参考我在「力扣」第 35 题：搜索插入位置的题解<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">《特别好用的二分查找法模板（Python 代码、Java 代码）》</a>中的叙述。</p><blockquote><p>后面的文字可能会非常绕，在这里建议读者通读，前后来回看，不太清楚的地方先跳过，且不一定全看我的叙述，看明白一小段，在草稿纸上写写画画一点，卡壳了再看我的叙述，这样就不会太晕。</p></blockquote><p>我们先从最简单的情况开始讨论：</p><p>1、如果区间不包含 <code>x</code>：</p><p>（1） 区间的右端点在 <code>x</code> 的左边，即 <code>x</code> 比 <code>arr</code> 中最大的元素还要大，<strong>因为要去掉 1 个元素，显然去掉左端点</strong>，因此“最优区间的左边界”的索引至少是 <code>mid + 1</code>，即 <code>left = mid + 1</code>，<strong>因为区间不可能再往左边走了</strong>，如图；</p><p><img src="https://pic.leetcode-cn.com/002e341fa376ece19580704839a5a8bad78b50c6c93a148a928b840ea8cd0272-image.png" alt="image.png"></p><p>说明：极端情况是此时中位数位于索引 <code>size - k</code>，区间不能右移。</p><p>（2）区间的左端点在 <code>x</code> 的左边，即 <code>x</code> 比 <code>arr</code> 中最小的元素还要小，当前的区间左端点的索引至多是 <code>mid</code>，此时 <code>right = mid</code>，<strong>因为区间不可能再往右偏了</strong>，如图；</p><p><img src="https://pic.leetcode-cn.com/4fe43ad19083c07fb72771892f36cb1d5b0dba01533e522f075ef0a153a1267a-image.png" alt="image.png"></p><p>说明：极端情况是此时 <code>mid</code> 位于索引 <code>0</code>，区间不能左移。</p><p>2、如果区间包含 <code>x</code>，我们尝试删掉一个元素，以便让区间发生移动，缩小搜索范围：</p><p>易知，我们要比较长度为 <code>k + 1</code> 的区间的左右端点的数值与 <code>x</code> 的距离。此时这个区间的左边界的索引是 <code>mid</code>，右边界的索引是 <code>mid + k</code>。根据“排除法”的结论，分类讨论如下：</p><p>（1）如果右边界距离 <code>x</code> 较近，左边界收缩，可以肯定的是“最优区间的左边界”的索引 <code>left</code> 至少是 <code>mid + 1</code>，即 <code>left = mid + 1</code>，如图；</p><p><img src="https://pic.leetcode-cn.com/0a8fe24c6abcad7ae2d774506b4b0abccd5eb95b953be9c367f49c633fed9343-image.png" alt="image.png"></p><p>说明：“右边界距离 <code>x</code> 较近”同样适用于 1、（1）情况，因此它们二者可以合并；</p><p>（2）如果左边界距离 <code>x</code> 较近，右边界收缩，此时区间不移动，注意：此时有可能收缩以后的区间就是待求的区间，也有可能整个区间向左移动，这件事情叫做，<code>right = mid</code> 不能排除 <code>mid</code>，如图；</p><p><img src="https://pic.leetcode-cn.com/6dfea16f88fd03e10c95c2e2d216711ed1489a58a173ac4cd1d2e1a9de583de0-image.png" alt="image.png"></p><p>说明1：这一点比较难想，但实际上也可以不想，根据 2、（1）的结论，左区间收缩的反面即是右区间不收缩，因此，这一分支的逻辑一定是 <code>right = mid</code>。</p><blockquote><p>“实际上也可以不想”的具体原因，同样参考我在「力扣」第 35 题：搜索插入位置的题解<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">《特别好用的二分查找法模板（Python 代码、Java 代码）》</a>中的叙述，我专门把如何写好二分法，使用二分法模板好用的地方、使用它的技巧和注意事项整理在这篇题解中，希望能对大家有所帮助。</p></blockquote><p>说明2：“左边界距离 <code>x</code> 较近”同样适用于 1、（2）情况，因此它们二者可以合并。</p><p>（3）如果左、右边界距离 <code>x</code> 的长度相等，删除右边界，结论同 2、（2），也有 <code>right = mid</code>，可以合并到 2、（2）。</p><p>以上看晕的朋友们，建议你在草稿纸上写写画画，思路就非常清晰了，并且写出的代码也很简洁。这个代码也不是我原创的，在网上搜了一下，刚开始的时候，一直不能理解下面这段代码的意思。</p><pre><code>if x - arr[mid] &gt; arr[mid + k] - x:    left = mid + 1else:    right = mid</code></pre><p>写个草稿就清楚多了，原来是并不困难，只是稍显复杂。</p><p><img src="https://pic.leetcode-cn.com/1505e8c19730133b6bc9c2b6088fd9f0ff376f9539dcf0932214b77415e542b6-image.png" alt="image.png"></p><p><img src="https://pic.leetcode-cn.com/1ff7a2c278f3624bae64e29bc4e3a7aeb2f1fb3835baaeb444f5d4c5df1e4c7d-image.png" alt="image.png"></p><p><strong>参考代码</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:        size = len(arr)        left = 0        right = size - k        while left < right:            # mid = left + (right - left) // 2            mid = (left + right) >> 1            # 尝试从长度为 k + 1 的连续子区间删除一个元素            # 从而定位左区间端点的边界值            if x - arr[mid] > arr[mid + k] - x:                left = mid + 1            else:                right = mid        return arr[left:left + k]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.ArrayList;import java.util.List;public class Solution {    public List<Integer> findClosestElements(int[] arr, int k, int x) {        int size = arr.length;        int left = 0;        int right = size - k;        while (left < right) {            // int mid = left + (right - left) / 2;            int mid = (left + right) >>> 1;            // 尝试从长度为 k + 1 的连续子区间删除一个元素            // 从而定位左区间端点的边界值            if (x - arr[mid] > arr[mid + k] - x) {                left = mid + 1;            } else {                right = mid;            }        }        List<Integer> res = new ArrayList<>();        for (int i = left; i < left + k; i++) {            res.add(arr[i]);        }        return res;    }    public static void main(String[] args) {        int[] arr = {0, 0, 1, 2, 3, 3, 4, 7, 7, 8};        int k = 3;        int x = 5;        Solution2 solution = new Solution2();        List<Integer> res = solution.findClosestElements(arr, k, x);        System.out.println(res);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(\log N)$，这里 $N$ 是数组的长度，使用二分法的时间复杂度是对数级别的。</li><li>空间复杂度：$O(1)$，只使用了常数个额外的辅助空间。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 611 题：有效三角形的个数</title>
      <link href="/leetcode-algo/2017/05/26/leetcode-algo/0611-valid-triangle-number/"/>
      <url>/leetcode-algo/2017/05/26/leetcode-algo/0611-valid-triangle-number/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-611-题：有效三角形的个数"><a href="#「力扣」第-611-题：有效三角形的个数" class="headerlink" title="「力扣」第 611 题：有效三角形的个数"></a>「力扣」第 611 题：有效三角形的个数</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/valid-triangle-number/solution/er-fen-cha-zhao-python-dai-ma-java-dai-ma-by-liwei/" target="_blank" rel="noopener">二分查找 （Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/valid-triangle-number/" target="_blank" rel="noopener">611. 有效三角形的个数</a>。</p><blockquote><p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p><p>示例 1:</p><p>输入: [2,2,3,4]<br>输出: 3<br>解释:<br>有效的组合是:<br>2,3,4 (使用第一个 2)<br>2,3,4 (使用第二个 2)<br>2,2,3<br>注意:</p><p>数组长度不超过1000。<br>数组里整数的范围为 [0, 1000]。</p></blockquote><h2 id="二分查找-（Python-代码、Java-代码）"><a href="#二分查找-（Python-代码、Java-代码）" class="headerlink" title="二分查找 （Python 代码、Java 代码）"></a>二分查找 （Python 代码、Java 代码）</h2><p><strong>思路分析</strong>：</p><p>这道题是朋友邀请我做的，我的第一感觉是：“先排序，然后根据两边之和大于第三边，两边之差小于第三边来做”，当然我也参考了评论区和题解区的代码，下面是我的思考过程。</p><p>一、考虑三条边能够组成三角形的充分必要条件</p><p>首先我们解决三条边构成三角形这件事情，我们脑子里会浮现出这样一句话：</p><blockquote><p>三角形的任意两边之和大于第三边，三角形的任意两边之差小于第三边。</p></blockquote><p>这是中学的数学知识告诉我们的，烦就烦在“任意”，三条边的任意组合我们都要看过去吗？不是的。</p><p>先看前半句话，“三角形的任意两边之和大于第三边”，事实上，只要<strong>最短的两条边大于第三边就好，剩下的就不用判断了</strong>，我的理由如下：既然边长是实数，不妨将这些边排个序。</p><p>假设有索引 <code>i &lt; j &lt; k</code> 使得 <code>nums[i] &lt;= nums[j] &lt;= nums[k]</code> 成立，不妨称它们为“短”、“中”、“长”，显然有：</p><ul><li>在任何情况下，“短 + 长 &gt; 中”成立。</li><li>在任何情况下，“中 + 长 &gt; 短”成立。</li></ul><p>再加上如果 <code>nums[i] + nums[j] &gt; nums[k]</code> 成立，即“短 + 中 &gt; 长”成立，那么“任意两边之和大于第三边”就一定成立。</p><p>另一方面，如果 <code>nums[i] + nums[j] &gt; nums[k]</code> 成立，即“短 + 中 &gt; 长”成立，它等价于：</p><ul><li>“长 - 短 &lt; 中”成立；</li><li>“长 - 中 &lt; 短”成立；</li></ul><p>而在任何情况下，“中 - 短 &lt; 长”都成立，因此“三角形的任意两边之差小于第三边”也成立。</p><p>根据以上分析，我们得到：三条边能够成三角形的充分必要条件是：</p><blockquote><p><strong>较短的两边之和大于（不包括等于）第三边（最长边）。</strong></p></blockquote><p>二、思考如何编码？</p><p>不知道你会不会想起<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">「力扣」第 15 题：三数之和</a>，可以借鉴解这道题的“双指针”的办法来完成，但是是在有序数组中做，我们看一看二分查找有没有用武之地，写好一个二分查找不在话下，于是有以下两个方向。</p><p>1、先固定 <code>i</code>，然后固定 <code>j</code>，在剩下的区间里，找第 1 个不满足构成三角形的第三条边的索引：</p><p>（1）因为以后的边越来越长，这条边以及以后的边都不能和前面的两条边构成三角形；</p><p>（2）因为是第 1 个不满足构成三角形的第三条边，那这个索引和 <code>j</code> 之间的所有数都满足构成三角形，得到“一票解”（一系列解的意思），注意边界条件（边界条件一般在草稿纸上举例就很清楚了）；</p><p>“找第 1 个不满足构成三角形的第三条边的索引”，在有序数组中，我们当然使用二分法，如图所示。</p><p><img src="https://pic.leetcode-cn.com/b01aad172f98c03437c2699fa9cd54521941446667fe828544022dc4db1b5ba7-611-1.png" alt="611-1.png"></p><p>2、先固定 <code>k</code>，然后固定 <code>j</code>，在之前的区间里，找第 1 个满足构成三角形的第一条边的索引：</p><p>（1）因为之前的边是越来越短的，这条边之前边都不能和索引为 <code>j</code> 和 <code>k</code> 的两条边构成三角形；</p><p>（2）因为以后的边越来越长，这条边和 <code>j</code>  之间的所有数都满足构成三角形，得到“一票解”（一系列解的意思），注意边界条件（边界条件一般在草稿纸上举例就很清楚了）。</p><p>“找第 1 个满足构成三角形的第一条边的索引”，在有序数组中，我们当然还使用二分法，如图所示。</p><p><img src="https://pic.leetcode-cn.com/b326cb1d314287fe7f85da72a42782a32e3224341b9b6ecc2269ede555816cba-611-2.png" alt="611-2.png"></p><p>之所以我上面说“写好一个二分查找不在话下”，那是因为我做了很多“二分查找”的问题，我专门把我使用得最多的二分查找法模板，它好用的地方、使用它的技巧和注意事项整理在了「力扣」第 35 题：搜索插入位置的题解<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">《特别好用的二分查找法模板（Python 代码、Java 代码）》</a>，希望能对大家有所帮助。</p><h3 id="方法：二分查找"><a href="#方法：二分查找" class="headerlink" title="方法：二分查找"></a>方法：二分查找</h3><p><strong>参考代码 1</strong>： 先固定 <code>i</code>，再固定 <code>j</code>，然后找 <code>k</code> 的上界。</p><p>编码的时候写的草稿如下：</p><p><img src="https://pic.leetcode-cn.com/58d7e9c7a5751f77cc9d29a454f8468551450efc6c357c5f5bf1ec2428629807-image.png" alt="image.png"></p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def triangleNumber(self, nums: List[int]) -> int:        # 索引数组：[0, 1, 2, 3, 4]，size = 5        # i 最多到倒数第 2 个索引        size = len(nums)        # 思路 1：从前到后，先固定 i ，再固定 j ，最后确定 k 的范围        # 首先不要忘记排序        nums.sort()        res = 0        # 注意边界，看上面那个索引数组知道 i 最多取到 2        for i in range(size - 2):            # 要给 k 留一个位置，故 size - 1 是上限（取不到）            for j in range(i + 1, size - 1):                # 在区间 [j + 1, size - 1] 中找第 1 个不能构成三角形的数                # k 与 j 之间的数的个数就是一票解                # 等价于，在子区间 [j + 1, size - 1] 里找第 1 个大于等于 nums[i] + nums[j] 的数                k = self.__find_first_cannot_triangle(nums, j + 1, size - 1, nums[i] + nums[j])                if k == -1:                    # 说明子区间 [j + 1, size - 1] 全部的数都可以构成三角形                    # 其中的数的个数为 size - 1 - (j + 1) + 1                    res += (size - j - 1)                else:                    # 说明子区间 [j + 1, k) 全部的数可以构成三角形，注意：这里 k 取不到                    # 其中的数的个数为 k - (j + 1)                    res += (k - j - 1)        return res    def __find_first_cannot_triangle(self, nums, left, right, target):        # 在 nums 的子区间 [left, right] 里找第 1 个大于等于 target 的元素的索引        # 如果不存在，返回 -1        while left < right:            mid = left + (right - left) // 2            if nums[mid] < target:                left = mid + 1            else:                right = mid        # 后处理，因为很有可能找不到大于等于 target 的元素        if nums[left] < target:            return -1        return left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Arrays;public class Solution {    public int triangleNumber(int[] nums) {        // 索引数组：[0, 1, 2, 3, 4]，size = 5        // i 最多到倒数第 2 个索引        int len = nums.length;        // 思路 1：从前到后，先固定 i ，再固定 j ，最后确定 k 的范围        // 首先不要忘记排序        Arrays.sort(nums);        int res = 0;        // 注意边界，看上面那个索引数组知道 i 最多取到 2        for (int i = 0; i < len - 2; i++) {            // 要给 k 留一个位置，故 size - 1 是上限（取不到）            for (int j = i + 1; j < len - 1; j++) {                // 在区间 [j + 1, size - 1] 中找第 1 个不能构成三角形的数                // k 与 j 之间的数的个数就是一票解                // 等价于，在子区间 [j + 1, size - 1] 里找第 1 个大于等于 nums[i] + nums[j] 的数                int k = findFirstCanNotTriangle(nums, j + 1, len - 1, nums[i] + nums[j]);                if (k == -1) {                    // 说明子区间 [j + 1, len - 1] 全部的数都可以构成三角形                    // 其中的数的个数为 len - 1 - (j + 1) + 1                    res += (len - j - 1);                } else {                    // 说明子区间 [j + 1, k) 全部的数可以构成三角形，注意：这里 k 取不到                    // 其中的数的个数为 k - (j + 1)                    res += (k - j - 1);                }            }        }        return res;    }    private int findFirstCanNotTriangle(int[] nums, int left, int right, int target) {        // 在 nums 的子区间 [left, right] 里找第 1 个大于等于 target 的元素的索引        // 如果不存在，返回 -1        while (left < right) {            int mid = left + (right - left) / 2;            if (nums[mid] < target) {                left = mid + 1;            } else {                right = mid;            }        }        // 后处理，因为很有可能找不到大于等于 target 的元素        if (nums[left] < target) {            return -1;        }        return left;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写了从前向后的代码，从后向前的代码就好写了，不过还是要注意一些细节问题，一旦发现出错，不要着急，在编码过程中打印一些输出语句，可以帮助你调试代码。</p><p><strong>参考代码 2</strong>：先固定 <code>k</code>，再固定 <code>j</code>，然后找 <code>i</code> 的下界。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def triangleNumber(self, nums: List[int]) -> int:        # 索引数组：[0, 1, 2, 3, 4]，size = 5        size = len(nums)        # 思路 2：从后到前，先固定 k ，再固定 j ，最后确定 i 的范围        # 首先不要忘记排序        nums.sort()        res = 0        # 注意边界，看上面那个索引数组知道 k 最小取到 2，不能再小了        for k in range(size - 1, 1, -1):            # 要给 i 留一个位置，故 1 是下限（取不到）            # print('k=', k)            for j in range(k - 1, 0, -1):                # 在区间 [0, j - 1] 中找第 1 个能构成三角形的数                # i 与 j 之间的数的个数就是一票解                # 等价于，在子区间 [0, j - 1] 里找第 1 个大于（不能等于） nums[k] - nums[j] 的数                i = self.__find_first_can_triangle(nums, 0, j - 1, nums[k] - nums[j])                # print(i, j, k)                if i == -1:                    # 说明子区间 [0, j - 1] 全部的数都不能构成三角形                    # 其中的数的个数为 0，                    # 为了语义清晰，我还是写一下 + 0                    res += 0                else:                    # 说明子区间 [i, j - 1] 全部的数可以构成三角形，注意：这里 k 取不到                    # 其中的数的个数为 j - 1 - i + 1                    res += (j - i)                # print('res=', res)        return res    def __find_first_can_triangle(self, nums, left, right, target):        # 在 nums 的子区间 [left, right] 里找第 1 个大于（不能等于） target 的元素的索引        # 如果不存在，返回 -1        while left < right:            mid = left + (right - left) // 2            if nums[mid] <= target:                left = mid + 1            else:                right = mid        # 后处理，因为很有可能找不到大于 target 的元素        if nums[left] <= target:            return -1        return left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">import java.util.Arrays;public class Solution {    public int triangleNumber(int[] nums) {        // 索引数组：[0, 1, 2, 3, 4]，size = 5        // i 最多到倒数第 2 个索引        int len = nums.length;        // 思路 2：从后到前，先固定 k ，再固定 j ，最后确定 i 的范围        // 首先不要忘记排序        Arrays.sort(nums);        int res = 0;        // 注意边界，看上面那个索引数组知道 k 最小取到 2，不能再小了        for (int k = len - 1; k > 1; k--) {            // 要给 k 留一个位置，故 size - 1 是上限（取不到）            for (int j = k - 1; j > 0; j--) {                // 在区间 [0, j - 1] 中找第 1 个能构成三角形的数                // i 与 j 之间的数的个数就是一票解                // 等价于，在子区间 [0, j - 1] 里找第 1 个大于（不能等于） nums[k] - nums[j] 的数                int i = findFirstCanTriangle(nums, 0, j - 1, nums[k] - nums[j]);                if (i == -1) {                    // 说明子区间 [0, j - 1] 全部的数都不能构成三角形                    // 其中的数的个数为 0，                    // 为了语义清晰，我还是写一下 + 0                    res += 0;                } else {                    // 说明子区间 [i, j - 1] 全部的数可以构成三角形，注意：这里 k 取不到                    // 其中的数的个数为 j - 1 - i + 1                    res += (j - i);                }            }        }        return res;    }    private int findFirstCanTriangle(int[] nums, int left, int right, int target) {        // 在 nums 的子区间 [left, right] 里找第 1 个大于（不能等于） target 的元素的索引        // 如果不存在，返回 -1        while (left < right) {            int mid = left + (right - left) / 2;            if (nums[mid] <= target) {                left = mid + 1;            } else {                right = mid;            }        }        // 后处理，因为很有可能找不到大于等于 target 的元素        if (nums[left] <= target) {            return -1;        }        return left;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结</strong>：两种方法写下来，个人还是推荐“从前向后”的办法，正向思维不太容易出错。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 374 题：猜数字大小</title>
      <link href="/leetcode-algo/2017/05/25/leetcode-algo/0374-guess-number-higher-or-lower/"/>
      <url>/leetcode-algo/2017/05/25/leetcode-algo/0374-guess-number-higher-or-lower/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-374-题：猜数字大小"><a href="#「力扣」第-374-题：猜数字大小" class="headerlink" title="「力扣」第 374 题：猜数字大小"></a>「力扣」第 374 题：猜数字大小</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/" target="_blank" rel="noopener">借本题说一说取中位数的写法（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a>。</p><blockquote><p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 1 到 n 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 guess(int num)，它会返回 3 个可能的结果（-1，1 或 0）：</p><p>-1 : 我的数字比较小<br> 1 : 我的数字比较大<br> 0 : 恭喜！你猜对了！<br>示例 :</p><p>输入: n = 10, pick = 6<br>输出: 6</p></blockquote><h2 id="借本题说一说取中位数的写法（Python-代码、Java-代码）"><a href="#借本题说一说取中位数的写法（Python-代码、Java-代码）" class="headerlink" title="借本题说一说取中位数的写法（Python 代码、Java 代码）"></a>借本题说一说取中位数的写法（Python 代码、Java 代码）</h2><p>以下代码是根据我在刷题过程中总结出来的最好用的二分法模板写成。我专门把这个二分法模板好用的地方、使用它的技巧和注意事项整理在了「力扣」第 35 题：搜索插入位置的题解<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">《特别好用的二分查找法模板（Python 代码、Java 代码）》</a>，希望能对大家有所帮助。</p><p><strong>参考代码</strong>：</p><ul><li>注意：以下虽然我用两种语言作答，但是它们的逻辑上还有一点点区别，那就是在取中位数的时候，答案在上面那篇题解中。</li></ul><pre class="line-numbers language-Python"><code class="language-Python">def guess(num):    passclass Solution(object):    def guessNumber(self, n):        left = 1        right = n        while left < right:            # mid = left + (right - left) // 2            mid = (left + right) >> 1            if guess(mid) == 1:                left = mid + 1            else:                right = mid        # 最后剩下的数一定是所求，无需后处理        return left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Java"><code class="language-Java">class GuessGame {    private static final int NUM = 6;    int guess(int num) {        if (num == NUM) {            return 0;        } else if (num < NUM) {            return -1;        }        return 1;    }}public class Solution extends GuessGame {    public int guessNumber(int n) {        int left = 1;        int right = n;        while (left < right) {            // int mid = left + (right - left + 1) / 2;            int mid = (left + right + 1) >>> 1;            int guessNum = guess(mid);            if (guessNum == -1) {                right = mid - 1;            } else {                left = mid;            }        }        // 最后剩下的数一定是所求，无需后处理        return left;    }    public static void main(String[] args) {        Solution solution = new Solution();        int n = 10;        int guessNumber = solution.guessNumber(n);        System.out.println(guessNumber);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>以上是本题题解，以下才是本文真正想说的，你应该已经注意到了，上面的示例代码中，<code>mid = left + (right - left) // 2</code> 和 <code>int mid = left + (right - left + 1) / 2;</code> 都被我注释掉了，不是因为它们不正确，而是因为它们不够好，下面就来具体说说。</p><p>1、最早学习二分法的时候，写中位数的索引是这样的：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python">mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、后来被告知在 <code>left</code> 和  <code>right</code> 很大的时候，<code>left + right</code> 会发生整型溢出，变成负数，这是一个 bug 得改！</p><p>于是我们写成：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python">mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后又被告知 <code>mid = left + (right - left) // 2</code> 在 <code>right</code> 很大、 <code>left</code> 是负数且很小的时候， <code>right - left</code> 也有可能超过 int 类型能表示的最大值，只不过一般情况下 <code>left</code> 和 <code>right</code> 表示的是数组索引值，<code>left</code> 是非负数，因此 <code>right - left</code> 溢出的可能性很小。</p><p>3、最后，在 Java 的 JDK 的 <code>Collections</code> 和 <code>Arrays</code> 提供的 <code>binarySearch</code> 方法里看到了，中位数是这样取的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>怎么又变成“+”了，一头雾水啊，会整型溢出吗？后来查了查资料，有可能会整型溢出的，不过结果依然正确。下面是原因：</p><blockquote><p><code>left + right</code> 在发生整型溢出以后，会变成负数，此时如果除以 2 ，<code>mid</code> 是一个负数，但是经过<strong>无符号右移</strong>，可以得到在不溢出的情况下正确的结果。</p></blockquote><p>首先解释“无符号右移”，在 Java 中，无符号右移运算符 <code>&gt;&gt;&gt;</code> 和右移运算符 <code>&gt;&gt;</code> 有区别：</p><ul><li><p>右移运算符 <code>&gt;&gt;</code> 在右移时，丢弃右边指定位数，左边补上符号位；</p></li><li><p>无符号右移运算符 <code>&gt;&gt;&gt;</code> 在右移时，丢弃右边指定位数，左边补上 $0$，也就是说，对于正数来说，二者一样，而负数通过 <code>&gt;&gt;&gt;</code> 后能变成正数。</p></li></ul><p>了解了这一点，就能够理解 Java 中用 <code>int mid = (low + high) &gt;&gt;&gt; 1;</code> 的原因了，关键不在 “+” ，而是“无符号右移”，在 Java 的 <code>Collections</code> 和 <code>Arrays</code> 提供的 <code>binarySearch</code> 方法里，<code>low</code> 和 <code>high</code> 都表示索引值，它们都是非负数，即使相加以后整型溢出，结果还是正确的，“位运算”本身就比其它运算符快，因此使用“+”和“无符号右移”是既快又好的做法。</p><p>如果你用 Java 写的话，不妨做下面的试验：</p><p>用“+”和除法，不能通过，提示也很清楚了。</p><p><img src="https://pic.leetcode-cn.com/049e64ded6739e8bd6955a1d5e3ef76acc0aac0ad12909bdd58772dd6d465240-image.png" alt="image.png"></p><p>如果你用 Python 的话，就可以过，这是因为：当 <code>left + right</code> 很大的时候，Python 就自动帮你转成 long 类型了，因此结果也不会错。 </p><p><img src="https://pic.leetcode-cn.com/46e50c5802c6b28bafe78c7b3ca88872139844177e929259ab5d0117ba61d52d-image.png" alt="image.png"></p><p>总结：</p><p>1、<code>int mid = (left + right) / 2;</code> 是初级写法，是有 bug 的；</p><p>2、<code>int mid = left + (right - left) / 2;</code> 是正确的写法，说明你考虑到了整型溢出的风险；</p><p>3、<code>int mid = (low + high) &gt;&gt;&gt; 1;</code> 首先肯定是正确的写法，其实也是一个装 ❌ 的写法，理由上面已经叙述过了。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 154 题：旋转排序数组的最小值 II（困难）</title>
      <link href="/leetcode-algo/2017/05/24/leetcode-algo/0154-find-minimum-in-rotated-sorted-array-ii/"/>
      <url>/leetcode-algo/2017/05/24/leetcode-algo/0154-find-minimum-in-rotated-sorted-array-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-154-题：旋转排序数组的最小值-II（困难）"><a href="#「力扣」第-154-题：旋转排序数组的最小值-II（困难）" class="headerlink" title="「力扣」第 154 题：旋转排序数组的最小值 II（困难）"></a>「力扣」第 154 题：旋转排序数组的最小值 II（困难）</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">二分法 + 分治法（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a>。</p><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p>示例 1：</p><p>输入: [1,3,5]<br>输出: 1<br>示例 2：</p><p>输入: [2,2,2,0,1]<br>输出: 0<br>说明：</p><p>这道题是 寻找旋转排序数组中的最小值 的延伸题目。<br>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</p></blockquote><h2 id="二分法-分治法（Python-代码、Java-代码）"><a href="#二分法-分治法（Python-代码、Java-代码）" class="headerlink" title="二分法 + 分治法（Python 代码、Java 代码）"></a>二分法 + 分治法（Python 代码、Java 代码）</h2><h3 id="方法一：二分法"><a href="#方法一：二分法" class="headerlink" title="方法一：二分法"></a>方法一：二分法</h3><p>只要是一次可以排除一半，都可以用二分法。那么如何使用二分法呢？我们很自然会想到使用边界的值和中间位置的值进行比较。</p><p><strong>注意</strong>：我这里说的是中间数，即位于中间的那个数，不是中位数，请读者注意区分。</p><p>于是可以分为以下两种情况：</p><p>1、左边界与中间数比较</p><p>我们在纸上写出几个例子：</p><p>例 1：<code>[1, 2, 3, 4, 5]</code></p><p>例 2：<code>[2, 3, 4, 5, 1]</code></p><p>以上这两个例子，中间数都比左边界大，但是旋转排序数组的最小值可能在中间数的左边（例 1），也可能在中间数的右边（例 2），因此<strong>不能使用左边界与中间数比较作为二分法的讨论依据</strong>。</p><p>接下来，看看另一种讨论依据。</p><p>2、右边界与中间数进行比较：</p><p>（1）当中间数比右边界表示的数大的时候，中间数就一定不是目标数（旋转排序数组的最小值），举个例子：</p><p>例 3：<code>[7, 8, 9, 10, 11, 12, 1, 2, 3]</code></p><p>中间数 11 比右边界 3 大，因此中间数以及中间数前面的数都不是目标数，把左边界设置中间数位置 + 1，即 <code>l = mid + 1</code>；</p><p>（2）当中间数比右边界表示的数小的时候，中间数就可能是目标数（旋转排序数组的最小值），举个例子：</p><p>例 4：<code>[7,8,1,2,3]</code></p><p>中间数 1 比右边界表示的数大的时候，说明，中间数到右边界是递增的（对于这道题是非递减），那么中间数右边的（不包括中间数）就一定不是目标数，把它们排除，因此，把右边界设置为 <code>r = mid</code>。</p><p>（3）当中间数与右边界表示的数相等的时候，看下面两个例子：</p><p>例 5：<code>[0, 1, 1, 1, 1, 1, 1]</code></p><p>例 6：<code>[1, 1, 1, 1, 0, 1, 1]</code></p><p>目标值可能在中间数的左边，也可能在中间数的右边，那么怎么办呢？很简单，此时你看到的是右边界，就把只右边界排除掉就好了。这正是因为右边界和中间数相等，你去掉了右边界，中间数还在，就让中间数在后面的循环中被发现吧。</p><p>因此，根据中间数和末尾数的大小关系，可以使用二分法找到目标值。</p><p><strong>关键</strong>：解本题的关键在于举例，考虑到不同的情况。</p><p>以下代码是根据我在刷题过程中总结出来的最好用的二分法模板写成。我专门把这个二分法模板好用的地方、使用它的技巧和注意事项整理在了「力扣 」第 35 题：搜索插入位置的题解<a href="">《特别好用的二分查找法模板（Python 代码、Java 代码）》</a>，希望能对大家有所帮助。</p><p><strong>参考代码 1</strong>：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def findMin(self, nums: List[int]) -> int:        size = len(nums)        if size == 0:            return Exception('程序出错')        left = 0        right = size - 1        while left < right:            # mid = left + (right - left) // 2            mid = (left + right) >> 1            if nums[mid] > nums[right]:                # mid 肯定不是最小值                # [7,8,9,10,11,1,2,3]                left = mid + 1            elif nums[mid] < nums[right]:                # mid 有可能是最小值                # [7,8,1,2,3]                right = mid            else:                # 都有可能，所以就把 right 排除了                # [1,1,1,1,1,0,1]                assert nums[mid] == nums[right]                right = right - 1        # 无需后处理        return nums[left]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public int findMin(int[] nums) {        int len = nums.length;        if (len == 0) {            return 0;        }        int left = 0;        int right = len - 1;        while (left < right) {            // int mid = left + (right - left) / 2;            int mid = (left + right) >>> 1;            if (nums[mid] > nums[right]) {                left = mid + 1;            } else if (nums[mid] < nums[right]) {                right = mid;            } else {                assert nums[mid] == nums[right];                right--;            }        }        return nums[left];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>代码同 LeetCode 第 153 题。</p><p>分治法将原问题划分成若干与原问题同结构且规模更小的子问题，等到这些子问题解决了以后，原问题也得到了解决。</p><p><strong>参考代码 2</strong>：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def findMin(self, nums: List[int]) -> int:        size = len(nums)        if size == 0:            raise Exception('程序出错')        if size == 1:            return nums[0]        return self.__find_min(nums, 0, size - 1)    def __find_min(self, nums, left, right):        if left == right:            return nums[left]        if left + 1 == right:            return min(nums[left], nums[right])        # mid = left + (right - left) // 2        mid = (left + right) >> 1        return min(self.__find_min(nums, left, mid), self.__find_min(nums, mid + 1, right))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public int findMin(int[] nums) {        int len = nums.length;        if (len == 0) {            throw new IllegalArgumentException("数组为空，最小值不存在");        }        return findMin(nums, 0, len - 1);    }    private int findMin(int[] nums, int left, int right) {        if (left + 1 >= right) {            return Math.min(nums[left], nums[right]);        }        if (nums[left] < nums[right]) {            return nums[left];        }        // int mid = left + (right - left) / 2;        int mid = (left + right) >>> 1;        return Math.min(findMin(nums, left, mid - 1), findMin(nums, mid, right));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 153 题：旋转排序数组的最小值（中等）</title>
      <link href="/leetcode-algo/2017/05/23/leetcode-algo/0153-find-minimum-in-rotated-sorted-array/"/>
      <url>/leetcode-algo/2017/05/23/leetcode-algo/0153-find-minimum-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<h3 id="「力扣」第-153-题：旋转排序数组的最小值（中等）"><a href="#「力扣」第-153-题：旋转排序数组的最小值（中等）" class="headerlink" title="「力扣」第 153 题：旋转排序数组的最小值（中等）"></a>「力扣」第 153 题：旋转排序数组的最小值（中等）</h3><p>题解地址：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-java-dai-ma-by-/" target="_blank" rel="noopener">二分法 + 分治法（Python 代码、Java 代码）</a>。</p><p>说明：文本首发在力扣的题解版块，更新也会在第 1 时间在上面的网站中更新，这篇文章只是上面的文章的一个快照，您可以点击上面的链接看到其他网友对本文的评论。</p><p>传送门：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a>。</p><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>你可以假设数组中不存在重复元素。</p><p>示例 1:</p><p>输入: [3,4,5,1,2]<br>输出: 1<br>示例 2:</p><p>输入: [4,5,6,7,0,1,2]<br>输出: 0</p></blockquote><h3 id="方法一：二分法"><a href="#方法一：二分法" class="headerlink" title="方法一：二分法"></a>方法一：二分法</h3><p>分类讨论的依据我已经写在了「力扣」第 154 题：寻找旋转排序数组中的最小值 II 的题解<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">《二分法 + 分治法（Python 代码、Java 代码）》</a>，第 154 题其实并不难，它解决了以后，第 153 题不在话下，请大家出门左转观看。</p><p>以下代码是根据我在刷题过程中总结出来的最好用的二分法模板写成。我专门把这个二分法模板好用的地方、使用它的技巧和注意事项整理在了「力扣」第 35 题：搜索插入位置的题解<a href="">《特别好用的二分查找法模板（Python 代码、Java 代码）》</a>，希望能对大家有所帮助。</p><p>1、<code>nums[mid] &gt; nums[right]</code>：例子：<code>[7, 8, 9, 10, 1, 2]</code>，<code>mid</code> 肯定不是最小；</p><p>2、否则，<code>nums[mid] &lt; nums[right]</code>：例子：<code>[8, 9, 1, 2, 3, 4, 5, 6]</code>，此时 <code>mid</code> 有可能是最小。</p><p><strong>参考代码 1</strong>：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def findMin(self, nums: List[int]) -> int:        size = len(nums)        if size == 0:            raise Exception('程序出错')        if size == 1:            return nums[0]        left = 0        right = size - 1        while left < right:            # mid = left + (right - left) // 2            mid = (left + right) >> 1            # [7, 8, 1, 2, 3, 4, 5, 6]            if nums[mid] > nums[right]:                # [3, 4, 5, 6, 7, 8, 1, 2]                # 此时 mid 肯定不是最小元素                left = mid + 1            else:                # mid 有可能是最小元素，所以，不能排除它                assert nums[mid] < nums[right]                right = mid        # 一定存在最小元素，因此无需再做判断        return nums[left]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public int findMin(int[] nums) {        int len = nums.length;        if (len == 0) {            throw new IllegalArgumentException("数组为空，无最小元素");        }        int left = 0;        int right = len - 1;        while (left < right) {            // int mid = left + (right - left) / 2;            int mid = (left + right) >>> 1;            if (nums[mid] > nums[right]) {                left = mid + 1;            } else {                // 因为题目中说：你可以假设数组中不存在重复元素。                // 此时一定有 nums[mid] < nums[right]                right = mid;            }        }        // 一定存在最小元素，因此无需再做判断        return nums[left];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二：分治法"><a href="#方法二：分治法" class="headerlink" title="方法二：分治法"></a>方法二：分治法</h3><p>分治法同样适用于 LeetCode 第 154 题。</p><p><strong>参考代码 2</strong>：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def findMin(self, nums: List[int]) -> int:        size = len(nums)        if size == 0:            raise Exception('程序出错')        if size == 1:            return nums[0]        return self.__findMin(nums, 0, size - 1)    def __findMin(self, nums, left, right):        if left == right:            return nums[left]        if left + 1 == right:            return min(nums[left], nums[right])        # mid = left + (right - left) // 2        mid = (left + right) >> 1        return min(self.__findMin(nums, left, mid),                   self.__findMin(nums, mid + 1, right))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    // 虽然可以通过，但是时间复杂度是 O(n)    public int findMin(int[] nums) {        int len = nums.length;        if (len == 0) {            throw new IllegalArgumentException("数组为空");        }        return findMin(nums, 0, len - 1);    }    private int findMin(int[] nums, int left, int right) {        // 思考：这个临界条件是为什么?        // 或者写成 left + 1 >= right        if (left == right || left + 1 == right) {            return Math.min(nums[left], nums[right]);        }        // int mid = left + (right - left) / 2;        int mid = (left + right) >>> 1;        // 8 9 1 2 3 4 5 6 7        if (nums[mid] < nums[right]) {            // 右边是顺序数组            return Math.min(findMin(nums, left, mid - 1), nums[mid]);        } else {            // 左边是顺序数组            // nums[mid] > nums[right]            // 3 4 5 6 7 8 1 2            return Math.min(nums[left], findMin(nums, mid + 1, right));        }    }    public static void main(String[] args) {        Solution2 solution2 = new Solution2();        int[] nums = {1, 2};        int solution2Min = solution2.findMin(nums);        System.out.println(solution2Min);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 81 题：搜索旋转排序数组 II（中等）</title>
      <link href="/leetcode-algo/2017/05/22/leetcode-algo/0081-search-in-rotated-sorted-array-ii/"/>
      <url>/leetcode-algo/2017/05/22/leetcode-algo/0081-search-in-rotated-sorted-array-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-81-题：搜索旋转排序数组-II（中等）"><a href="#「力扣」第-81-题：搜索旋转排序数组-II（中等）" class="headerlink" title="「力扣」第 81 题：搜索旋转排序数组 II（中等）"></a>「力扣」第 81 题：搜索旋转排序数组 II（中等）</h2><p>题解地址：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/" target="_blank" rel="noopener">二分查找（Python 代码、Java 代码）</a>。</p><p>传送门：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a>。</p><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0, 0, 1, 2, 2, 5, 6]</code> 可能变为 <code>[2, 5, 6, 0, 0, 1, 2]</code> )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 <code>true</code>，否则返回 <code>false</code>。</p><p>示例 1：</p><pre><code>输入: nums = [2,5,6,0,0,1,2], target = 0输出: true</code></pre><p>示例 2：</p><pre><code>输入: nums = [2,5,6,0,0,1,2], target = 3输出: false</code></pre><p>进阶：</p><p>这是搜索旋转排序数组的延伸题目，本题中的 <code>nums</code>  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p></blockquote><p>题目给出的是“旋转排序数组”，是“部分有序数组”，<strong>我们同样可以一次排除一半或者一半以上元素的方法</strong>，即二分查找法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分查找法的本质是排除法，二分只是手段，二分保证了“熵”最大，即在没有任何有效信息的时候，平分是最好的方案。</p><p>思路清楚了以后，我们就得确定“有序数组”存在在“原始数组”的哪个子区间里，下面提供了两个比较标准：</p><p>1、中间元素和左边界比较；</p><p>2、中间元素和右边界比较。</p><p>由这两个比较标准就能写出两版不同的代码。</p><h3 id="方法：二分查找"><a href="#方法：二分查找" class="headerlink" title="方法：二分查找"></a>方法：二分查找</h3><p><strong>参考代码 1</strong>：中间元素和左边界比较</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public boolean search(int[] nums, int target) {        int len = nums.length;        if (len == 0) {            return false;        }        int left = 0;        int right = len - 1;        while (left < right) {            int mid = (left + right) >>> 1;            if (nums[mid] > nums[left]) {                if (nums[left] <= target && target <= nums[mid]) {                    // 落在前有序数组里                    right = mid;                } else {                    left = mid + 1;                }            } else if (nums[mid] < nums[left]) {                // 让分支和上面分支一样                if (nums[mid] < target && target <= nums[right]) {                    left = mid + 1;                } else {                    right = mid;                }            } else {                // 要排除掉左边界之前，先看一看左边界可以不可以排除                if (nums[left] == target) {                    return true;                } else {                    left = left + 1;                }            }        }        // 后处理，夹逼以后，还要判断一下，是不是 target        return nums[left] == target;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import Listclass Solution:    def search(self, nums: List[int], target: int) -> bool:        size = len(nums)        if size == 0:            return False        left = 0        right = size - 1        while left < right:            mid = (left + right) >> 1            if nums[mid] > nums[left]:                if nums[left] <= target <= nums[mid]:                    # 落在前有序数组里                    right = mid                else:                    left = mid + 1            elif nums[mid] < nums[left]:                # 让分支和上面分支一样                if nums[mid] < target <= nums[right]:                    left = mid + 1                else:                    right = mid            else:                # 要排除掉左边界之前，先看一看左边界可以不可以排除                if nums[left] == target:                    return True                left = left + 1        # 后处理，夹逼以后，还要判断一下，是不是 target        return nums[left] == target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考代码 2</strong>：中间元素和右边界比较</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    // 中间的数与右边界比较    public boolean search(int[] nums, int target) {        int len = nums.length;        if (len == 0) {            return false;        }        int left = 0;        int right = len - 1;        while (left < right) {            int mid = (left + right + 1 ) >>> 1;            if (nums[mid] < nums[right]) {                // 10 11 4 5 6 7 8 9                // 右边的一定是顺序数组，包括中间数                if (nums[mid] <= target && target <= nums[right]) {                    left = mid;                } else {                    right = mid - 1;                }            } else if (nums[mid] > nums[right]) {                // 4 5 9  2                // 左边是一定是顺序数组，包括中间数                if (nums[left] <= target && target < nums[mid]) {                    right = mid - 1;                } else {                    left = mid;                }            }else {                if(nums[right] == target){                    return true;                }                right = right -1;            }        }        return nums[left] == target;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">from typing import List# 中间元素和右边界比较class Solution:    def search(self, nums: List[int], target: int) -> bool:        size = len(nums)        if size == 0:            return False        left = 0        right = size - 1        while left < right:            # mid = left + (right - left + 1) // 2            mid = (left + right + 1) >> 1            if nums[mid] < nums[right]:                # 后面是有序的                # [2,3,4,5,5,6,6,7]                if nums[mid] <= target <= nums[right]:                    left = mid                else:                    right = mid - 1            elif nums[mid] > nums[right]:                # [3,4,5,5,6,6,7,2]                if nums[left] <= target <= nums[mid - 1]:                    right = mid - 1                else:                    left = mid            else:                assert nums[mid] == nums[right]                if nums[right] == target:                    return True                # 右边不是才删除                right = right - 1        # 后处理        return nums[left] == target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    // [2,5,6,0,0,1,2]    // [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,6,0,0,1,2]    // 传统的二分查找法，与右边界比较    public boolean search(int[] nums, int target) {        int len = nums.length;        if (len == 0) {            return false;        }        int left = 0;        int right = len - 1;        while (left <= right) {            int mid = left + (right - left) / 2;            if (nums[mid] == target) {                return true;            }            if (nums[mid] == nums[right]) {                right--;            } else if (nums[mid] < nums[right]) {                // mid 到 right 是顺序数组                if (nums[mid] < target && target <= nums[right]) {                    left = mid + 1;                } else {                    right = mid - 1;                }            } else {                // nums[mid] > nums[right]                // left 到 mid 是顺序数组                if (nums[left] <= target && target < nums[mid]) {                    right = mid - 1;                } else {                    left = mid + 1;                }            }        }        return false;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 69 题：x 的平方根（简单）</title>
      <link href="/leetcode-algo/2017/05/21/leetcode-algo/0069-sqrtx/"/>
      <url>/leetcode-algo/2017/05/21/leetcode-algo/0069-sqrtx/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-69-题：x-的平方根（简单）"><a href="#「力扣」第-69-题：x-的平方根（简单）" class="headerlink" title="「力扣」第 69 题：x 的平方根（简单）"></a>「力扣」第 69 题：x 的平方根（简单）</h2><ul><li><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <code>x</code> 的平方根，其中 <code>x</code> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1：</p><pre><code>输入：4输出：2</code></pre><p>示例 2：</p><pre><code>输入：8输出：2说明：8 的平方根是 2.82842...，由于返回类型是整数，小数部分将被舍去。</code></pre></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>查找一个有范围的整数，可以使用二分查找。 </p><h3 id="方法一：二分法"><a href="#方法一：二分法" class="headerlink" title="方法一：二分法"></a>方法一：二分法</h3><p><strong>思想</strong>：使用二分法搜索平方根的思想很简单，就类似于小时候我们看的电视节目中的“猜价格”游戏，高了就往低了猜，低了就往高了猜，范围越来越小。因此，使用二分法猜算术平方根就很自然。</p><p>直觉告诉我们，一个数的平方根最多不会超过它的一半，例如 $8$ 的平方根，$8$ 的一半是 $4$，$4^2=16&gt;8$，如果这个数越大越是如此，因此我们要计算一下，这个边界是多少。为此，解如下不等式：</p><p>$$<br>(\frac{a}{2})^2 \ge a<br>$$</p><p>意即：如果一个数的一半的平方大于它自己，那么这个数的取值范围。解以上不等式得 $a \ge 4$ 或者 $a \le 0$。</p><p>于是边界值就是 $4$，那么对 $0$、$1$、$2$、$3$ 分别计算结果，很容易知道，这 $4$ 个数的平方根依次是 $0$、$1$、$1$、$1$。</p><p><strong>注意</strong>：这 $4$ 个特值如果没有考虑到，有可能导致你设置的搜索边界不正确。在使用二分法寻找平方根的时候，要特别注意边界值的选择，以下给出两个参考代码。</p><p><strong>参考代码 1</strong>：所有的数都放在一起考虑，为了照顾到 $0$ 把左边界设置为 $0$，为了照顾到 $1$ 把右边界设置为 <code>x // 2 + 1</code>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 注意：针对特殊测试用例，例如 2147395599</span>        <span class="token comment" spellcheck="true">// 要把搜索的范围设置成长整型</span>        <span class="token comment" spellcheck="true">// 为了照顾到 0 把左边界设置为 0</span>        <span class="token keyword">long</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// # 为了照顾到 1 把右边界设置为 x // 2 + 1</span>        <span class="token keyword">long</span> right <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环</span>            <span class="token keyword">long</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> square <span class="token operator">=</span> mid <span class="token operator">*</span> mid<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>square <span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码要注意到：如果中点 <code>mid</code> 声明为 <code>int</code> 类型，针对大整型测试用例通不过，因此变量需要声明为 <code>long</code> 类型，下同。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 为了照顾到 0 把左边界设置为 0</span>        left <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 为了照顾到 1 把右边界设置为 x // 2 + 1</span>        right <span class="token operator">=</span> x <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环</span>            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            square <span class="token operator">=</span> mid <span class="token operator">*</span> mid            <span class="token keyword">if</span> square <span class="token operator">></span> x<span class="token punctuation">:</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left <span class="token operator">=</span> mid        <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考代码 2</strong>：事实上，只要单独照顾一下 $0$ 这个特例就可以了。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 注意：针对特殊测试用例，例如 2147395599</span>        <span class="token comment" spellcheck="true">// 要把搜索的范围设置成长整型</span>        <span class="token keyword">long</span> left <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> right <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环</span>            <span class="token keyword">long</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> square <span class="token operator">=</span> mid <span class="token operator">*</span> mid<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>square <span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        left <span class="token operator">=</span> <span class="token number">1</span>        right <span class="token operator">=</span> x <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环</span>            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            square <span class="token operator">=</span> mid <span class="token operator">*</span> mid            <span class="token keyword">if</span> square <span class="token operator">></span> x<span class="token punctuation">:</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left <span class="token operator">=</span> mid        <span class="token keyword">return</span> left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 这里二分法的使用是有技巧的（如果你没有意识到，这里很可能是个“坑”），下面我就上面注释中提到的：</p><blockquote><p>注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环。</p></blockquote><p>做一些解释。当 <code>x = 9</code> 的时候，我们不妨给“错误的”代码加上一些调试语句，这样你就会更清晰地发现死循环在什么时候出现，例如：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        left <span class="token operator">=</span> <span class="token number">1</span>        right <span class="token operator">=</span> x <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 调试代码开始：为了仔细观察区间左右端点，我们每进入一次循环，让线程休眠 1 秒</span>            <span class="token keyword">import</span> time            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'调试代码，观察区间左右端点、中位数，和进入的分支： left = {} , right = {} , '</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 调试代码结束</span>            <span class="token comment" spellcheck="true"># 错误代码，在分支左区间不发生收缩的情况下，中位数应该取右中位数</span>            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token comment" spellcheck="true"># 调试代码</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'mid = {} ,'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>            square <span class="token operator">=</span> mid <span class="token operator">*</span> mid            <span class="token keyword">if</span> square <span class="token operator">></span> x<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 调试代码</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'进入 right = mid - 1 这个分支。'</span><span class="token punctuation">)</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 调试代码</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'进入 left = mid 这个分支。'</span><span class="token punctuation">)</span>                left <span class="token operator">=</span> mid        <span class="token keyword">return</span> left<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 当 x = 8 的时候，代码能得出正确答案</span>    x <span class="token operator">=</span> <span class="token number">9</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> solution<span class="token punctuation">.</span>mySqrt<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制台输出：</p><pre class="line-numbers language-angelscript"><code class="language-angelscript">调试代码，观察区间左右端点、中位数，和进入的分支： left = 2 , right = 4 , mid = 3 , 进入 left = mid 这个分支。调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。Traceback (most recent call last):  File "/Users/liwei/（按照惯例这里不让你们看，虽然真的没有什么秘密，就是皮一下子很开心啊有木有）/LeetCode-Solution-Python/17-二分查找/0069-x 的平方根-2（平方根）.py", line 37, in <module>    res = solution.mySqrt(x)  File "/Users/liwei/（按照惯例这里不让你们看，虽然真的没有什么秘密，就是皮一下子很开心啊有木有）/LeetCode-Solution-Python/17-二分查找/0069-x 的平方根-2（平方根）.py", line 11, in mySqrt    time.sleep(1)KeyboardInterrupt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：如果取中点为左中位数，你看到死循环发生在 <code>left = 3</code>， <code>right = 4</code> 的时候，此时<strong>区间只有 2 个元素</strong>。这是为什么呢？</p><p>此时索引区间 <code>[3, 4]</code> 的中位数为左中位数，即 <code>mid = 3</code> ，此时 <code>square = 9 &lt; 9</code> 不成立，进入 <code>left = mid</code> 这个分支，你发现问题了吗，区间不发生收缩，即下一轮循环的索引区间还是  <code>[3, 4]</code>，此时中位数还取左中位数，即 <code>mid = 3</code> ，<code>square = 9 &lt; 9</code> 不成立，又进入 <code>left = mid</code> 这个分支，死循环就是这样产生的。</p><p>接着，请你把 <code>mid = left + (right - left) // 2</code> 改成 <code>mid = left + (right - left + 1) // 2</code> ，即选择右中位数，再观察一下控制台输出，就知道此时为什么要选右中位数了。</p><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(\log N)$，二分法的时间复杂度是对数级别的。</li><li>空间复杂度：$O(1)$，使用了常数个数的辅助空间用于存储和比较。</li></ul><h3 id="方法二：牛顿法"><a href="#方法二：牛顿法" class="headerlink" title="方法二：牛顿法"></a>方法二：牛顿法</h3><p>提示：</p><p>牛顿法不要求掌握，但是思想也很简单，就是以直线代替曲线。具体可以参考题解首页给出的原始题解地址。</p><p><strong>参考代码 2</strong>：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'不能输入负数'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 起始的时候在 1 ，这可以比较随意设置</span>        cur <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">+</span> x <span class="token operator">/</span> cur<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>            <span class="token keyword">if</span> abs<span class="token punctuation">(</span>cur <span class="token operator">-</span> pre<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> int<span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：<code>1e-6</code> 是科学计数法，表示 $1$ 乘以 $10$ 的负 $6$ 次方，也就是 $0.000001$。有的地方使用 <code>epsilon</code>（$\epsilon$）表示 <code>1e-6</code> ，用来抵消浮点运算中因为误差造成的相等无法判断的情况，它通常是一个非常小的数字，具体多小要根据你的精度需求来设置。</p><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：（待讨论，反正很快很快就是了 ^_^，调皮一下显示我的无知）；</li><li>空间复杂度：$O(1)$，使用了常数个数的辅助空间用于存储和比较。</li></ul><p>（本节完）</p><h1 id="LeetCode-第-69-题：使用牛顿法求解平方根"><a href="#LeetCode-第-69-题：使用牛顿法求解平方根" class="headerlink" title="LeetCode 第 69 题：使用牛顿法求解平方根"></a>LeetCode 第 69 题：使用牛顿法求解平方根</h1><p>传送门：<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. x 的平方根</a>。</p><blockquote><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><strong>示例 1:</strong></p><pre><code>输入: 4输出: 2</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: 8输出: 2说明: 8 的平方根是 2.82842...,   由于返回类型是整数，小数部分将被舍去。</code></pre></blockquote><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>思路：使用二分查找，特别注意：应该返回右边端点。</p><p>Python 代码：（推荐写法）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> x <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            square <span class="token operator">=</span> mid <span class="token operator">*</span> mid            <span class="token keyword">if</span> square <span class="token operator">></span> x<span class="token punctuation">:</span>                r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                l <span class="token operator">=</span> mid        <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码1：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 二分法</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type x: int        :rtype: int        """</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> x <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            s <span class="token operator">=</span> m <span class="token operator">*</span> m            <span class="token keyword">if</span> s <span class="token operator">==</span> x<span class="token punctuation">:</span>                <span class="token keyword">return</span> m            <span class="token keyword">elif</span> s <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 注意返回 l 和返回 r 的区别，应该返回 r</span>        <span class="token comment" spellcheck="true"># 【因为返回的是不超过，所要把右边界返回回去】</span>        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码2：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 二分法</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type x: int        :rtype: int        """</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">1</span>        l <span class="token operator">=</span> <span class="token number">0</span>        r <span class="token operator">=</span> x <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            s <span class="token operator">=</span> m <span class="token operator">*</span> m            <span class="token keyword">if</span> s <span class="token operator">==</span> x<span class="token punctuation">:</span>                <span class="token keyword">return</span> m            <span class="token keyword">elif</span> s <span class="token operator">&lt;</span> x<span class="token punctuation">:</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><p>思路：使用牛顿法，推荐这种做法，更简单，返回值向下取整，就能符合题要求。</p><blockquote><p>牛顿法的公式推导必须要会。</p></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 牛顿法</span>    <span class="token comment" spellcheck="true"># 与系统函数作比较</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type x: int        :rtype: int        """</span>        <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'不能输入负数'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        cur <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">+</span> x <span class="token operator">/</span> cur<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>            <span class="token keyword">if</span> abs<span class="token punctuation">(</span>cur <span class="token operator">-</span> pre<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> cur    <span class="token comment" spellcheck="true"># 这个解提交到 LeetCode 上就可以了</span>    <span class="token keyword">def</span> <span class="token function">mySqrt1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type x: int        :rtype: int        """</span>        <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'不能输入负数'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 起始的时候在 1 ，这可以比较随意设置</span>        cur <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            pre <span class="token operator">=</span> cur            cur <span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">+</span> x <span class="token operator">/</span> cur<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>            <span class="token keyword">if</span> abs<span class="token punctuation">(</span>cur <span class="token operator">-</span> pre<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1e</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> int<span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> numpy <span class="token keyword">as</span> np    nums <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">999</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>    solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>        a <span class="token operator">=</span> solution<span class="token punctuation">.</span>mySqrt<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        b <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"牛顿法：{} \t NumPy：{}\t 差距：{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是牛顿法的笔记：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzjqfubqebj30w40jetck.jpg" alt="image-20190110160239961"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzjqftv7mfj30u013fwm1.jpg" alt="image-20190110160310951"></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/69-1.png" alt=""></p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution/69-2.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h2 id="牛顿法的应用之一：解方程，求开方。"><a href="#牛顿法的应用之一：解方程，求开方。" class="headerlink" title="牛顿法的应用之一：解方程，求开方。"></a>牛顿法的应用之一：解方程，求开方。</h2><p>马同学的《如何通俗易懂地讲解牛顿迭代法求开方？》讲解了牛顿法迭代求高次方程的根的思路：<br><a href="https://www.zhihu.com/question/20690553" target="_blank" rel="noopener">https://www.zhihu.com/question/20690553</a></p><p>注明：为什么例子是二次的呢？因为二次一定是凸函数。</p><p>皮果提的文章</p><p>牛顿法与拟牛顿法学习笔记（一）牛顿法<br><a href="http://blog.csdn.net/itplus/article/details/21896453" target="_blank" rel="noopener">http://blog.csdn.net/itplus/article/details/21896453</a></p><p>牛顿法与拟牛顿法学习笔记（二）拟牛顿条件<br><a href="http://blog.csdn.net/itplus/article/details/21896619" target="_blank" rel="noopener">http://blog.csdn.net/itplus/article/details/21896619</a></p><p>牛顿法与拟牛顿法学习笔记（三）DFP 算法<br><a href="http://blog.csdn.net/itplus/article/details/21896981" target="_blank" rel="noopener">http://blog.csdn.net/itplus/article/details/21896981</a></p><p>牛顿法与拟牛顿法学习笔记（四）BFGS 算法<br><a href="http://blog.csdn.net/itplus/article/details/21897443" target="_blank" rel="noopener">http://blog.csdn.net/itplus/article/details/21897443</a></p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 35 题：搜索插入位置（简单）</title>
      <link href="/leetcode-algo/2017/05/20/leetcode-algo/0035-search-insert-position/"/>
      <url>/leetcode-algo/2017/05/20/leetcode-algo/0035-search-insert-position/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-35-题：搜索插入位置（简单）"><a href="#「力扣」第-35-题：搜索插入位置（简单）" class="headerlink" title="「力扣」第 35 题：搜索插入位置（简单）"></a>「力扣」第 35 题：搜索插入位置（简单）</h2><ul><li><p><a href="https://leetcode-cn.com/problems/search-insert-position" target="_blank" rel="noopener">链接</a></p></li><li><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">题解链接（含视频讲解）</a></p></li></ul><blockquote><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1：</p><pre><code>输入: [1, 3, 5, 6], 5输出: 2</code></pre><p>示例 2：</p><pre><code>输入: [1, 3, 5, 6], 2输出: 1</code></pre><p>示例 3：</p><pre><code>输入: [1, 3, 5, 6], 7输出: 4</code></pre><p>示例 4：</p><pre><code>输入: [1, 3, 5, 6], 0输出: 0</code></pre></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>看到的中间数 <code>nums[i]</code> 什么时候不是解，比较好想；</li><li>「好想」的这一步对了，它的反面就可以很容易得到，边界设置就不容易出错；</li><li>依然是建议在编码的时候，把下一轮搜索区间是什么写在注释里；</li><li>理解：把要查找的目标元素留在最后判断的思想。这道题就是把可以插入元素的位置留在最后判断，因为一定可以放在一个位置上，最后剩下的那个位置就是插入元素的位置。</li></ul><p>如果二分查找一开始写不出来，可以尝试先写暴力法，分析清楚细节；</p><ul><li>在有序数组中查找插入元素的位置，显然可以使用二分查找；</li><li>这篇题解提供的思路是“排除法”，即：在循环的过程中，不断排除不需要的解，最后剩下的那个元素就一定是我们想要的。</li></ul><p>具体的做法是：</p><ul><li>首先，插入位置有可能在数组的末尾（题目中的示例 3），需要单独判断；</li><li>其次，如果待插入元素比最后一个元素严格小，并且在这个数组中有和插入元素一样的元素，返回任意一个位置即可；</li><li>否则，插入的位置应该是严格大于 <code>target</code> 的第 1 个元素的位置。</li></ul><p>因此，<strong>严格小于 <code>target</code> 的元素一定不是解</strong>，根据这个思路，可以写出如下代码。</p><p><strong>参考代码 1</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> len<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 严格小于 target 的元素一定不是解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 特判</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>            <span class="token keyword">return</span> size        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token comment" spellcheck="true"># 严格小于 target 的元素一定不是解</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 下一轮搜索区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right <span class="token operator">=</span> mid        <span class="token keyword">return</span> left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++ 代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 特判</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> size<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 严格小于 target 的元素一定不是解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(\log N)$，这里 $N$ 是数组的长度，每一次都将问题的规模缩减为原来的一半，因此时间复杂度是对数级别的；</li><li>空间复杂度：$O(1)$。</li></ul><p>由于插入元素的位置，一定在搜索范围里，因此退出循环的时候，不用再做一次判断。</p><p>本题还可以有如下两种写法，请读者比较它们的不同之处。</p><p><strong>参考代码 2</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 len</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 小于 target 的元素一定不是解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索的区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        left <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 len</span>        right <span class="token operator">=</span> size        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 严格小于 target 的元素一定不是解</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 下一轮搜索区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right <span class="token operator">=</span> mid        <span class="token keyword">return</span> left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++ 代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 len</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 小于 target 的元素一定不是解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索的区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考代码 3</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 根据本题特殊性，看到等于 target 的元素，返回任意一个即可</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        left <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 len</span>        right <span class="token operator">=</span> size        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 严格小于 target 的元素一定不是解</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 下一轮搜索区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 根据本题特殊性，看到等于 target 的元素，返回任意一个即可</span>                <span class="token keyword">return</span> mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                right <span class="token operator">=</span> mid        <span class="token keyword">return</span> left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++ 代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 根据本题特殊性，看到等于 target 的元素，返回任意一个即可</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p><hr><p>（以前写的文字，备份）</p><p>传送门：<a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a> </p><blockquote><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><pre><code>输入: [1,3,5,6], 5输出: 2</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [1,3,5,6], 2输出: 1</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: [1,3,5,6], 7输出: 4</code></pre><p><strong>示例 4:</strong></p><pre><code>输入: [1,3,5,6], 0输出: 0</code></pre></blockquote><p>分析：根据题意，结合题目给出的 4 个示例，给出这个问题的等价表述如下。</p><blockquote><p>1、如果目标值（严格）大于排序数组的最后一个数，返回这个排序数组的长度，否则进入第 2 点。</p><p>2、返回排序数组从左到右，大于或者等于目标值的第 1 个数的<strong>索引</strong>。</p></blockquote><p>说明：事实上，当给出数组中有很多数和目标值相等的时候，我们返回任意一个与之相等的数的索引值都可以，不过为了简单起见，也为了方便后面的说明，我们返回第 1 个。</p><p>题目告诉你“排序数组”，其实就是在<strong>疯狂暗示你用二分查找法</strong>。二分查找法的思想并不难，但写好一个二分法还是有一些注意事项的，在这里我借着这道题位为大家总结一下。</p><p>刚接触二分法的时候，我们可能会这样写：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> len<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 等于的情况最简单，我们应该放在第 1 个分支进行判断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 题目要我们返回大于或者等于目标值的第 1 个数的索引</span>                <span class="token comment" spellcheck="true">// 此时 mid 一定不是所求的左边界，</span>                <span class="token comment" spellcheck="true">// 此时左边界更新为 mid + 1</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 既然不会等于，此时 nums[mid] > target</span>                <span class="token comment" spellcheck="true">// mid 也一定不是所求的右边界</span>                <span class="token comment" spellcheck="true">// 此时右边界更新为 mid - 1</span>                r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 注意：一定得返回左边界 l，</span>        <span class="token comment" spellcheck="true">// 如果返回右边界 r 提交代码不会通过</span>        <span class="token comment" spellcheck="true">// 下面我尝试说明一下理由，如果你不太理解下面我说的，那是我的表达问题</span>        <span class="token comment" spellcheck="true">// 【注意】建议你不要纠结这个问题，因为我马上介绍的二分法模板，可以避免对返回 l 和 r 的思考</span>        <span class="token comment" spellcheck="true">// 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1</span>        <span class="token comment" spellcheck="true">// 在上面的 while (l &lt;= r) 退出循环以后，r &lt; l，r = 0 ，l = 1</span>        <span class="token comment" spellcheck="true">// 根据题意应该返回 l，</span>        <span class="token comment" spellcheck="true">// 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 r</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你是把二分法可以进行的条件写成 <code>while (l &lt;= r)</code> 的话，在写最后一句 <code>return</code> 的时候，如果你不假思索，把左边界 <code>l</code> 返回回去，可能误打误撞，你就写对了，但是事实上，返回 <code>l</code> 是有一定道理的，如果题目换一种问法，你可能就要返回右边界 <code>r</code>（这句话不太理解没有关系，我也不打算讲得很清楚，因为太绕了，这不是我要说的重点）。</p><p>你可能在一些资料中，看过别人写二分法的时候，把二分法可以进行的条件写成 <code>while (l &lt; r)</code> ，你是不是跟我一样有疑问，咦？当左右边界一样的时候，那个数岂不是会被漏掉。但是我要告诉你，这样写是最好的，这是写二分法最好的“模板”。下面给出我的理由。</p><blockquote><p>推荐你在 <code>while</code> 循环里写 <code>l &lt; r</code>，因为在退出循环的时候，你不必纠结返回 <code>l</code> 还是返回 <code>r</code>。但还有一些细节要注意。</p></blockquote><p>写 <code>while (l &lt; r)</code> 的时候，退出循环时，左边界等于右边界，因此你不必纠结要返回 <code>l</code> 还是 <code>r</code> ，你返回 <code>l</code> 或者 <code>r</code> 都是可以的。这是“夹逼”的思想，搜索要找到的数，使得区间越来越小，直到区间成为一个数。这里有 2 个细节要注意：</p><blockquote><p>1、<strong>如果你确定你要找的数一定在左边界和右边界所表示的区间里出现</strong>，那么可以放心地返回 <code>l</code> 或者 <code>r</code>；</p><p>2、如果你不确定你要找的数一定在左边界和右边界所表示的区间里出现，那么也没有关系，只要在退出循环以后，再针对 <code>nums[l]</code> 或者 <code>nums[r]</code> （此时 <code>nums[l] == nums[r]</code>）单独作一次判断，看它是不是你要找的数即可。</p></blockquote><p>这是我推荐使用你写 <code>while (l &lt; r)</code> 的主要原因，可以避免你对返回左边界还是右边界的讨论。下面给出这道问题，使用  <code>while (l &lt; r)</code>  模板写法的示例代码。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 返回大于等于 target 的索引，有可能是最后一个</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        l <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 如果 target 比 nums里所有的数都大，则最后一个数的索引 + 1 就是候选值，因此，右边界应该是数组的长度</span>        r <span class="token operator">=</span> size                <span class="token comment" spellcheck="true"># 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界。</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> mid        <span class="token keyword">return</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写出这段代码是有一定“技巧”的。</p><p>1、首先是取中点的方式：<code>mid = l + (r - l) // 2</code>。</p><p>当 <code>l</code> 和 <code>r</code> 是很大的整数的时候，你写 <code>int mid = (l + r) / 2;</code> 这里 <code>l + r</code> 就有可能超过 <code>int</code> 类型能表示的最大值，因此使用 <code>mid = l + (r - l) // 2</code> 可以避免这种情况。</p><p>事实上  <code>mid = l + (r - l) // 2</code>  在 <code>r</code> 很大，并 <code>l</code> 是负数且很小的时候， <code>r - l</code> 也有可能超过 <code>int</code> 类型能表示的最大值，只不过一般情况下 <code>l</code> 和 <code>r</code> 表示的是数组索引值，<code>l</code> 是非负数，因此  <code>r - l</code>  溢出的可能性很小。</p><p>另外，还要注意一点，我们知道当数组的元素个数是偶数的时候，中位数有左中位数和右中位数：</p><ul><li><p>使用 <code>mid = l + (r - l) // 2</code> 得到左中位数的索引；</p></li><li><p>使用 <code>mid = l + (r - l + 1) // 2</code> 得到右中位数的索引。</p></li></ul><p>我们使用一个具体的例子来验证这件事情，当索引 <code>l = 3</code>，索引 <code>r = 4</code> 的时候，左中位数是索引 <code>l</code>，右中位数是索引 <code>r</code>，这是因为：</p><p><code>mid = l + (r - l) // 2 = 3 + (4 - 3) // 2 = 3 + 0 = 3</code>，</p><p><code>mid = l + (r - l + 1) // 2 = 3 + (4 - 3 + 1) // 2 = 3 + 1 = 4</code>，</p><p>记忆方法：<code>(r - l)</code> 不加 1 选左中位数，加 1 选右中位数。</p><p>那么什么时候使用左中位数，什么时候使用右中位数呢？这就要看分支的逻辑了。</p><p>2、编写分支的逻辑循序先写“排除逻辑”所在的分支。</p><blockquote><p>先考虑能把“中位数”排除在外的逻辑，而不能排除“中位数”的逻辑放在 <code>else</code> 分支里，这样做的理由有 2 点：</p><p>1、可以排除“中位数”的逻辑，通常比较好想（但并不绝对，这一点视情况而定）；</p><p>2、分支条数变成 2 ，比原来 3 个分支要考虑的情况少，即<strong>不用单独考虑中位数是否满足题意</strong>，<strong>因为退出循环的时候，左右区间压缩成一个数（索引）的时候，这个索引表示的数要么满足题意，要么不满足题意，而不必在二分逻辑中单独做判断</strong>（这一点很重要，希望读者结合具体例子仔细体会）。</p></blockquote><p>以本题为例，最开始我们就分析了要求我们找到“大于或者等于目标值的第 1 个数的<strong>索引</strong>”。所以</p><ul><li><p>如果中位数小于目标值，就应该被排除，左边界 <code>l</code> 就至少是 <code>mid + 1</code>，这个逻辑很容易分析清楚；</p></li><li><p>如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 1 个数的<strong>索引</strong>，<strong>中位数以及中位数的左边都有可能是符合题意的数</strong>，因此右边界就不能把 <code>mid</code> 排除，因此右边界 <code>r</code> 至多是 <code>mid</code> 。</p></li></ul><p>而下一点就更关键了。</p><p>3、根据分支编写的情况，选择使用左中位数还是右中位数。</p><p>我们应该先写分支，再写中位数，看看应该选左中位数还是右中位数。这个结论不用记住，需要结合具体例子理解。规则如下：</p><blockquote><p>二分法之所以有效，是因为在每一轮的逻辑判断中，都可以排除差不多一半的候选数，即<strong>候选区间会收缩，最终收缩成 1 个数的时候，就定位了我们真正要找的那个数</strong>。但是<strong>在区间元素只有 2 个时候，中位数的选择如果不恰当，很可能会出现死循环</strong>。</p><p>为了避免出现死循环，我们需要保证：</p><p>1、如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；</p><p>2、同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。</p></blockquote><p>上面的规则说起来很绕，不要去记它，我写的时候都晕。理解上面的这个规则可以通过具体的例子：</p><blockquote><p>针对以上规则的第 1 点：如果分支的逻辑，在选择左边界的时候不能排除中位数，例如：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 不妨先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span> <span class="token comment" spellcheck="true"># 业务逻辑代码</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>check<span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># 选择右边界的时候，可以排除中位数</span>     r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">else</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># 选择左边界的时候，不能排除中位数</span>     l <span class="token operator">=</span> mid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>在区间中的元素只剩下 2 个时候</strong>，例如：<code>l = 3</code>，<code>r = 4</code>。此时<strong>左中位数就是左边界</strong>，如果你的逻辑执行到 <code>l = mid</code> 这个分支，<strong>且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环</strong>；</li><li>为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 <code>l = mid</code> 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 <code>r = mid - 1</code> 让区间收缩，最终成为 1 个数，退出 <code>while</code> 循环。</li></ul><p>上面的这种情况如果你理解了，就可以类似地看待提出的规则的第 2 点。</p></blockquote><p>总结一下，我爱用这个模板的原因、技巧和注意事项：</p><blockquote><p>1、技巧：无脑地写 <code>while l &lt; r:</code> ，这样你就不用判断，在退出循环的时候你应该返回 <code>l</code> 还是 <code>r</code>；</p><p>2、技巧：先写分支逻辑，并且先写排除中位数的逻辑分支，再根据分支的情况选择使用左中位数还是右中位数；</p><p>3、原因：分支条数只有 2 条，代码执行效率更高，不用单独判断中位数是否符合题目要求，因为在在二分的过程中，区间会逐渐收缩，二分的时候，代码逻辑的关注点是排除将近一半的候选数；</p><p>4、注意1：如果你确定你要找的数就在候选区间里，那么退出循环的时候，区间最后收成为 1 个数后，直接把这个数返回即可；如果你最后要找的数有可能不在候选区间里，区间最后收成为 1 个数后，还要单独判断一下这个数是否符合题意；</p><p>5、注意2：左中位数还是右中位数选择的标准根据分支的逻辑而来，这个标准就是每一次循环让区间收缩，在区间只剩下 2 个元素的时候，为了避免死循环发生，如果你实在很晕，不防就使用有 2 个元素的测试用例，就能明白其中的原因。</p></blockquote><p>最后给出两个模板，大家看的时候看注释，不用记这个模板：</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">binary_search_1</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 当分支逻辑不能排除右边界的时候选择左中位数</span>    <span class="token comment" spellcheck="true"># 如果选择右中位数，当区间只剩下 2 个元素的时候，</span>    <span class="token comment" spellcheck="true"># 一旦进入 r = mid 这个分支，右边界不会收缩，代码进入死循环</span>    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>        mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">if</span> check<span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 先写可以排除中位数的逻辑</span>            l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 右边界不能排除</span>            r <span class="token operator">=</span> mid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">binary_search_2</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 当分支逻辑不能排除左边界的时候选择右中位数</span>    <span class="token comment" spellcheck="true"># 如果选择做中位数，当区间只剩下 2 个元素的时候，</span>    <span class="token comment" spellcheck="true"># 一旦进入 l = mid 这个分支，左边界不会收缩，代码进入死循环</span>    <span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>        mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">if</span> check<span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 先写可以排除中位数的逻辑</span>            r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># 左边界不能排除</span>            l <span class="token operator">=</span> mid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：我写的时候，一般是先把中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 <code>(r - l)</code> 这个括号里面加 1 。</p><p>本题选择“左中位数”，选择“右中位数”的是 <a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">「力扣」第 69 题：x 的平方根</a>。</p><p>我想我应该是成功地把你绕晕了，在此建议您不妨多做几道使用“二分查找法”解决的问题，用一下我说的这个模板，<strong>在发现问题的过程中，体会这个模板好用的地方，相信你一定会和我一样爱上这个模板的</strong>。</p><hr><p>（以下是原始文章，备份用）</p><h1 id="特别好用的二分查找法模板（Python-代码、Java-代码）"><a href="#特别好用的二分查找法模板（Python-代码、Java-代码）" class="headerlink" title="特别好用的二分查找法模板（Python 代码、Java 代码）"></a>特别好用的二分查找法模板（Python 代码、Java 代码）</h1><table><thead><tr><th>题目地址</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">LeetCode 第 35 题：搜索插入位置</a></td><td><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">特别好用的二分查找法模板（Python 代码、Java 代码）</a></td></tr></tbody></table><p>分析：根据题意，结合题目给出的 4 个示例，不难分析出这个问题的等价表述如下。</p><blockquote><p>1、如果目标值（严格）大于排序数组的最后一个数，返回这个排序数组的长度，否则进入第 2 点。</p><p>2、返回排序数组从左到右，大于或者等于目标值的第 1 个数的<strong>索引</strong>。</p></blockquote><p>事实上，当给出数组中有很多数和目标值相等的时候，我们返回任意一个与之相等的数的索引值都可以，不过为了简单起见，也为了方便后面的说明，我们返回第 1 个符合题意的数的索引。</p><p>题目告诉你“排序数组”，其实就是在<strong>疯狂暗示你用二分查找法</strong>。二分查找法的思想并不难，但写好一个二分法并不简单，就借着这道题为大家总结一下。</p><h3 id="一、传统二分查找法模板"><a href="#一、传统二分查找法模板" class="headerlink" title="一、传统二分查找法模板"></a>一、传统二分查找法模板</h3><p>刚接触二分查找法的时候，我们可能会像下面这样写代码，我把这种写法容易出错的地方写在了注释里：</p><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public int searchInsert(int[] nums, int target) {        int len = nums.length;        if (nums[len - 1] < target) {            return len;        }        int l = 0;        int r = len - 1;        while (l <= r) {            int mid = (l + r) / 2;            // 等于的情况最简单，我们放在第 1 个分支进行判断            if (nums[mid] == target) {                return mid;            } else if (nums[mid] < target) {                // 题目要我们返回大于或者等于目标值的第 1 个数的索引                // 此时 mid 一定不是所求的左边界，                // 此时左边界更新为 mid + 1                l = mid + 1;            } else {                // 既然不会等于，此时 nums[mid] > target                // mid 也一定不是所求的右边界                // 此时右边界更新为 mid - 1                r = mid - 1;            }        }        // 注意：一定得返回左边界 l，        // 如果返回右边界 r 提交代码不会通过        // 下面我尝试说明一下理由，如果你不太理解下面我说的，那是我的表达问题        // 【注意】建议你不要纠结这个问题，因为我马上介绍的二分法模板，可以避免对返回 l 和 r 的思考        // 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1        // 在上面的 while (l <= r) 退出循环以后，r < l，r = 0 ，l = 1        // 根据题意应该返回 l，        // 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 r        return l;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：如果你把二分查找法可以进行的条件写成 <code>while (l &lt;= r)</code> 的话，在写最后一句 <code>return</code> 的时候，如果你不假思索，把左边界 <code>l</code> 返回回去，可能误打误撞，你写对了。但是事实上，返回 <code>l</code> 是有一定道理的，如果题目换一种问法，你可能就要返回右边界 <code>r</code>，这句话不太理解没有关系，我也不打算讲得很清楚，因为太绕了，这不是我要说的重点。</p><blockquote><p>传统二分查找法的问题在于，当退出 <code>while</code> 循环的时候，应该返回左边界还是右边界比较容易出错。</p></blockquote><p>那么是不是可以回避这个问题呢？答案是肯定的，并且只要你掌握了下面我介绍的“神奇的”二分查找法模板，你会屡试不爽的。</p><h3 id="二、“神奇的”二分查找法模板"><a href="#二、“神奇的”二分查找法模板" class="headerlink" title="二、“神奇的”二分查找法模板"></a>二、“神奇的”二分查找法模板</h3><p>在一些资料中，你可能看过别人写二分查找法，把循环可以进行的条件写成 <code>while (l &lt; r)</code> ，当时你是不是跟我一样有疑问，咦？当左右边界一样的时候，那个数岂不是会被漏掉。但是我要告诉你，这样写是最好的，这是最好二分查找法“模板”的一部分。</p><blockquote><p>理由很简单，写 <code>while (l &lt; r)</code> 的时候，退出循环时，左边界等于右边界，因此你不必纠结要返回 <code>l</code> 还是 <code>r</code> ，此时返回 <code>l</code> 或者 <code>r</code> 都是可以的。</p></blockquote><p>二分查找法之所以高效，是因为它利用了数组有序的特点，在每一次的搜索过程中，都可以排除将近一半的数，<strong>使得搜索区间越来越小，直到区间成为一个数</strong>。不过这里有个细节要注意：</p><blockquote><p>1、<strong>如果你确定你要找的数一定在左边界和右边界所表示的区间里出现</strong>，那么可以放心地返回 <code>l</code> 或者 <code>r</code>；</p><p>2、如果你不确定你要找的数一定在左边界和右边界所表示的区间里出现，那么也没有关系，只要在退出循环以后，再针对 <code>nums[l]</code> 或者 <code>nums[r]</code> （此时 <code>nums[l] == nums[r]</code>）单独作一次判断，看它是不是你要找的数即可。</p></blockquote><p>写 <code>while (l &lt; r)</code> 可以避免你对返回左边界还是右边界的讨论。下面给出这道问题，使用 <code>while (l &lt; r)</code> 模板写法的参考代码。</p><p>Python 代码：</p><pre class="line-numbers language-Python"><code class="language-Python">class Solution:    def searchInsert(self, nums, target):        # 返回大于等于 target 的索引，有可能是最后一个        size = len(nums)        if size == 0:            return 0        l = 0        # 如果 target 比 nums里所有的数都大，则最后一个数的索引 + 1 就是候选值，因此，右边界应该是数组的长度        r = size        # 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界        while l < r:            mid = l + (r - l) // 2            if nums[mid] < target:                l = mid + 1            else:                r = mid        return l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java 代码：</p><pre class="line-numbers language-Java"><code class="language-Java">public class Solution {    public int searchInsert(int[] nums, int target) {        int len = nums.length;        if (len == 0) {            return 0;        }        if (target > nums[len - 1]) {            return len;        }        int left = 0;        int right = len - 1;        while (left < right) {            int mid = left + (right - left) / 2;            if (nums[mid] < target) {                left = mid + 1;            } else {                right = mid;            }        }        return right;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过写出这段代码还是有一定“技巧”的。</p><h3 id="三、技巧、调试方法和注意事项"><a href="#三、技巧、调试方法和注意事项" class="headerlink" title="三、技巧、调试方法和注意事项"></a>三、技巧、调试方法和注意事项</h3><p>1、首先，得弄清楚取中点的方式。</p><p>（1）当 <code>l</code> 和 <code>r</code> 是很大的整数的时候，你写 <code>int mid = (l + r) / 2;</code> 这里 <code>l + r</code> 就有可能超过 <code>int</code> 类型能表示的最大值，因此使用 <code>mid = l + (r - l) // 2</code> 可以避免这种情况。</p><p>事实上  <code>mid = l + (r - l) // 2</code>  在 <code>r</code> 很大，并 <code>l</code> 是负数且很小的时候， <code>r - l</code> 也有可能超过 <code>int</code> 类型能表示的最大值，只不过一般情况下 <code>l</code> 和 <code>r</code> 表示的是数组索引值，<code>l</code> 是非负数，因此  <code>r - l</code>  溢出的可能性很小。</p><p>（2）另外还要注意，当数组的元素个数是偶数的时候，中位数有左中位数和右中位数之分：</p><ul><li><p>使用 <code>mid = l + (r - l) // 2</code> 得到左中位数的索引；</p></li><li><p>使用 <code>mid = l + (r - l + 1) // 2</code> 得到右中位数的索引。</p></li></ul><p>当数组的元素个数是奇数的时候，二者都能选到最中间的那个中位数。</p><p>我们使用一个具体的例子来验证这件事情，当索引 <code>l = 3</code>，索引 <code>r = 4</code> 的时候，左中位数是索引 <code>l</code>，右中位数是索引 <code>r</code>，这是因为：</p><p><code>mid = l + (r - l) // 2 = 3 + (4 - 3) // 2 = 3 + 0 = 3</code>，</p><p><code>mid = l + (r - l + 1) // 2 = 3 + (4 - 3 + 1) // 2 = 3 + 1 = 4</code>。</p><blockquote><p>记忆方法：<strong><code>(r - l)</code> 不加 1 选左中位数，加 1 选右中位数</strong>。</p></blockquote><p>那么，什么时候使用左中位数，什么时候使用右中位数呢？这就要看分支的逻辑了。</p><p>2、编写分支的逻辑循序先写“排除逻辑”所在的分支。</p><p><strong>这里介绍很重要的一个技巧</strong>：先考虑能把“中位数”排除在外的逻辑，而不能排除“中位数”的逻辑放在 <code>else</code> 分支里，这样做的理由有 2 点：</p><blockquote><p>（1）可以排除“中位数”的逻辑，通常比较好想，但并不绝对，这一点视情况而定；</p><p>（2）分支条数变成 2 条，比原来 3 个分支要考虑的情况少，即<strong>不用单独考虑中位数是否满足题意</strong>，<strong>因为退出循环的时候，左右区间压缩成一个数（索引）的时候，这个索引表示的数要么满足题意，要么不满足题意，而不必在二分逻辑中单独做判断</strong>（这一点很重要，希望读者结合具体例子仔细体会）。</p></blockquote><p>以本题为例，最开始我们就分析了要求我们找到“大于或者等于目标值的第 1 个数的<strong>索引</strong>”。所以对于这道题而言：</p><p>（1）如果中位数小于目标值，就应该被排除，左边界 <code>l</code> 就至少是 <code>mid + 1</code>；</p><p>（2）如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 1 个数的<strong>索引</strong>，<strong>中位数以及中位数的左边都有可能是符合题意的数</strong>，因此右边界就不能把 <code>mid</code> 排除，因此右边界 <code>r</code> 至多是 <code>mid</code>，此时右边界不向左边收缩。</p><p><strong>而下一点就更关键了</strong>。</p><p>3、根据分支编写的情况，选择使用左中位数还是右中位数。</p><p>先写分支，根据分支的逻辑选中位数，选左中位数还是右中位数，这要做的理由是为了防止出现死循环。</p><blockquote><p>死循环就容易发生在区间元素只有 2 个时候，此时中位数的选择尤为关键。</p></blockquote><p>为了避免出现死循环，我们需要确保：</p><blockquote><p>1、如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环；</p><p>2、同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。</p></blockquote><p>上面的规则说起来很绕，可以暂时跳过，不要去记它，我写的时候都晕。理解上面的这个规则可以通过具体的例子：</p><p>针对以上规则的第 1 点：如果分支的逻辑，在选择左边界的时候不能排除中位数，例如：</p><p>Python 伪代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 不妨先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整</span>    mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    <span class="token comment" spellcheck="true"># 业务逻辑代码</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>check<span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 选择右边界的时候，可以排除中位数</span>        r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 选择左边界的时候，不能排除中位数</span>        l <span class="token operator">=</span> mid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>在区间中的元素只剩下 2 个时候</strong>，例如：<code>l = 3</code>，<code>r = 4</code>。此时<strong>左中位数就是左边界</strong>，如果你的逻辑执行到 <code>l = mid</code> 这个分支，<strong>且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环</strong>；</li><li>为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 <code>l = mid</code> 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 <code>r = mid - 1</code> 让区间收缩，最终成为 1 个数，退出 <code>while</code> 循环。</li></ul><p>上面的这种情况如果你理解了，就可以类似地理解提出的规则的第 2 点。</p><blockquote><p>按照我的经验，一开始编码的时候，稍不注意就很容易出现死循环，不过没有关系，你可以你的代码中写上一些输出语句，就容易理解“在区间元素只有 2 个的时候容易出现死循环”。具体编码调试的细节，可以参考我在 <a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">「力扣」第 69 题：x 的平方根</a>的题解<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">《二分查找 + 牛顿法（Python 代码、Java 代码）》</a> 。</p></blockquote><h3 id="四、使用总结"><a href="#四、使用总结" class="headerlink" title="四、使用总结"></a>四、使用总结</h3><p>总结一下，我爱用这个模板的原因、技巧、优点和注意事项：</p><blockquote><p>1、原因：无脑地写 <code>while l &lt; r:</code> ，这样你就不用判断，在退出循环的时候你应该返回 <code>l</code> 还是 <code>r</code>；</p><p>2、技巧：先写分支逻辑，并且先写排除中位数的逻辑分支（因为容易想到），再根据分支的情况选择使用左中位数还是右中位数；</p><p>3、优点：分支条数只有 2 条，代码执行效率更高，不用单独判断中位数是否符合题目要求，<strong>写分支的逻辑的目的是尽量排除更多的候选元素</strong>，而判断中位数是否符合题目要求我们放在最后进行，这就是第 5 点；</p><p>4、注意事项 1：左中位数还是右中位数选择的标准根据分支的逻辑而来，标准是每一次循环都应该让区间收缩，在区间只剩下 2 个元素的时候，为了避免死循环发生，选择正确的中位数类型。如果你实在很晕，不防就使用有 2 个元素的测试用例，就能明白其中的原因，另外在代码出现死循环的时候，建议你可以将左边界、右边界、你选择的中位数的值，还有分支逻辑都打印输出一下，出现死循环的原因就一目了然了；</p><p>5、注意事项 2：如果能确定要找的数就在候选区间里，那么退出循环的时候，区间最后收缩成为 1 个数后，直接把这个数返回即可；如果你要找的数有可能不在候选区间里，区间最后收缩成为 1 个数后，还要单独判断一下这个数是否符合题意；</p></blockquote><p>最后给出两个模板，大家看的时候看注释，而不必也无需记忆它们，最好的理解这个模板的方法还是应用它。</p><p>Python 伪代码1： 分支是右区间不收缩的时候，选中位数选左中位数，因为如果你选右中位数，会出现死循环。</p><pre class="line-numbers language-Python"><code class="language-Python">def binary_search_1(l, r):    # 当分支逻辑不能排除右边界的时候选择左中位数    # 如果选择右中位数，当区间只剩下 2 个元素的时候，    # 一旦进入 r = mid 这个分支，右边界不会收缩，代码进入死循环    while l < r:        mid = l + (r - l) // 2        if check(mid):            # 先写可以排除中位数的逻辑            l = mid + 1        else:            # 右边界不能排除            r = mid    # 退出循环的时候，视情况，是否需要单独判断 l （或者 r）这个索引表示的元素是否符合题意<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 伪代码2：分支是左区间不收缩的时候，选中位数选右中位数，因为如果你选左中位数，会出现死循环。</p><pre class="line-numbers language-Python"><code class="language-Python">def binary_search_2(l, r):    # 当分支逻辑不能排除左边界的时候选择右中位数    # 如果选择做中位数，当区间只剩下 2 个元素的时候，    # 一旦进入 l = mid 这个分支，左边界不会收缩，代码进入死循环    while l < r:        mid = l + (r - l + 1) // 2        if check(mid):            # 先写可以排除中位数的逻辑            r = mid - 1        else:              # 左边界不能排除            l = mid    # 退出循环的时候，视情况，是否需要单独判断 l （或者 r）这个索引表示的元素是否符合题意<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明</strong>：我写的时候，一般是先默认将中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 <code>(r - l)</code> 这个括号里面加 1 。</p><p>我想我应该是成功地把你绕晕了，在此建议您不妨多做几道使用“二分查找法”解决的问题，用一下我说的这个模板，<strong>在发现问题的过程中，体会这个模板好用的地方，相信你一定会和我一样爱上这个模板的</strong>。</p><h3 id="五、应用提升"><a href="#五、应用提升" class="headerlink" title="五、应用提升"></a>五、应用提升</h3><p>这里给出一些练习题，这些练习题都可以使用这个“神奇的”二分查找法模板比较轻松地写出来，并且得到一个不错的分数，大家加油！</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution-new/0035/704.png" alt="LeetCode 第 704 题"></p><p>说明：<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">传送门</a>。这道题是二分查找的模板题，因为目标值有可能在数组中并不存在，所以退出 <code>while</code> 循环的时候，要单独判断一下。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution-new/0035/69.png" alt="LeetCode 第 69 题"></p><p>说明：<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">传送门</a>。</p><p>（1）题解链接已经在上文中已经给出，这道题根据分支的逻辑应该选右中位数；</p><p>（2）这道题因为还有更高效的“牛顿法”，所以看起来排名并不是特别理想。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution-new/0035/300.png" alt="LeetCode 第 300 题"></p><p>说明：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">传送门</a>，第 300 题的一个子过程就是本题（第 35 题），我在这道题的题解<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener">《动态规划 + 贪心算法（二分法）（Python 代码、Java 代码）》</a> 中给了两个 Python 的示例代码，它们是对本文中给出的注意事项：</p><blockquote><p>如果你确定要搜索的数在区间里，循环完成以后直接返回即可；如果你不确定要搜索的数在区间里，循环完成以后需要再做一次判断。</p></blockquote><p>的具体代码实现。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution-new/0035/153.png" alt="LeetCode 第 153 题"></p><p>说明：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">传送门</a>，二分查找法还可以用于部分有序数组中元素的查找。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution-new/0035/154.png" alt="LeetCode 第 154 题"></p><p>说明：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/description/" target="_blank" rel="noopener">传送门</a>。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution-new/0035/287.png" alt="LeetCode 第 287 题"></p><p>说明：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">传送门</a>，这道题是对“数”作二分，而不是对索引做二分，具体可以参考我写的题解<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/" target="_blank" rel="noopener">《二分法（Python 代码、Java 代码）》</a>。</p><p><img src="https://liweiwei1419.github.io/images/leetcode-solution-new/0035/1095.png" alt="LeetCode 第 1095 题"></p><p>说明：<a href="https://leetcode-cn.com/problems/find-in-mountain-array/submissions/" target="_blank" rel="noopener">传送门</a>。这道题很有意思，做这一道题等于做了 3 道二分查找的问题，并且，你还会发现，这 3 个二分查找的问题写出来的分支都是一样的，因此它们选中位数的时候，都选择了左中位数。</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 23 题：合并 K 个排序链表（困难）</title>
      <link href="/leetcode-algo/2017/05/19/leetcode-algo/0034-find-first-and-last-position-of-element-in-sorted-array/"/>
      <url>/leetcode-algo/2017/05/19/leetcode-algo/0034-find-first-and-last-position-of-element-in-sorted-array/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-34-题：排序数组查找首、末位置（简单）"><a href="#「力扣」第-34-题：排序数组查找首、末位置（简单）" class="headerlink" title="「力扣」第 34 题：排序数组查找首、末位置（简单）"></a>「力扣」第 34 题：排序数组查找首、末位置（简单）</h2><ul><li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/" target="_blank" rel="noopener">题解链接（含视频题解）</a></li></ul><blockquote><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 $O(\log n)$ 级别。</p><p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p><p>示例 1：</p><pre><code>输入: nums = [5, 7, 7, 8, 8, 10], target = 8输出: [3, 4]</code></pre><p>示例 2：</p><pre><code>输入: nums = [5, 7, 7, 8, 8, 10], target = 6输出: [-1, -1]</code></pre></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>如果当前看到的中间元素的数值恰好等于目标元素，应该<strong>继续使用二分查找</strong>，查找它第一次出现和最后一次出现的位置，不可以线性地去扫描。</p></blockquote><h3 id="方法一：暴力求解（Brute-Force）"><a href="#方法一：暴力求解（Brute-Force）" class="headerlink" title="方法一：暴力求解（Brute Force）"></a>方法一：暴力求解（Brute Force）</h3><blockquote><p>该方法大家都会，可以跳过。</p></blockquote><p>很容易想到的一个方法是暴力解法，我们只需要从头到尾遍历一次数组，就能够找到目标元素出现的第一个位置和最后一个位置。根据题意，我们想象最一般的那种情况，先遇到的数都是严格小于 <code>target</code>，然后遇到的数都等于 <code>target</code>，最后遇到的数都严格大于  <code>target</code>。</p><ul><li>因此，我们可以在遍历的开始，检查遍历到的元素是否等于  <code>target</code> ，遇到刚好等于 <code>target</code> 的时候，记录当前的位置；</li><li>然后接着遍历，检查遍历到的元素是否不等于  <code>target</code> ，遇到刚好不等于 <code>target</code> 的时候，记录当前位置的前一个位置即可。</li></ul><p>这个算法的时间复杂度是 $O(N)$，不符合题目的要求。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">searchRange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> targetRange <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> targetRange<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                targetRange<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 连第 1 个位置都没有找到，说明已经遍历完整个数组了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetRange<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> targetRange<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> targetRange<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                targetRange<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>targetRange<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            targetRange<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> targetRange<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码讲解</strong>：</p><ul><li>首先新建一个有两个元素的整型数组 <code>targetRange</code>，初始化的值为 <code>[-1, -1]</code>，然后把数组的长度赋值成一个变量 <code>len</code>，当数组的长度等于 <code>0</code> 的时候，直接返回 <code>targetRange</code>；</li><li>然后从下标为 <code>0</code> 的地方开始遍历，只要找到了等于 <code>target</code> 的元素，就将 <code>targetRange</code> 下标为 <code>0</code> 的那个元素赋值为 <code>i</code> ，然后退出循环；</li><li>这里要注意的一点是：如果在整个遍历的过程中， <code>targetRange[0]</code> 都没有被重新赋值，那就说明目标元素 <code>target</code> 在有序数组 <code>nums</code> 中并不存在，依然将   <code>targetRange</code> 返回即可；</li><li>接着我们从目标元素第一次出现的位置  <code>targetRange[0]</code>  的下一个位置开始遍历，只要检测到元素不等于  <code>target</code> ，记录它的前一个位置，即将  <code>targetRange[1]</code> 赋值为 <code>i - 1</code> ，然后就可以退出循环；</li><li>还要注意的一个细节是，如果目标元素刚好在有序数组的最后一个位置，其实这个循环体是根本没有办法执行的，因此，可以在最后做一个判断，如果  <code>targetRange[1]</code>  还没有被赋值，就把它赋值为数组中最后一个位置。</li></ul><h3 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h3><p>下面我们看一下如何使用二分查找，找到目标元素在有序数组中的开始位置和结束位置。</p><ul><li><p>二分查找法的基本思想是：在一个区间范围里看处在中间位置的元素的值 <code>nums[mid]</code> 与目标元素 <code>target</code> 的大小关系，进而决定目标值落在哪一个部分里；</p></li><li><p>对于这道题，与常见的二分查找问题最大的不同就在于，目标元素  <code>target</code> 在有序数组中很可能存在多个；</p></li><li><p>而当我们使用二分查找方法看到的处在中间位置的元素的值 <code>nums[mid]</code> 恰好等于目标元素  <code>target</code> 的时候，还需要继续查找下去，而此时比较容易陷入的误区是线性查找，正确的做法是继续二分查找；</p></li><li><p>很显然，目标元素第 1 次出现的位置一定不可能是严格小于 <code>target</code> 的元素的位置，根据之前暴力解法的分析，目标元素第 1 次出现的位置是严格小于 <code>target</code> 的元素的位置的边界，因此，我们可以通过这个思路使用二分法找到这个边界；</p></li><li><p>对称地，目标元素最后 1 次出现的位置一定不可能是严格大于 <code>target</code> 的元素的位置，目标元素最后 1 次出现的位置是严格大于 <code>target</code> 的元素的位置的边界，因此，我们可以通过这个思路使用二分法找到这个边界。</p></li></ul><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">searchRange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> firstPosition <span class="token operator">=</span> <span class="token function">findFirstPosition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstPosition <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> lastPosition <span class="token operator">=</span> <span class="token function">findLastPosition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>firstPosition<span class="token punctuation">,</span> lastPosition<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findFirstPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 小于一定不是解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findLastPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 大于一定不是解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [left, mid - 1]</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码讲解</strong>：</p><ul><li><p>首先依然是将数组的长度赋值给一个变量 <code>len</code>；</p></li><li><p>然后做一个特判：当数组的长度为 <code>0</code> 的时候，直接返回 <code>[-1 , -1]</code>；</p></li><li><p>接下来我们先二分查找 <code>target</code> 第 1 次出现的位置，我们把它封装成一个私有方法 <code>findFirstPosition</code>：</p><ul><li>分别初始化左边界 <code>left = 0</code>  和右边界 <code>right = len - 1</code> ，表示待搜索区间的左右边界；</li><li>接下来不断地二分查找目标元素，我们把循环可以继续的条件写成 <code>while (left &lt; right)</code> ，注意这里写成严格小于，这是一种比较常见的写法，它的思路是把符合条件的元素放在最后做判断，好处是在退出循环的时候一定有 <code>left == right</code> 成立，我们就不用考虑到底应该返回 <code>left</code> 还是返回 <code>right</code> 了。但是这种写法有几个要注意的地方，我们马上会提到。</li><li>然后是计算中间位置下标的代码 <code>int mid = left + (right - left) / 2;</code></li><li>根据刚才的分析，当 <code>nums[mid] &lt; target</code> 的时候，<code>mid</code> 以及 <code>mid</code> 左边的所有元素一定不是 <code>target</code> 出现的第 1 个位置，因此下一轮搜索的元素就一定在 <code>[mid + 1, right]</code> 中，因此，将左边界设置为 <code>mid + 1</code>；</li><li>接下来是 <code>nums[mid] &lt; target</code> 的反面， <code>nums[mid] &gt;= target</code> ，此时搜索的区间是 <code>if</code> 这个分支搜索区间的反面，即 <code>[left, mid]</code> ，我们来验证一下：如果我们看到一个数严格大于 <code>target</code> ， <code>target</code> 出现的第 1 个位置一定出现在这个数的左边；如果我们看到一个数恰好等于 <code>target</code> ，它有可能就是出现的第 1 个位置，也有可能 <code>target</code> 出现的第 1 个位置在它左边，但是一定不会在这个位置右边，因此，下一轮搜索的区间是  <code>[left, mid]</code> 是没有问题的，此时需要设置右边界 <code>right = mid</code>；</li><li>在退出循环的时候，还有一个下标的元素 <code>left</code>（或者说是 <code>right</code> 此时它们的值相等）没有看到，因为题目中说，目标元素有可能在数组中并不存在，因此，需要单独再做一次判断，这一步叫做后处理。</li><li>如果 <code>nums[left] == target</code> ，下标位置 <code>left</code> 就是 <code>target</code> 第 1 次出现的位置，否则返回 <code>-1</code>。</li></ul></li><li><p>对称地，我们来写查找 <code>target</code> 最后 1 次出现的位置的代码。</p><ul><li><p>首先可以确定的是，如果在查找 <code>target</code> 第 1 次出现的位置的时候，我们都没有找到  <code>target</code> ，在查找 <code>target</code>  最后一次出现的位置的时候，我们肯定也不会找到这个数，因此可以先做一个特殊的判断；</p></li><li><p><code>findLastPosition</code> 的结构和 <code>findFirstPosition</code> 很像，我们直接复制下来，需要更改的是 <code>if</code> 和 <code>else</code> 的逻辑，根据刚才的分析，当 <code>nums[mid] &gt; target</code> 的时候，<code>mid</code> 以及 <code>mid</code> 右边的所有元素一定不是 <code>target</code> 出现的最后 1 个位置，因此下一轮搜索的元素就一定在 <code>[left, mid - 1]</code> 中，因此，将右边界设置为 <code>mid - 1</code>；</p></li><li><p>接下来是 <code>nums[mid] &gt; target</code> 的反面， <code>nums[mid] &lt;= target</code> ，此时搜索的区间是 <code>if</code> 这个分支搜索区间的反面，即 <code>[mid, right]</code> ，我们来验证一下：如果我们看到一个数严格小于 <code>target</code> ， <code>target</code> 出现的最后 1 个位置一定出现在这个数的右边；如果我们看到一个数恰好等于 <code>target</code> ，它有可能就是出现的最后 1 个位置，也有可能 <code>target</code> 出现的最后 1 个位置在它右边，但是一定不会在这个位置左边，因此，下一轮搜索的区间是 <code>[mid, right]</code>  是没有问题的，此时需要设置左边界 <code>left = mid</code>；</p></li><li><p>此时要特别注意的一点是：一旦看到  <code>left = mid</code> 与 <code>right = mid - 1</code> 这种在二分搜索中边界收缩的行为，我们需要在取中间数的时候，做一些小的调整，那就是在这个括号里加 1：<code>int mid = left + (right - left + 1) / 2;</code></p></li><li><p>原因是这样的：<code>/</code> 是整数除法，它默认的取整行为是向下取整，即 <code>(3 + 4) / 2 = 3</code>。当我们使用原来写法的时候，<code>mid</code> 永远取不到 <code>right</code>，而边界收缩是  <code>left = mid</code> 与 <code>right = mid - 1</code> 的时候，我们画一个示意图，它是这样的，当待搜索区间只有 2 个元素的时候，由于中间数永远取不到右边，我们发现区间分不开，此时，一旦代码执行到这一个分支，无论是左边界还是右边界都不会向中间考虑，此时代码进入死循环；</p></li><li><p>要想解决这个问题，其实刚刚我已经说了，需要把取中间数时候整数除法的下取整行为改成上取整，即在括号里加 <code>1</code>，虽然这种取整行为的改变只需要在最后只剩 2 个元素的时候做出，但是我们全程就让它上取整也是没有问题的；</p></li><li><p>这一条是一个经验总结，也是人们在使用的过程中逐渐总结出来的，其实这个处理也不难发现，我们只需要在出现死循环的时候，在程序中打印出 <code>left</code> 、<code>right</code> 和 <code>mid</code> 的取值，就很容易发现问题并想到解决的办法；</p></li><li><p>在退出循环的时候，这里依然是还有一个下标的元素 <code>left</code>（或者说是 <code>right</code> 此时它们的值相等）没有看到。但是我们注意到，其实代码能够执行到这里，是不是说明，<code>target</code> 在 <code>nums</code> 中一定存在，看一看我们之前的判断。因此，我们就没有必要在判断  <code>nums[left]</code> 是否等于 <code>target</code>，此时 <code>left</code>的值就一定是 <code>target</code> 在有序数组 <code>nums</code> 中最后 1 次出现的下标 。</p></li></ul></li></ul><p>调试代码：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">searchRange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> firstPosition <span class="token operator">=</span> <span class="token function">findFirstPosition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstPosition <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> lastPosition <span class="token operator">=</span> <span class="token function">findLastPosition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>firstPosition<span class="token punctuation">,</span> lastPosition<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findLastPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"left = "</span> <span class="token operator">+</span> left <span class="token operator">+</span> <span class="token string">", mid = "</span> <span class="token operator">+</span> mid <span class="token operator">+</span> <span class="token string">", right = "</span> <span class="token operator">+</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 严格大于 target 的时候不是解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索的区间是 [left, mid - 1]</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"下一轮搜索的区间是 [left, mid - 1]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"下一轮搜索的区间是 [mid, right]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// [mid, right]</span>                left <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">findFirstPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 严格小于 target 的时候不是解</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一轮搜索的区间是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(\log N)$，这里 $N$ 是数组的长度，两个子问题都是二分查找，因此时间复杂度为对数级别。</li><li>空间复杂度：$O(1)$，只使用了常数个数的辅助变量、指针。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 33 题：搜索旋转排序数组（中等）</title>
      <link href="/leetcode-algo/2017/05/18/leetcode-algo/0033-search-in-rotated-sorted-array/"/>
      <url>/leetcode-algo/2017/05/18/leetcode-algo/0033-search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-33-题：搜索旋转排序数组（中等）"><a href="#「力扣」第-33-题：搜索旋转排序数组（中等）" class="headerlink" title="「力扣」第 33 题：搜索旋转排序数组（中等）"></a>「力扣」第 33 题：搜索旋转排序数组（中等）</h2><ul><li><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">链接</a></p></li><li><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/" target="_blank" rel="noopener">题解链接</a></p></li></ul><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 <code>[0, 1, 2, 4, 5, 6, 7]</code> 可能变为 <code>[4, 5, 6, 7, 0, 1, 2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 $O(\log n)$ 级别。</p><p>示例 1：</p><pre><code>输入: nums = [4, 5, 6, 7, 0, 1, 2], target = 0输出: 4</code></pre><p>示例 2：</p><pre><code>输入: nums = [4, 5, 6, 7, 0, 1, 2], target = 3输出: -1</code></pre></blockquote><h3 id="方法一：暴力法（Brute-Force）"><a href="#方法一：暴力法（Brute-Force）" class="headerlink" title="方法一：暴力法（Brute Force）"></a>方法一：暴力法（Brute Force）</h3><p>无视题目“你的算法时间复杂度必须是 $O(\log n)$ 级别”这项要求，采用线性扫描的方式搜索。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，这里 $N$ 是数组的长度。</li><li>空间复杂度：$O(1)$，使用到的临时变量的个数是常数。</li></ul><h3 id="方法二：二分查找（Binary-Search）"><a href="#方法二：二分查找（Binary-Search）" class="headerlink" title="方法二：二分查找（Binary Search）"></a>方法二：二分查找（Binary Search）</h3><p>题目中说：“你的算法时间复杂度必须是 $O(\log n)$ 级别”，暗示我们可以使用二分查找算法。题目中还说说：“<strong>你可以假设数组中不存在重复的元素</strong>”。</p><p>可以根据示例 <code>[4, 5, 6, 7, 0, 1, 2]</code> ，自己手写几个旋转数组。不难发现：将待搜索区间从中间一分为二，<strong><code>mid</code> 位置一定会落在其中一个有序区间里</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dk987cj0j310b0u0div.jpg" alt="image-20191128101416746"></p><ul><li>由于题目不允许我们逐个扫描，因此待搜索区间的第 1 个下标、最后一个下标、中间下标就很重要；</li><li>事实上，我们很容易能够根据中间下标的元素值和第 1 个下标（或者最后一个下标）的元素的值判断 <code>mid</code> 落在哪个有序的区间里。</li></ul><p>还可以这样理解：</p><ul><li>中间元素把待搜索区间分成了两部分，两部分具有的性质是至少有一部分是有序的；</li></ul><p>我们不妨讨论中间元素和右边界的关系（其它情况类似），因为不存在重复元素，所以它们的关系不是大于就是小于。</p><p><strong>情况 1</strong>：<code>nums[mid] &lt; nums[right]</code>，当中间元素的数值严格小于右边界的数值时候</p><p>1、此时区间  <code>[mid, right]</code> （表示左闭右闭，下同）一定是有序的；</p><p>2、因为 <code>target</code> 要么在有序区间   <code>[mid, right]</code> 里，要么在另一个区间   <code>[left, mid - 1]</code> 里。</p><p>（1）显然在有序区间   <code>[mid, right]</code> 里的条件好写，即：  <code>nums[mid] &lt;= target &lt;= nums[right]</code>。因为 <code>target</code> 落在其中，所以能且只能等于其中的一个元素，当然包括头尾，此时设置 <code>left = mid</code>；</p><p>（2）落在另一个区间 <code>[left, mid - 1]</code> 里的时候，就是上一个情况的反面，这种情况用 <code>else</code> 表示即可，此时设置 <code>right = mid - 1</code> 是显然的。</p><blockquote><p><strong>关键</strong>：把比较好些的判断（<code>target</code> 落在有序的那部分）放在 <code>if</code> 的开头考虑，把剩下的情况放在 <code>else</code> 里面。</p></blockquote><p>同理，讨论 <code>nums[mid] &lt; nums[right]</code> 的反面（下面我的描述基本就是反过来讲的）。</p><p><strong>情况 2</strong>：<code>nums[mid] &gt; nums[right]</code>，当中间元素的数值严格小于右边界的数值时候，因为没有重复元素，所以是严格大于</p><p>1、此时区间  <code>[left, mid - 1]</code> 内的元素一定是有序的；</p><p>2、因为 <code>target</code> 要么在有序区间   <code>[left, mid - 1]</code> 里，要么在另一个区间   <code>[mid, right]</code> 里。</p><p>（1）显然在有序区间   <code>[left, mid - 1]</code> 里的条件好写，即：  <code>nums[left] &lt;= target &lt;= nums[mid - 1]</code>。因为 <code>target</code> 落在其中，所以能且只能等于其中的一个元素，当然包括头尾，此时设置 <code>right = mid - 1</code>；</p><p>（2）落在另一个区间 <code>[mid, right]</code> 里的时候，就是上一个情况的反面，这种情况用 <code>else</code> 表示即可，此时设置 <code>left = mid</code> 是显然的。</p><blockquote><p>这里特别巧，情况 1 和情况 2 边界的收缩正好吻合。都是 <code>left = mid</code> 与 <code>right = mid - 1</code>。因此选中间数的时候就得上取整，即  <code>int mid = (left + right + 1) &gt;&gt;&gt; 1</code>。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dk95gjojj30uk0bet9g.jpg" alt="image-20191128103723984"></p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 使用上取整的中间数，必须在上面的 mid 表达式的括号里 + 1</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [mid, right]</span>                    left <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 只要上面对了，这里不用思考，可以一下子写出来</span>                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// [left, mid] 有序，但是为了和上一个 if 有同样的收缩行为，</span>                <span class="token comment" spellcheck="true">// 我们故意只认为 [left, mid - 1] 有序</span>                <span class="token comment" spellcheck="true">// 当区间只有 2 个元素的时候 int mid = (left + right + 1) >>> 1; 一定会取到右边</span>                <span class="token comment" spellcheck="true">// 此时 mid - 1 不会越界，就是这么刚刚好</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [left, mid - 1]</span>                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    left <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 有可能区间内不存在目标元素，因此还需做一次判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(\log N)$，这里 $N$ 是数组的长度，在循环中一次排除一半，因此时间复杂度是对数级别的；</li><li>空间复杂度：$O(1)$，使用到的临时变量的个数是常数。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「力扣」第 4 题：寻找两个有序数组的中位数（困难）</title>
      <link href="/leetcode-algo/2017/05/17/leetcode-algo/0004-median-of-two-sorted-arrays/"/>
      <url>/leetcode-algo/2017/05/17/leetcode-algo/0004-median-of-two-sorted-arrays/</url>
      
        <content type="html"><![CDATA[<h2 id="「力扣」第-4-题：寻找两个有序数组的中位数（困难）"><a href="#「力扣」第-4-题：寻找两个有序数组的中位数（困难）" class="headerlink" title="「力扣」第 4 题：寻找两个有序数组的中位数（困难）"></a>「力扣」第 4 题：寻找两个有序数组的中位数（困难）</h2><p>来源：力扣（LeetCode）</p><ul><li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">链接</a></li><li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/" target="_blank" rel="noopener">题解链接</a></li></ul><blockquote><p>给定两个大小为 <code>m</code> 和 <code>n</code> 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 $O(\log(m + n))$。</p><p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p><p>示例 1：</p><pre><code>nums1 = [1, 3]nums2 = [2]则中位数是 2.0</code></pre><p>示例 2：</p><pre><code>nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3) / 2 = 2.5</code></pre></blockquote><h3 id="方法一：根据定义，合并、排序以后取中位数（时间复杂度不符合要求）"><a href="#方法一：根据定义，合并、排序以后取中位数（时间复杂度不符合要求）" class="headerlink" title="方法一：根据定义，合并、排序以后取中位数（时间复杂度不符合要求）"></a>方法一：根据定义，合并、排序以后取中位数（时间复杂度不符合要求）</h3><p>这应该是最简单直接的做法，即根据定义来做。考虑如下两种情况：</p><p>情况 1：如果合并以后的数组的长度是偶数，中位数有 2 个，此时取它们的平均值； </p><p>情况 2：如果合并以后的数组的长度是奇数；中位数有 1 个，把这个值返回即可。</p><p>说明：这个解法虽然不符合题目要求，但是是常规思路。<strong>并且它的优点也很显著：即在输入数组不是有序数组的时候，这个算法依然有效，因此如果这一题出现在面试中，向面试官提到这个最简单的思路，我觉得也是有必要的（一定要把它的这个优点连带说出来）</strong>。</p><p><strong>参考代码 1</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> merge <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> merge<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> merge<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>merge<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> merge<span class="token punctuation">[</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>merge<span class="token punctuation">[</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> merge<span class="token punctuation">[</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        m <span class="token operator">=</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>        nums1<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>        nums1<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> nums1<span class="token punctuation">[</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums1<span class="token punctuation">[</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O((M + N) \log (M + N))$，这里 $M$ 是数组 nums1 的长度，$N$ 是数组 nums2 的长度。</li><li>空间复杂度：$O(M+ N)$。</li></ul><p><strong>分析</strong>：</p><p>优点：</p><p>1、简单、直接，编码出错的概率低； </p><p>2、在输入数组是非有序数组的时候，算法依然有效。</p><p>缺点：  </p><p>1、空间复杂度高：这个算法连排序都做好了，得使用两个数组的长度之和的空间；  </p><p>2、时间复杂度高：得看完所有的两个数组的数。</p><hr><p>根据以上分析的两个缺点，在思路上我们有如下优化：我们可以不用拼在一起再排序，使用“归并排序的子过程”也可以得到一个更长的有序数组，从而得到这个更长的有序数组的中位数。</p><p>可以在<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">「力扣」第 88 题：合并两个有序数组</a>的题解<a href="https://leetcode-cn.com/problems/merge-sorted-array/solution/si-xiang-mei-you-chuang-xin-de-di-fang-zhu-yao-ti-/" target="_blank" rel="noopener">《思路没有创新的地方，主要提供逻辑清楚的代码和编码细节（Python 代码、Java 代码）》</a>中看到如何归并两个有序数组。不过我们没有必要搞一个新数组真的去合并，<strong>设置两个指针在数组上移动即可</strong>。仔细思考过后，还发现实际上没有必要“归并”完全，在归并的时候，我们只要看完排在前面的一半的数就可以了。</p><h3 id="方法二：使用“归并排序”的子过程（时间复杂度不符合要求）"><a href="#方法二：使用“归并排序”的子过程（时间复杂度不符合要求）" class="headerlink" title="方法二：使用“归并排序”的子过程（时间复杂度不符合要求）"></a>方法二：使用“归并排序”的子过程（时间复杂度不符合要求）</h3><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-0.png" alt="4-0.png"></p><p>数组长度之和是奇数的时候，要看到索引为 $\cfrac{m - 1}{2}$ 的这个数， 数组长度之和是偶数时，要看到索引为 $\cfrac{m}{2}$ 的这个数。</p><p>有两种思路：</p><ul><li>思路1（不采用）：</li></ul><p>不管长度之和是奇数还是偶数，直接先看到索引为 $\cfrac{m - 1}{2}$ 的这个数，如果是奇数，就可以返回了，如果是偶数，再往下看一个数；</p><p>编码的时候，发现，会有一些冗余的代码，并且要考虑一些边界的问题，例如看索引为 $\cfrac{m}{2}$ 的数的时候，可能 nums1 和 nums2 其中之一已经看完。</p><ul><li>思路2（采用）：</li></ul><p>那么不管奇数偶数，我都看到索引为 $\cfrac{m}{2}$ 的这个数，那么索引为 $\cfrac{m - 1}{2}$ 的这个数肯定看过了。</p><p>技巧：</p><p>1、我只关心最近看到的这两个数，那么我不妨将它们放置在一个长度为 $2$ 的数组中，使用计数器模 $2$ 的方式计算索引（这个技巧貌似叫做“滚动变量”），这样空间复杂度就可以降到常数。</p><p>2、在编码的时候，使用 <code>counter</code> 这个指针表示最后一次赋值的那个索引，初始化的时候，应该为 $-1$，在每一次循环开始之前 <code>++</code> 。</p><p><strong>参考代码 2</strong>：</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 最后要找到合并以后索引是 median_index 的这个数</span>        <span class="token keyword">int</span> medianIndex <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计数器从 -1 开始，在循环开始之前加 1</span>        <span class="token comment" spellcheck="true">// 这样在退出循环的时候，counter 能指向它最后赋值的那个元素</span>        <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// nums1 的索引</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// nums2 的索引</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>counter <span class="token operator">&lt;</span> medianIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            counter<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 先写 i 和 j 遍历完成的情况，否则会出现数组下标越界</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>counter <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>counter <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>counter <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>counter <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果 m + n 是奇数，median_index 就是我们要找的</span>        <span class="token comment" spellcheck="true">// 如果 m + n 是偶数，有一点麻烦，要考虑其中有一个用完的情况，其实也就是把上面循环的过程再进行一步</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">[</span>counter <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        m <span class="token operator">=</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 最后要找到合并以后索引是 median_index 的这个数</span>        median_index <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># nums1 的索引</span>        i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># nums2 的索引</span>        j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 计数器从 -1 开始，在循环开始之前加 1</span>        <span class="token comment" spellcheck="true"># 这样在退出循环的时候，counter 能指向它最后赋值的那个元素</span>        counter <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> counter <span class="token operator">&lt;</span> median_index<span class="token punctuation">:</span>            counter <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 先写 i 和 j 遍历完成的情况，否则会出现数组下标越界</span>            <span class="token keyword">if</span> i <span class="token operator">==</span> m<span class="token punctuation">:</span>                res<span class="token punctuation">[</span>counter <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> j <span class="token operator">==</span> n<span class="token punctuation">:</span>                res<span class="token punctuation">[</span>counter <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token punctuation">[</span>counter <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">[</span>counter <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># print(res)</span>            <span class="token comment" spellcheck="true"># 每一次比较，不论是 nums1 中元素出列，还是 nums2 中元素出列</span>            <span class="token comment" spellcheck="true"># 都会选定一个数，因此计数器 + 1</span>        <span class="token comment" spellcheck="true"># 如果 m + n 是奇数，median_index 就是我们要找的</span>        <span class="token comment" spellcheck="true"># 如果 m + n 是偶数，有一点麻烦，要考虑其中有一个用完的情况，其实也就是把上面循环的过程再进行一步</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> res<span class="token punctuation">[</span>counter <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> sum<span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(M + N)$，这里 $M$ 是数组 nums1 的长度，$N$ 是数组 nums2 的长度，看了数组长度之和的一半，常数系数视为 $1$。</li><li>空间复杂度：$O(1)$，这里候选值数组 <code>res</code> 只占 $2$ 个空间，用到的其它辅助变量也只有常数个。</li></ul><hr><p>接下来的这个思路是符合题目对时间复杂度要求的，但是我个人觉得偏难。它的优点当然在于时间复杂度低，能够很快胜任，但这个算法不一定好。</p><p>1、编码较困难，得考虑清楚不同的边界情况，因此编码出错的概率很高；</p><p>2、调试困难，出了什么问题，自己调试起来也未必很快就能找到原因，尤其是在一些边界条件的时候（这道题的边界条件在下面这个 PPT 的第 5 张，我画了 6 张图）；</p><p>3、相对于方法一：在输入数组如果不是有序数组的话，该算法失效。</p><p>因此，也不是非常好的算法，处处都“碾压”一个看起来比较不怎样的算法，简单、好想的算法也有它的用武之地，<strong>要针对具体的场景选择使用不同的方法</strong>。</p><p>下面这个方法是我看了很多朋友的题解，最终在 <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/solution/" target="_blank" rel="noopener">LeetCode 的英文版的官方题解</a>一个评论里看到的思路和代码，思路我是用自己的话写了出来，希望能够对大家有所帮助。</p><p>思路很简单，找两个有序数组的分割。编码上有一点点技巧，特别是在处理边界条件的时候。</p><p>我个人觉得这样的问题看别人的题解的时候，先看个大概，懂得大致的思路，这相当于接受了他人的提示，然后尝试自己编码能不能做出来。<strong>然后还有一点是很重要的，很多算法题我都是得在纸上打个草稿，才能把思路和边界条件想清楚明白，所以一定不能偷懒</strong>。 </p><h3 id="方法三：使用二分法找两个数组的“边界线”"><a href="#方法三：使用二分法找两个数组的“边界线”" class="headerlink" title="方法三：使用二分法找两个数组的“边界线”"></a>方法三：使用二分法找两个数组的“边界线”</h3><p>（温馨提示：下面的幻灯片建议您点击右下角的前进 “▶|” 或者后退 “|◀” 按钮以控制播放。）</p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-binary-search-1.png" alt="4-1.png"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-binary-search-2.png" alt="4-2.png"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-binary-search-3.png" alt="4-3.png"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-binary-search-4.png" alt="4-4.png"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-binary-search-5.png" alt="4-5.png"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-binary-search-6.png" alt="4-6.png"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-binary-search-7.png" alt="4-7.png"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-binary-search-8.png" alt="4-8.png"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-binary-search-9.png" alt="4-9.png"></p><p><img src="https://liweiwei1419.gitee.io/images/leetcode-solution-new/0004/4-binary-search-10.png" alt="4-10.png"></p><p><strong>参考代码 3</strong>：使用<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/" target="_blank" rel="noopener">《“神奇的”二分查找法模板》</a>写出的代码，使用这个模板会快一点点，但是用不好的话，比较容易采坑，如果不熟悉这个模板的朋友，可以直接跳到“参考代码 4”。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 为了让搜索范围更小，我们始终让 num1 是那个更短的数组，PPT 第 9 张</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">.</span>length <span class="token operator">></span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> nums1<span class="token punctuation">;</span>            nums1 <span class="token operator">=</span> nums2<span class="token punctuation">;</span>            nums2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 上述交换保证了 m &lt;= n，在更短的区间 [0, m] 中搜索，会更快一些</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用二分查找算法在数组 nums1 中搜索一个索引 i，PPT 第 9 张</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里使用的是最简单的、"传统"的二分查找法模板，使用"高级的"二分查找法模板在退出循环时候处理不方便</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 尝试要找的索引，在区间里完成二分，为了保证语义，这里就不定义成 mid 了</span>            <span class="token comment" spellcheck="true">// 用加号和右移是安全的做法，即使在溢出的时候都能保证结果正确，但是 Python 中不存在溢出</span>            <span class="token comment" spellcheck="true">// 参考：https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// j 的取值在 PPT 第 7 张</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 边界值的特殊取法的原因在 PPT 第 10 张</span>            <span class="token keyword">int</span> nums1LeftMax <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MIN_VALUE <span class="token operator">:</span> nums1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> nums1RightMin <span class="token operator">=</span> i <span class="token operator">==</span> m <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> nums2LeftMax <span class="token operator">=</span> j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MIN_VALUE <span class="token operator">:</span> nums2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> nums2RightMin <span class="token operator">=</span> j <span class="token operator">==</span> n <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 交叉小于等于关系成立，那么中位数就可以从"边界线"两边的数得到，原因在 PPT 第 2 张、第 3 张</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1LeftMax <span class="token operator">&lt;=</span> nums2RightMin <span class="token operator">&amp;&amp;</span> nums2LeftMax <span class="token operator">&lt;=</span> nums1RightMin<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 已经找到解了，分数组之和是奇数还是偶数得到不同的结果，原因在 PPT 第 2 张</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums1LeftMax<span class="token punctuation">,</span> nums2LeftMax<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums1LeftMax<span class="token punctuation">,</span> nums2LeftMax<span class="token punctuation">)</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>nums1RightMin<span class="token punctuation">,</span> nums2RightMin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums2LeftMax <span class="token operator">></span> nums1RightMin<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这个分支缩短边界的原因在 PPT 第 8 张</span>                left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这个分支缩短边界的原因在 PPT 第 8 张</span>                right <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"传入无效的参数，输入的数组不是有序数组，算法失效"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 为了让搜索范围更小，我们始终让 num1 是那个更短的数组，PPT 第 9 张</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">></span> len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 这里使用了 pythonic 的写法，即只有在 Python，中可以这样写</span>            <span class="token comment" spellcheck="true"># 在一般的编程语言中，得使用一个额外变量，通过"循环赋值"的方式完成两个变量的地址的交换</span>            nums1<span class="token punctuation">,</span> nums2 <span class="token operator">=</span> nums2<span class="token punctuation">,</span> nums1        <span class="token comment" spellcheck="true"># 上述交换保证了 m &lt;= n，在更短的区间 [0, m] 中搜索，会更快一些</span>        m <span class="token operator">=</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 使用二分查找算法在数组 nums1 中搜索一个索引 i，PPT 第 9 张</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> m        <span class="token comment" spellcheck="true"># 因为 left_total 这个变量会一直用到，因此单独赋值，表示左边粉红色部分一共需要的元素个数</span>        left_total <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 尝试要找的索引，在区间里完成二分，为了保证语义，这里就不定义成 mid 了</span>            <span class="token comment" spellcheck="true"># 用加号和右移是安全的做法，即使在溢出的时候都能保证结果正确，但是 Python 中不存在溢出</span>            <span class="token comment" spellcheck="true"># 参考：https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/</span>            i <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span>            j <span class="token operator">=</span> left_total <span class="token operator">-</span> i            <span class="token comment" spellcheck="true"># 如果 nums1 左边最大值 > nums2 右边最小值</span>            <span class="token keyword">if</span> nums2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 这个分支缩短边界的原因在 PPT 第 8 张，情况 ①</span>                left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 这个分支缩短边界的原因在 PPT 第 8 张，情况 ②</span>                <span class="token comment" spellcheck="true"># 【注意】：不让它收缩的原因是讨论 nums1[i - 1] > nums2[j]，i - 1 在数组的索引位置，在 i = 0 时越界</span>                right <span class="token operator">=</span> i        <span class="token comment" spellcheck="true"># 退出循环的时候，交叉小于等于一定关系成立，那么中位数就可以从"边界线"两边的数得到，原因在 PPT 第 2 张、第 3 张</span>        i <span class="token operator">=</span> left        j <span class="token operator">=</span> left_total <span class="token operator">-</span> left        <span class="token comment" spellcheck="true"># 边界值的特殊取法的原因在 PPT 第 10 张</span>        nums1_left_max <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> nums1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        nums1_right_min <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> i <span class="token operator">==</span> m <span class="token keyword">else</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        nums2_left_max <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> nums2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        nums2_right_min <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> j <span class="token operator">==</span> n <span class="token keyword">else</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 已经找到解了，分数组之和是奇数还是偶数得到不同的结果，原因在 PPT 第 2 张</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> max<span class="token punctuation">(</span>nums1_left_max<span class="token punctuation">,</span> nums2_left_max<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>max<span class="token punctuation">(</span>nums1_left_max<span class="token punctuation">,</span> nums2_left_max<span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">(</span>nums1_right_min<span class="token punctuation">,</span> nums2_right_min<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考代码 4</strong>：使用“传统的”二分查找法模板写出的代码。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 为了让搜索范围更小，我们始终让 num1 是那个更短的数组，PPT 第 9 张</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">.</span>length <span class="token operator">></span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> nums1<span class="token punctuation">;</span>            nums1 <span class="token operator">=</span> nums2<span class="token punctuation">;</span>            nums2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 上述交换保证了 m &lt;= n，在更短的区间 [0, m] 中搜索，会更快一些</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用二分查找算法在数组 nums1 中搜索一个索引 i，PPT 第 9 张</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 因为 left_total 这个变量会一直用到，因此单独赋值，表示左边粉红色部分一共需要的元素个数</span>        <span class="token keyword">int</span> totalLeft <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 尝试要找的索引，在区间里完成二分，为了保证语义，这里就不定义成 mid 了</span>            <span class="token comment" spellcheck="true">// 用加号和右移是安全的做法，即使在溢出的时候都能保证结果正确，但是 Python 中不存在溢出</span>            <span class="token comment" spellcheck="true">// 参考：https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// j 的取值在 PPT 第 7 张</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> totalLeft <span class="token operator">-</span> i<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这个分支缩短边界的原因在 PPT 第 8 张，情况 ①</span>                left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 这个分支缩短边界的原因在 PPT 第 8 张，情况 ②</span>                <span class="token comment" spellcheck="true">// 【注意】：不让它收缩的原因是讨论 nums1[i - 1] > nums2[j]，i - 1 在数组的索引位置，在 i = 0 时越界</span>                right <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 退出循环的时候，交叉小于等于一定关系成立，那么中位数就可以从"边界线"两边的数得到，原因在 PPT 第 2 张、第 3 张</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> totalLeft <span class="token operator">-</span> left<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 边界值的特殊取法的原因在 PPT 第 10 张</span>        <span class="token keyword">int</span> nums1LeftMax <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MIN_VALUE <span class="token operator">:</span> nums1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nums1RightMin <span class="token operator">=</span> i <span class="token operator">==</span> m <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nums2LeftMax <span class="token operator">=</span> j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MIN_VALUE <span class="token operator">:</span> nums2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nums2RightMin <span class="token operator">=</span> j <span class="token operator">==</span> n <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 交叉小于等于关系成立，那么中位数就可以从"边界线"两边的数得到，原因在 PPT 第 2 张、第 3 张</span>        <span class="token comment" spellcheck="true">// 已经找到解了，分数组之和是奇数还是偶数得到不同的结果，原因在 PPT 第 2 张</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums1LeftMax<span class="token punctuation">,</span> nums2LeftMax<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums1LeftMax<span class="token punctuation">,</span> nums2LeftMax<span class="token punctuation">)</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>nums1RightMin<span class="token punctuation">,</span> nums2RightMin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 为了让搜索范围更小，我们始终让 num1 是那个更短的数组，PPT 第 9 张</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span> <span class="token operator">></span> len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 这里使用了 pythonic 的写法，即只有在 Python，中可以这样写</span>            <span class="token comment" spellcheck="true"># 在一般的编程语言中，得使用一个额外变量，通过"循环赋值"的方式完成两个变量的地址的交换</span>            nums1<span class="token punctuation">,</span> nums2 <span class="token operator">=</span> nums2<span class="token punctuation">,</span> nums1        <span class="token comment" spellcheck="true"># 上述交换保证了 m &lt;= n，在更短的区间 [0, m] 中搜索，会更快一些</span>        m <span class="token operator">=</span> len<span class="token punctuation">(</span>nums1<span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 使用二分查找算法在数组 nums1 中搜索一个索引 i，PPT 第 9 张</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> m        <span class="token comment" spellcheck="true"># 这里使用的是最简单的、"传统"的二分查找法模板</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 尝试要找的索引，在区间里完成二分，为了保证语义，这里就不定义成 mid 了</span>            <span class="token comment" spellcheck="true"># 用加号和右移是安全的做法，即使在溢出的时候都能保证结果正确，但是 Python 中不存在溢出</span>            <span class="token comment" spellcheck="true"># 参考：https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/</span>            i <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span>            j <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> i            <span class="token comment" spellcheck="true"># 边界值的特殊取法的原因在 PPT 第 10 张</span>            nums1_left_max <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> nums1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>            nums1_right_min <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> i <span class="token operator">==</span> m <span class="token keyword">else</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            nums2_left_max <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> nums2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>            nums2_right_min <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">if</span> j <span class="token operator">==</span> n <span class="token keyword">else</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># 交叉小于等于关系成立，那么中位数就可以从"边界线"两边的数得到，原因在 PPT 第 2 张、第 3 张</span>            <span class="token keyword">if</span> nums1_left_max <span class="token operator">&lt;=</span> nums2_right_min <span class="token operator">and</span> nums2_left_max <span class="token operator">&lt;=</span> nums1_right_min<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 已经找到解了，分数组之和是奇数还是偶数得到不同的结果，原因在 PPT 第 2 张</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> max<span class="token punctuation">(</span>nums1_left_max<span class="token punctuation">,</span> nums2_left_max<span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span>max<span class="token punctuation">(</span>nums1_left_max<span class="token punctuation">,</span> nums2_left_max<span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">(</span>nums1_right_min<span class="token punctuation">,</span> nums2_right_min<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>            <span class="token keyword">elif</span> nums1_left_max <span class="token operator">></span> nums2_right_min<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 这个分支缩短边界的原因在 PPT 第 8 张，情况 ②</span>                right <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 这个分支缩短边界的原因在 PPT 第 8 张，情况 ①</span>                left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'传入无效的参数，输入的数组不是有序数组，算法失效'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(\log(\min(M,N)))$，为了使得搜索更快，我们把更短的数组设置为 nums1 ，因为使用二分查找法，在它的长度的对数时间复杂度内完成搜索；</li><li>空间复杂度：$O(1)$，只使用了常数个的辅助变量。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「二分查找」专题二：在循环体内部排除元素</title>
      <link href="/leetcode-algo/2017/05/16/leetcode-solution/array2/"/>
      <url>/leetcode-algo/2017/05/16/leetcode-solution/array2/</url>
      
        <content type="html"><![CDATA[<h2 id="「二分查找」专题二：在循环体内部排除元素"><a href="#「二分查找」专题二：在循环体内部排除元素" class="headerlink" title="「二分查找」专题二：在循环体内部排除元素"></a>「二分查找」专题二：在循环体内部排除元素</h2><h3 id="从哪些元素一定不是目标元素考虑"><a href="#从哪些元素一定不是目标元素考虑" class="headerlink" title="从哪些元素一定不是目标元素考虑"></a>从哪些元素一定不是目标元素考虑</h3><p>做对这一类问题的思路是「排除法」。在本题解最开始其实已经介绍了，我们的思路是做排除法：具体是根据看到的 <code>mid</code> 位置的元素，排除掉不可能存在目标元素的区间，进而确定下一轮在可能存在目标元素的子区间。</p><p>具体做法是：</p><p>1、先把循环可以继续的条件写成 <code>while (left &lt; right)</code>。</p><p>在循环的过程中 <code>left</code> 不断右移，<code>right</code> 不断左移。从形式上看，退出循环的时候一定有 <code>left == right</code> 成立。此时要注意：<strong><code>left</code> （<code>right</code>） 这个位置的值可能程序还没有读取到，因此“有可能”需要再对 <code>left</code>（<code>right</code>） 这个位置的值是否是目标元素的值做一次判断</strong>。</p><p>2、写 <code>if</code> 和 <code>else</code> 语句的时候，思考当 <code>nums[mid]</code> 满足什么性质的时候，<code>mid</code> 不是解，进而接着判断 <code>mid</code> 的左边有没有可能是解，<code>mid</code> 的右边有没有可能是解。</p><p>说明：（1）做题的经验告诉我，“思考什么时候不是解”比较好想。生活中其实也是这样，我往往说不大清楚我想要什么，但是我很确定我不想要什么。</p><p>（2）此时 <code>mid</code> 作为待查找数组就分为两个区间，一个部分可能存在目标元素，一个部分一定不存在目标元素，<code>mid</code> 作为这两个区间的分界点。</p><p><strong>根据 <code>mid</code> 被分到左边区间还是右边区间，代码写出来只有以下 2 种（重难点）</strong>：</p><p><strong>边界收缩行为 1</strong>： <code>mid</code> 被分到左边。即区间被分成 <code>[left, mid]</code> 与 <code>[mid + 1, right]</code>，这里用“闭区间”表示区间端点可以取到，下同；</p><p>代码写出来是这样的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [mid + 1, right]，因此把左边界设置到 mid + 1 位置</span>    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 上面对了以后，不加思考，剩下的区间一定是 [left, mid]，因此左边界向右收缩到 mid 位置</span>    right <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：这里的 <code>check(mid)</code> 函数通常是一个表达式（例如上面的“参考代码 1”），在一些情况下有可能逻辑比较复杂，建议专门抽取成一个私有方法，以突显主干逻辑。</p><p><strong>边界收缩行为 2</strong>： <code>mid</code> 被分到右边。即区间被分成 <code>[left, mid - 1]</code> 与 <code>[mid, right]</code>；</p><p>同上，代码写出来是这样的（由于注释是对称的，这里省略，留给读者填充）：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    left <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、<strong>根据「边界收缩行为」修改取中间数的行为（重难点）</strong>。</p><p>先说一下中间数的取法。一般是这样的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种写法在绝大多数情况下没问题，但是在 <code>left</code> 和 <code>right</code> 特别大的场景中，<code>left + right</code> 会发生整形溢出，得到一个负数，<code>mid</code> 的值随之也是负数。改进的写法是：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这两种写法事实上没有本质的区别，在 <code>left</code> 和 <code>right</code> 都表示数组索引的时候，几乎不会越界，因为绝大多数情况下不会开那么长的数组。</p><p>这里有一个细节，<code>/</code> 是整除，它的行为是“向下取整”，造成了 <strong><code>int mid = (left + right) / 2</code> 这种写法 <code>mid</code> 永远取不到带搜索区间里最右边的位置</strong>（读者可以举一个只有 <code>2</code> 个元素的子数组，理解这句话）。</p><p>面对上面的“<strong>边界收缩行为 2</strong>”（<code>mid</code> 被分到右边），在待搜索区间收缩到只剩下 2 个元素的时候，<strong>就有可能</strong>（请读者在练习的过程中体会这里我的描述为什么是“有可能”而不是“一定”）造成死循环。如下图：</p><p><img src="https://pic.leetcode-cn.com/eda3857e94d6ead3ed2d2f473fdaf8eaa1252a481e3220511d3a89e4d2f112ac-LeetCode%20%E7%AC%AC%2035%20%E9%A2%98%EF%BC%9A%E2%80%9C%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%E2%80%9D.png" alt="LeetCode 第 35 题：“搜索插入位置”.png"></p><p>注意：</p><blockquote><p>当待搜索区间<strong>只剩下</strong> $2$ 个元素的时候，才有可能会进入死循环。如果读者不太明白，可以暂时先不去理解这一点，直到编码过程中，出现死循环的时候，再去调试就很清楚了。</p></blockquote><p>有了上面的分析，我们把上面「边界收缩行为」对应的中间数取法补上：</p><p><strong>边界收缩行为 1</strong>： <code>mid</code> 被分到左边。即区间被分成 <code>[left, mid]</code> 与 <code>[mid + 1, right]</code>，此时取中间数的时候下取整。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [mid + 1, right]</span>    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    right <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>边界收缩行为 2</strong>： <code>mid</code> 被分到右边。即区间被分成 <code>[left, mid - 1]</code> 与 <code>[mid, right]</code>，此时取中间数的时候<strong>上取整</strong>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 下一轮搜索区间是 [left, mid - 1]</span>    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    left <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我可能没有说得很清楚。如果读者不太明白，也没有关系，读者在练习的过程中，如果遇到死循环，可以在 <code>while</code> 循环里把 <code>left</code>、<code>right</code>、<code>mid</code> 变量的值打印出来看，就看得很清楚了。</p><p><strong>遇到几次死循环，调试正确以后</strong>，就能很清楚地记住：</p><blockquote><p><strong>在 <code>if</code> <code>else</code> 语句里面只要出现 <code>left = mid</code> 的时候，把去中间数行为改成上取整即可。</strong></p></blockquote><p>这里有一个比较细节的地方：在 Java 中，有一种特殊的语法，叫无符号右移 <code>&gt;&gt;&gt;</code>。我在使用 Java 语言答题的时候，取中间数都写成 <code>int mid = (left + right) &gt;&gt;&gt; 1</code> 和  <code>int mid = (left + right + 1) &gt;&gt;&gt; 1</code> ，这是因为无符号右移 <code>&gt;&gt;&gt;</code> 在对操作数右移以后，不论这个数是正数还是负数，高位一律补 <code>0</code>。使用无符号右移的好处是：<strong>即使在 <code>left + right</code> 整形溢出以后，得到的结果依然正确</strong>。这一点是从 JDK 的源码中借鉴来的（<code>Arrays.binarySearch()</code> 方法）。</p><p>在 Python 中虽然没有无符号右移，但是也可以使用 <code>&gt;&gt;</code>，因为 Python 在 <code>left + right</code> 整型越界的时候，直接转为长整型，因此不会得到负数。</p><p>但是，<strong>一般编程语言的编译器都会将 <code>/ 2</code>，以及除以 $2$ 的方幂的操作，在内部修改为 <code>&gt;&gt;</code>，因此我们编码的时候没有必要写成右移，还有可能遇到运算优先级顺序的问题，就直接写成 <code>/</code> 是没有问题的</strong>。</p><p>其它语言我就不清楚了，读者根据自己使用语言的情况选择合适的语法即可。主要内容就是这些，下面做一个总结总结。</p><h3 id="使用“排除法”写对二分查找问题的一般步骤"><a href="#使用“排除法”写对二分查找问题的一般步骤" class="headerlink" title="使用“排除法”写对二分查找问题的一般步骤"></a>使用“排除法”写对二分查找问题的一般步骤</h3><p>（可以右键“在新标签页中打开图片”可以查看大图）</p><p><img src="https://pic.leetcode-cn.com/e120bac189db2fc912dce550d9c46746a312f362ee3d6d40e799aad8db69ae6f-image.png" alt="image.png"></p><p>1、确定搜索区间初始化时候的左右边界，有时需要关注一下边界值。在初始化时，有时把搜索区间设置大一点没有关系，但是如果恰好把边界值排除在外，再怎么搜索都得不到结果。</p><p>例如本题，如果一开始把 <code>len</code> 这个位置排除在外进行二分搜索，代码是怎么都通不过评测系统的。</p><p>2、无条件写上 <code>while (left &lt; right)</code> ，表示退出循环的条件是 <code>left == right</code>，对于返回左右边界就不用思考了，因此此时它们的值相等；</p><p>3、先写下取整的中间数取法，然后<strong>从如何把 <code>mid</code> 排除掉的角度思考 <code>if</code> 和 <code>else</code> 语句应该怎样写</strong>。</p><p>（这里建议写两个注释。）</p><p>注意：</p><ul><li>一般而言，我都会<strong>把「什么时候不是目标元素」作为注释写在代码中</strong>，提醒自己要判断正确，这一步判断非常关键，直接影响到后面的代码逻辑；</li><li>然后接着思考 <code>mid</code> 不是解的情况下，<code>mid</code> 的左右两边是否存在解，把下一轮搜索的区间范围作为注释写进代码里，进而在确定下一轮搜索区间边界的收缩行为时，这样不容易出错；</li><li>在 <code>if</code> 有把握写对的情况下，<code>else</code> 就是 <code>if</code> 的反面，可以不用思考，直接写出来；</li><li>这种思考方式，就正正好把待搜索区间从逻辑上分成两个区间，一个区间不可能存在目标元素，进而在另一个区间里继续搜索，更符合“二分”的语义。</li></ul><p>4、根据 <code>if</code> <code>else</code> 里面写的情况，看看是否需要修改中间数下取整的行为。</p><p>上面已经说了，只有看到 <code>left = mid</code> 的时候，才需要调整成为上取整，记住这一点即可，我因为刚开始不理解这种写法，遇到很多次死循环，现在已经牢记在心了。</p><p>5、退出循环的时候，一定有 <code>left == right</code> 成立。有些时候可以直接返回 <code>left</code> （或者 <code>right</code>，由于它们相等，后面都省略括弧）或者与 <code>left</code> 相关的数值，有些时候还须要再做一次判断，判断 <code>left</code> 与 <code>right</code> 是否是我们需要查找的元素，这一步叫“后处理”。</p><h3 id="与其它二分查找模板的比较"><a href="#与其它二分查找模板的比较" class="headerlink" title="与其它二分查找模板的比较"></a>与其它二分查找模板的比较</h3><p>它们的区别主要在于 <code>while</code> ，这是几个模板之间最主要的差别。</p><p>1、 <code>while (left &lt;= right)</code> 事实上是把待搜索区间“三分”，<code>if</code> <code>else</code> 有三个分支，它直接面对目标元素，在目标元素在待搜索数组中有只有 1 个的时候，可能提前结束查找。但是如果目标元素没有在待搜索数组中存在，则不能节约搜索次数；</p><p>2、<code>while (left &lt; right)</code> 是本题解推荐使用的思考方法，没有写成模板是因为不建议记模板，建议的方法是多做题，掌握“排除法”，更学术的说法是使用“减治法”编写二分查找算法的方法。</p><p>优点是：更符合二分语义，不用去思考返回 <code>left</code> 还是 <code>right</code>，在退出循环的时候，有的时候，根据语境不正确的数都排除掉，最后剩下的那个数就一定是目标值，不需要再做一次判断。</p><p>缺点是：理解当分支逻辑出现 <code>left = mid</code> 的时候，要修改取中间数的行为，使其上取整。</p><p>3、<code>while (left + 1 &lt; right)</code> 这种写法其实很多人都在用，如果你理解了本题解介绍的方法，理解它就很容易了。使用它在退出循环的时候，有 <code>left + 1 = right</code> 成立，即 <code>left</code> 和 <code>right</code>夹成的区间里一定有 2 个元素，此时需要分别判断 <code>left</code> 和 <code>right</code> 位置的元素是不是目标元素，有时需要注意判断的先后顺序。</p><p>优点：不用去理解和处理第 2 点说的那种上取整的行为，因为不会出现死循环。<br>缺点：一定需要后处理，在后处理这个问题上增加了思考的负担。另外 <code>while (left + 1 &lt; right)</code> 这种写法我个人认为不那么自然。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>「力扣」上的二分查找问题主要有这三类题型。</p><h4 id="一、在数组中查找符合条件的元素的索引"><a href="#一、在数组中查找符合条件的元素的索引" class="headerlink" title="一、在数组中查找符合条件的元素的索引"></a>一、在数组中查找符合条件的元素的索引</h4><p>一般而言这个数组是有序的，也可能是半有序的，但不大可能是无序的。</p><table><thead><tr><th>题目</th><th>提示与题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></td><td>二分查找的模板问题，使用本题解介绍的方法就要注意，需要“后处理”。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></td><td>查找边界问题，<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/" target="_blank" rel="noopener">题解（有视频讲解）</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></td><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-java-dai-ma-by-/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></td><td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></td><td>二分查找的思路需要理解，代码很像第 35 题，<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">275. H指数 II</a></td><td><a href="https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></td><td><a href="https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个有序数组的中位数</a></td><td>二分搜索中最难的问题之一，建议先弄清楚解题思路，<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/" target="_blank" rel="noopener">题解</a>。</td></tr></tbody></table><h4 id="二、在一个有上下界的区间里搜索一个整数"><a href="#二、在一个有上下界的区间里搜索一个整数" class="headerlink" title="二、在一个有上下界的区间里搜索一个整数"></a>二、在一个有上下界的区间里搜索一个整数</h4><table><thead><tr><th>题目</th><th>提示与题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">69. 平方根</a></td><td>在一个整数范围里查找一个整数，也是二分查找法的应用场景，<a href="https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/" target="_blank" rel="noopener">题解</a>。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></td><td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/" target="_blank" rel="noopener">题解</a>。在一个整数范围里查找一个整数。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener">374. 猜数字大小</a></td><td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/" target="_blank" rel="noopener">题解</a></td></tr></tbody></table><h4 id="三、判别条件是一个函数"><a href="#三、判别条件是一个函数" class="headerlink" title="三、判别条件是一个函数"></a>三、判别条件是一个函数</h4><table><thead><tr><th>题目</th><th>提示与题解</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">278. 第一个错误的版本</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">658. 找到 K 个最接近的元素</a></td><td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></td><td><a href="https://leetcode-cn.com/problems/koko-eating-bananas/solution/er-fen-cha-zhao-ding-wei-su-du-by-liweiwei1419/" target="_blank" rel="noopener">题解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></td><td><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/" target="_blank" rel="noopener">题解</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「二分查找」专题一：在循环体内部查找元素</title>
      <link href="/leetcode-algo/2017/05/15/leetcode-solution/array1/"/>
      <url>/leetcode-algo/2017/05/15/leetcode-solution/array1/</url>
      
        <content type="html"><![CDATA[<h2 id="「二分查找」专题一：在循环体内部查找元素"><a href="#「二分查找」专题一：在循环体内部查找元素" class="headerlink" title="「二分查找」专题一：在循环体内部查找元素"></a>「二分查找」专题一：在循环体内部查找元素</h2><p>「力扣」第 704 题是二分查找的模板问题。</p><h3 id="「力扣」第-704-题：二分查找"><a href="#「力扣」第-704-题：二分查找" class="headerlink" title="「力扣」第 704 题：二分查找"></a>「力扣」第 704 题：二分查找</h3><p>传送门：<a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a>。</p><blockquote><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1</code></pre><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol></blockquote><h3 id="把数组分成-3-个部分"><a href="#把数组分成-3-个部分" class="headerlink" title="把数组分成 3 个部分"></a>把数组分成 3 个部分</h3><p>循环部分给出的条件是 <code>while (left &lt;= right)</code>，表示当 <code>left == right</code> 成立的时候，还有一个元素，即下标为 <code>left</code>（<code>right</code>）位置的元素还没有看到，需要继续查看这个元素的值，看看是不是我们想要的。</p><p>这个思路把待查找数组分为了 3 个部分：</p><ul><li><code>mid</code> 所在位置；</li><li><code>mid</code> 的左边（不包括 <code>mid</code>）；</li><li><code>mid</code> 的右边（不包括 <code>mid</code>）。</li></ul><p>根据 <code>mid</code> 元素与目标元素的值的大小关系，如果 <code>nums[mid]</code> 恰好等于 <code>target</code> 直接返回。否则根据不等关系，<strong>确定下一轮搜索的区间</strong>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 在 [left, right] 范围里查找目标元素</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 由数组的有序性可知，mid 以及 mid 的左边都小等于 target</span>                <span class="token comment" spellcheck="true">// 下一轮搜索的范围是 [mid + 1, right]</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 此时 target &lt; nums[mid]</span>                <span class="token comment" spellcheck="true">// 由数组的有序性可知，mid 以及 mid 的右边边都小等于 target</span>                <span class="token comment" spellcheck="true">// 下一轮搜索的范围是 [left, mid - 1]</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>「力扣」上有些二分题用这种思路做，<strong>有的时候往往会顺带思考很多问题，增加了出错率</strong>，例如：</p><ul><li>返回 <code>left</code> 还是 <code>right</code>；</li><li>明明已经看到了等于 <code>target</code> 的元素，但是题目要求返回小于等于 <code>target</code> 的第 1 个元素的位置，或则要求返回大于等于 <code>target</code> 的最后 1 个元素的位置的时候，一不小心会把代码写成线性查找。</li></ul><p>这两个问题有时会增加思考问题的负担，一不小心还有可能出错。这一类问题的共同特点是：目标值往往在待查找数组中存在多个，但是题目要求我们返回的是一个边界值。</p><blockquote><p>简单问题用这个思路是没有问题的。</p></blockquote><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 2：二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 减治思想 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 14：桶排序（了解）</title>
      <link href="/leetcode-algo/2017/05/14//leetcode-algo/bucket-sort/"/>
      <url>/leetcode-algo/2017/05/14//leetcode-algo/bucket-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-14：桶排序（了解）"><a href="#「排序算法」专题-14：桶排序（了解）" class="headerlink" title="「排序算法」专题 14：桶排序（了解）"></a>「排序算法」专题 14：桶排序（了解）</h2><ul><li>基本思路：一个坑一个萝卜，也可以一个坑多个萝卜，对每个坑排序，再拿出来，整体就有序。</li></ul><p><strong>参考代码 10</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 桶排序</span>    <span class="token comment" spellcheck="true">// 1 &lt;= A.length &lt;= 10000</span>    <span class="token comment" spellcheck="true">// -50000 &lt;= A[i] &lt;= 50000</span>    <span class="token comment" spellcheck="true">// 10_0000</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OFFSET <span class="token operator">=</span> <span class="token number">50000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第 1 步：将数据转换为 [0, 10_0000] 区间里的数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> OFFSET<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第 2 步：观察数据，设置桶的个数</span>        <span class="token comment" spellcheck="true">// 步长：步长如果设置成 10 会超出内存限制</span>        <span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 桶的个数</span>        <span class="token keyword">int</span> bucketLen <span class="token operator">=</span> 10_0000 <span class="token operator">/</span> step<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>bucketLen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>bucketLen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第 3 步：分桶</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> bucketIndex <span class="token operator">=</span> num <span class="token operator">/</span> step<span class="token punctuation">;</span>            temp<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>next<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>            next<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第 4 步：对于每个桶执行插入排序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketLen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">insertionSort</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第 5 步：从桶里依次取出来</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketLen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> curLen <span class="token operator">=</span> next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> curLen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> OFFSET<span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> endIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endIndex<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：（略，这部分内容不太重要，增加学习负担）</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 递归 </tag>
            
            <tag> partition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 13：基数排序（了解）</title>
      <link href="/leetcode-algo/2017/05/13//leetcode-algo/radix-sort/"/>
      <url>/leetcode-algo/2017/05/13//leetcode-algo/radix-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-13：基数排序（了解）"><a href="#「排序算法」专题-13：基数排序（了解）" class="headerlink" title="「排序算法」专题 13：基数排序（了解）"></a>「排序算法」专题 13：基数排序（了解）</h2><ul><li><p>基本思路：也称为基于关键字的排序，例如针对数值排序，个位、十位、百位就是关键字。针对日期数据的排序：年、月、日、时、分、秒就是关键字。</p></li><li><p><strong>「基数排序」用到了「计数排序」</strong>。</p></li></ul><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 基数排序：低位优先</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OFFSET <span class="token operator">=</span> <span class="token number">50000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预处理，让所有的数都大于等于 0，这样才可以使用基数排序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> OFFSET<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第 1 步：找出最大的数字</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                max <span class="token operator">=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第 2 步：计算出最大的数字有几位，这个数值决定了我们要将整个数组看几遍</span>        <span class="token keyword">int</span> maxLen <span class="token operator">=</span> <span class="token function">getMaxLen</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计数排序需要使用的计数数组和临时数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 表征关键字的量：除数</span>        <span class="token comment" spellcheck="true">// 1 表示按照个位关键字排序</span>        <span class="token comment" spellcheck="true">// 10 表示按照十位关键字排序</span>        <span class="token comment" spellcheck="true">// 100 表示按照百位关键字排序</span>        <span class="token comment" spellcheck="true">// 1000 表示按照千位关键字排序</span>        <span class="token keyword">int</span> divisor <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 有几位数，外层循环就得执行几次</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 每一步都使用计数排序，保证排序结果是稳定的</span>            <span class="token comment" spellcheck="true">// 这一步需要额外空间保存结果集，因此把结果保存在 temp 中</span>            <span class="token function">countingSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> divisor<span class="token punctuation">,</span> len<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 交换 nums 和 temp 的引用，下一轮还是按照 nums 做计数排序</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> t <span class="token operator">=</span> nums<span class="token punctuation">;</span>            nums <span class="token operator">=</span> temp<span class="token punctuation">;</span>            temp <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// divisor 自增，表示采用低位优先的基数排序</span>            divisor <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> OFFSET<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res<span class="token punctuation">,</span> <span class="token keyword">int</span> divisor<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1、计算计数数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 计算数位上的数是几，先取个位，再十位、百位</span>            <span class="token keyword">int</span> remainder <span class="token operator">=</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> divisor<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            count<span class="token punctuation">[</span>remainder<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 2、变成前缀和数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 3、从后向前赋值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> remainder <span class="token operator">=</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> divisor<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> count<span class="token punctuation">[</span>remainder<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            res<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            count<span class="token punctuation">[</span>remainder<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 4、count 数组需要设置为 0 ，以免干扰下一次排序使用</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取一个整数的最大位数     *     * @param num     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getMaxLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            num <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxLen<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxLen<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：（略，这部分内容不太重要，增加学习负担）</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 递归 </tag>
            
            <tag> partition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 12：计数排序</title>
      <link href="/leetcode-algo/2017/05/12//leetcode-algo/counting-sort/"/>
      <url>/leetcode-algo/2017/05/12//leetcode-algo/counting-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-12：计数排序"><a href="#「排序算法」专题-12：计数排序" class="headerlink" title="「排序算法」专题 12：计数排序"></a>「排序算法」专题 12：计数排序</h2><h3 id="3-种「非比较」的排序算法（了解，如果是面向笔试，不要花时间去研究）"><a href="#3-种「非比较」的排序算法（了解，如果是面向笔试，不要花时间去研究）" class="headerlink" title="3 种「非比较」的排序算法（了解，如果是面向笔试，不要花时间去研究）"></a>3 种「非比较」的排序算法（了解，如果是面向笔试，不要花时间去研究）</h3><p>特别说明：<strong>这部分算法不建议花太多去仔细研究它们的细节</strong>。如果是面向面试，了解思想即可，用到了再学。</p><p>直接放弃我个人觉得完全可以。</p><p>学习资料是《算法导论》。下面是我根据《算法导论》上介绍的内容整理出来的。</p><p>这三种排序的区别与上面的排序的特点是：一个数该放在哪里，是由这个数本身的大小决定的，它不需要经过比较。也可以认为是哈希的思想：由数值映射地址。</p><p>因此这三种算法一定需要额外的空间才能完成排序任务，时间复杂度可以提升到 $O(N)$，但适用场景不多，主要是因为<strong>使用这三种排序一定要保证输入数组的每个元素都在一个合理的范围内</strong>（例如本题）。</p><p>这三种算法还有一个特点是：都可以实现成稳定排序，无需稳定化。</p><p>我在这里只是给出了可以通过测评的代码，没有具体展开介绍了。具体想知道细节的朋友可以参考《算法导论》。</p><h3 id="计数排序（了解）"><a href="#计数排序（了解）" class="headerlink" title="计数排序（了解）"></a>计数排序（了解）</h3><p>「计数排序」是这三种排序算法里最好理解的，从名字就可以看出。把每个出现的数值都做一个计数，然后根据计数从小到大输出得到有序数组。</p><p>这种做法丢失了稳定性，如果是本题这种基本数据类型的话没有关系。如果是对象类型，就不能这么做了。</p><p>保持稳定性的做法是：先对计数数组做前缀和，在第 2 步往回赋值的时候，根据原始输入数组的数据从后向前赋值，前缀和数组保存了每个元素存放的下标信息（这里没有说得太细，本来这一点就不重要，也不难理解）。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计数排序</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OFFSET <span class="token operator">=</span> <span class="token number">50000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 由于 -50000 &lt;= A[i] &lt;= 50000</span>        <span class="token comment" spellcheck="true">// 因此"桶" 的大小为 50000 - (-50000) = 10_0000</span>        <span class="token comment" spellcheck="true">// 并且设置偏移 OFFSET = 50000，目的是让每一个数都能够大于等于 0</span>        <span class="token comment" spellcheck="true">// 这样就可以作为 count 数组的下标，查询这个数的计数</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> 10_0000<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计数数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计算计数数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>num <span class="token operator">+</span> OFFSET<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 把 count 数组变成前缀和数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 先把原始数组赋值到一个临时数组里，然后回写数据</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> temp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为了保证稳定性，从后向前赋值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> count<span class="token punctuation">[</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> OFFSET<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            count<span class="token punctuation">[</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> OFFSET<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：（略，这部分内容不太重要，增加学习负担）</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 11：希尔排序（不建议多花时间了解）</title>
      <link href="/leetcode-algo/2017/05/11//leetcode-algo/shell-sort/"/>
      <url>/leetcode-algo/2017/05/11//leetcode-algo/shell-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-11：希尔排序（不建议多花时间了解）"><a href="#「排序算法」专题-11：希尔排序（不建议多花时间了解）" class="headerlink" title="「排序算法」专题 11：希尔排序（不建议多花时间了解）"></a>「排序算法」专题 11：希尔排序（不建议多花时间了解）</h2><p>希尔排序的参考资料是《算法 4》。</p><ul><li>思想来源：插入排序的优化。在插入排序里，如果靠后的数字较小，它来到前面就得交换多次。「希尔排序」改进了这种做法。带间隔地使用插入排序，直到最后「间隔」为 $1$ 的时候，就是标准的「插入排序」，此时数组里的元素已经「几乎有序」了；</li><li>希尔排序的「间隔序列」其实是一个超参数，这方面有一些研究成果，有兴趣的朋友可以了解一下，但是如果这是面向笔试面试，就不用了解了。</li></ul><p><strong>参考代码 6</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 希尔排序</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用 Knuth 增量序列</span>        <span class="token comment" spellcheck="true">// 找增量的最大值</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> h <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>            h <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> h <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>h <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// insertion sort</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">insertionForDelta</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> h<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            h <span class="token operator">=</span> h <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将 nums[i] 插入到对应分组的正确位置上，其实就是将原来 1 的部分改成 gap     *     * @param nums     * @param gap     * @param i     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insertionForDelta</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> gap<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意：这里 j >= deta 的原因</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> gap <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>            j <span class="token operator">-=</span> gap<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希尔排序的时间复杂度至今还没有明确的结论，只有一个范围，已经不在我能介绍的范围了。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 10：冒泡排序（了解）</title>
      <link href="/leetcode-algo/2017/05/10//leetcode-algo/bubble-sort/"/>
      <url>/leetcode-algo/2017/05/10//leetcode-algo/bubble-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-10：冒泡排序（了解）"><a href="#「排序算法」专题-10：冒泡排序（了解）" class="headerlink" title="「排序算法」专题 10：冒泡排序（了解）"></a>「排序算法」专题 10：冒泡排序（了解）</h2><h3 id="冒泡排序（了解）"><a href="#冒泡排序（了解）" class="headerlink" title="冒泡排序（了解）"></a>冒泡排序（了解）</h3><p>前面的选择排序可以作为排序算法的入门算法，插入排序让我们看到了如何改进算法，充分利用每一轮循环的比较来加快排序的速度。冒泡排序的思想如同它的名字一样，每一轮都将一个元素「冒泡」到数组的末尾。</p><h4 id="冒泡排序的基本思想"><a href="#冒泡排序的基本思想" class="headerlink" title="冒泡排序的基本思想"></a>冒泡排序的基本思想</h4><ul><li><p>基本思想：外层循环每一次经过两两比较，把每一轮未排定部分最大的元素放到了数组的末尾；</p></li><li><p>依次将相邻的两个元素进行比较，把较大的元素交换到后面，这样一轮循环下来，就可以找到这一轮循环中最大的那个元素，我们把这个过程形象地称之为“冒泡”；</p></li><li><p>由于每一轮循环都「冒泡」出一个这一轮循环最大的元素，所以上一轮循环的最后一个元素，没有必要再参加下一轮循环的比较了；</p></li><li><p>「冒泡排序」有个特点：在遍历的过程中，提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要很「死板地」地走完所有的流程。</p></li></ul><h4 id="冒泡排序第-1-版"><a href="#冒泡排序第-1-版" class="headerlink" title="冒泡排序第 1 版"></a>冒泡排序第 1 版</h4><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort_1</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 注意临界值的选取</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="冒泡排序第-2-版"><a href="#冒泡排序第-2-版" class="headerlink" title="冒泡排序第 2 版"></a>冒泡排序第 2 版</h4><p>Java 代码：</p><p>以下代码提交以后会出现超时，超时数据是规模较大的数据，一般情况下说明算法是正确的，但不高效。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 冒泡排序：超时</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 先默认数组是有序的，只要发生一次交换，就必须进行下一轮比较，</span>            <span class="token comment" spellcheck="true">// 如果在内层循环中，都没有执行一次交换操作，说明此时数组已经是升序数组</span>            <span class="token keyword">boolean</span> sorted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    sorted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sorted<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：在「冒泡」的过程中检查数组是否已经排好序，如果已经是顺序数组，整个算法就可以终止了。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubble_sort_2</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        sorted <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment" spellcheck="true"># 假设数组是排好序的</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 注意临界值的选取</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                swap<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                sorted <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment" spellcheck="true"># 只要发现有元素交换，就说明假设是错误的</span>        <span class="token comment" spellcheck="true"># 如果一轮下来都没有元素交换，那么接下来的几轮就没有必要进行比较了</span>        <span class="token keyword">if</span> sorted<span class="token punctuation">:</span>            <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N^2)$，这里 $N$ 是数组的长度；</li><li>空间复杂度：$O(1)$，使用到常数个临时变量。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 9：堆排序（第 3 节）</title>
      <link href="/leetcode-algo/2017/05/09//leetcode-algo/heap-sort/"/>
      <url>/leetcode-algo/2017/05/09//leetcode-algo/heap-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-9：堆排序（第-3-节）"><a href="#「排序算法」专题-9：堆排序（第-3-节）" class="headerlink" title="「排序算法」专题 9：堆排序（第 3 节）"></a>「排序算法」专题 9：堆排序（第 3 节）</h2><p>说明：堆很重要，堆排序根据个人情况掌握。这一节内容可以在学习完堆以后掌握。</p><p>堆讲的最好的资料就是《算法 4》，堆的内容比较多，我在这里就不多展开了，建议大家直接看书获得相关知识。</p><ul><li>堆排序是选择排序的优化，选择排序需要在未排定的部分里通过「打擂台」的方式选出最大的元素（复杂度 $O(N)$），而「堆排序」就把未排定的部分构建成一个「堆」，这样就能以 $O(\log N)$ 的方式选出最大元素；</li><li>堆是一种相当有意思的数据结构，它在很多语言里也被命名为「优先队列」。它是建立在数组上的「树」结构，类似的数据结构还有「并查集」「线段树」等。</li></ul><p>我个人是这样看待这些定义的：「优先队列」是一种特殊的队列，按照优先级顺序出队，从这一点上说，与「普通队列」无差别。「优先队列」可以用数组实现，也可以用有序数组实现，但只要是线性结构，复杂度就会高，因此，「树」结构就有优势，「优先队列」的最好实现就是「堆」。</p><p>「堆」还有很多扩展的知识：「索引堆」、「多叉堆」，已经不在我能介绍的范围了，我个人觉得一般的面试问题也不会涉及。但是基础的堆的相关知识是有必要掌握的，要知道堆的底层是数组，可能涉及扩容的问题，上浮和下沉操作。</p><p>「力扣」上有很多使用「优先队列」完成的问题，感兴趣的朋友不妨做一下。</p><p>至于现在笔试考不考「手写一个堆」，我个人觉得意义不大。如果真的考到了，能写尽量写，不能一次写对就和面试官说明自己对于「堆」所掌握的知识我感觉就可以了。面试的时候，本来精神就比平常紧张。我们都不是「堆」的发明人，了解和熟悉「堆」的原理和使用场景，自己学习的时候，手写过堆，通过了测试用例就可以了。</p><p><strong>参考代码 5</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将数组整理成堆</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环不变量：区间 [0, i] 堆有序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 把堆顶元素（当前最大）交换到数组末尾</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 逐步减少堆有序的部分</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 下标 0 位置下沉操作，使得区间 [0, i] 堆有序</span>            <span class="token function">siftDown</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将数组整理成堆（堆有序）     *     * @param nums     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 只需要从 i = (len - 1) / 2 这个位置开始逐层下移</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">siftDown</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * @param nums     * @param k    当前下沉元素的下标     * @param end  [0, end] 是 nums 的有效部分     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> end <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            k <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N \log N)$，这里 $N$ 是数组的长度；</li><li>空间复杂度：$O(1)$。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 8：快速排序（第 3 节）</title>
      <link href="/leetcode-algo/2017/05/08/algorithms-and-data-structures/quick-sort-3/"/>
      <url>/leetcode-algo/2017/05/08/algorithms-and-data-structures/quick-sort-3/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-8：快速排序（第-3-节）"><a href="#「排序算法」专题-8：快速排序（第-3-节）" class="headerlink" title="「排序算法」专题 8：快速排序（第 3 节）"></a>「排序算法」专题 8：快速排序（第 3 节）</h2><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 快速排序 3：三指针快速排序</span>    <span class="token comment" spellcheck="true">/**     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INSERTION_SORT_THRESHOLD <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Random RANDOM <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 小区间使用插入排序</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;=</span> INSERTION_SORT_THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">insertionSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> randomIndex <span class="token operator">=</span> left <span class="token operator">+</span> RANDOM<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> randomIndex<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环不变量：</span>        <span class="token comment" spellcheck="true">// all in [left + 1, lt] &lt; pivot</span>        <span class="token comment" spellcheck="true">// all in [lt + 1, i) = pivot</span>        <span class="token comment" spellcheck="true">// all in [gt, right] > pivot</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> lt <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> gt <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> gt<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                lt<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> lt<span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                gt<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> gt<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> lt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意这里，大大减少了两侧分治的区间</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> lt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> gt<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 对数组 nums 的子区间 [left, right] 使用插入排序     *     * @param nums  给定数组     * @param left  左边界，能取到     * @param right 右边界，能取到     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N \log N)$，这里 $N$ 是数组的长度；</li><li>空间复杂度：$O(\log N)$，这里占用的空间主要来自递归函数的栈空间。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 分治算法 </tag>
            
            <tag> partition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 7：快速排序（第 2 节）</title>
      <link href="/leetcode-algo/2017/05/07/algorithms-and-data-structures/quick-sort-2/"/>
      <url>/leetcode-algo/2017/05/07/algorithms-and-data-structures/quick-sort-2/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-7：快速排序（第-2-节）"><a href="#「排序算法」专题-7：快速排序（第-2-节）" class="headerlink" title="「排序算法」专题 7：快速排序（第 2 节）"></a>「排序算法」专题 7：快速排序（第 2 节）</h2><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 快速排序 2：双指针（指针对撞）快速排序</span>    <span class="token comment" spellcheck="true">/**     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INSERTION_SORT_THRESHOLD <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Random RANDOM <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 小区间使用插入排序</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;=</span> INSERTION_SORT_THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">insertionSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> pIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> pIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> pIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 对数组 nums 的子区间 [left, right] 使用插入排序     *     * @param nums  给定数组     * @param left  左边界，能取到     * @param right 右边界，能取到     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> randomIndex <span class="token operator">=</span> left <span class="token operator">+</span> RANDOM<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> randomIndex<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> lt <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> gt <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环不变量：</span>        <span class="token comment" spellcheck="true">// all in [left + 1, lt) &lt;= pivot</span>        <span class="token comment" spellcheck="true">// all in (gt, right] >= pivot</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>lt <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>lt<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                lt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>gt <span class="token operator">></span> left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>gt<span class="token punctuation">]</span> <span class="token operator">></span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                gt<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lt <span class="token operator">></span> gt<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 细节：相等的元素通过交换，等概率分到数组的两边</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> lt<span class="token punctuation">,</span> gt<span class="token punctuation">)</span><span class="token punctuation">;</span>            lt<span class="token operator">++</span><span class="token punctuation">;</span>            gt<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> gt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> gt<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 分治算法 </tag>
            
            <tag> partition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 6：快速排序（第 1 节）</title>
      <link href="/leetcode-algo/2017/05/06/algorithms-and-data-structures/quick-sort-1/"/>
      <url>/leetcode-algo/2017/05/06/algorithms-and-data-structures/quick-sort-1/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-6：快速排序（第-1-节）"><a href="#「排序算法」专题-6：快速排序（第-1-节）" class="headerlink" title="「排序算法」专题 6：快速排序（第 1 节）"></a>「排序算法」专题 6：快速排序（第 1 节）</h2><ul><li><p>基本思路：快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序；</p><ul><li><p>算法思想：分而治之（分治思想），与「归并排序」不同，「快速排序」在「分」这件事情上不想「归并排序」无脑地一分为二，而是采用了 partition 的方法（书上，和网上都有介绍，就不展开了），因此就没有「合」的过程。</p></li><li><p>实现细节（注意事项）：（针对特殊测试用例：顺序数组或者逆序数组）一定要随机化选择切分元素（<code>pivot</code>），否则在输入数组是有序数组或者是逆序数组的时候，快速排序会变得非常慢（等同于冒泡排序或者「选择排序」）；</p></li></ul></li></ul><p>以下是针对特殊测试用例（有很多重复元素的输入数组）有 3 种版本的快排：</p><ul><li>版本 1：基本快排：把等于切分元素的所有元素分到了数组的同一侧，可能会造成递归树倾斜；</li><li>版本 2：双指针快排：把等于切分元素的所有元素<strong>等概率</strong>地分到了数组的两侧，避免了递归树倾斜，递归树相对平衡；</li><li>版本 3：三指针快排：把等于切分元素的所有元素挤到了数组的中间，在有很多元素和切分元素相等的情况下，递归区间大大减少。</li></ul><blockquote><p>这里有一个经验的总结：之所以快排有这些优化，起因都是来自「递归树」的高度。<strong>关于「树」的算法的优化，绝大部分都是在和树的「高度」较劲</strong>。类似的通过减少树高度、使得树更平衡的数据结构还有「二叉搜索树」优化成「AVL 树」或者「红黑树」、「并查集」的「按秩合并」与「路径压缩」。</p></blockquote><ul><li>写对「快速排序」的技巧：保持「循环不变量」，即定义的变量在循环开始前、循环过程中、循环结束以后，都保持不变的性质，这个性质是人为根据问题特点定义的。</li><li>「循环不变量」的内容在《算法导论》这本书里有介绍。我个人觉得非常有用。<strong>「循环不变量」是证明算法有效性的基础，更是写对代码的保证，遵守循环不变量，是不是该写等于号，先交换还是先 <code>++</code> ，就会特别清楚，绝对不会写错，我在编码的时候，会将遵守的「循环不变量」作为注释写在代码中</strong>。</li></ul><p>快速排序丢失了稳定性，如果需要稳定的快速排序，需要具体定义比较函数，这个过程叫「稳定化」，在这里就不展开了。</p><p>使用「快速排序」解决的经典问题（非常重要）：</p><ul><li>TopK 问题：「力扣」第 215 题：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第 K 个最大元素</a>；</li><li>荷兰国旗问题：「力扣」第 75 题：<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">颜色分类</a>。</li></ul><p>不好意思，我又来啰嗦了：《算法 4》这本书里面的代码风格是极其不推荐的。代码是写给人看的，应该尽量避免代码个人风格化，采用统一规范的写法，保证易读性，可扩展性。</p><p><img src="http://liweiwei1419.gitee.io/visualgo/01-sorting/06-quick-sort-01.png" alt="06-quick-sort-01"></p><p>Java 代码：（下面提供了快排的三个版本，供参考）</p><p>说明：</p><ul><li><code>lt</code> 是 <code>less than</code> 的缩写，表示（严格）小于；</li><li><code>gt</code> 是 <code>greater than</code> 的缩写，表示（严格）大于；</li><li><code>le</code> 是 <code>less than or equal</code> 的缩写，表示小于等于（本代码没有用到）；</li><li><code>ge</code> 是 <code>greater than or equal</code> 的缩写，表示大于等于（本代码没有用到）。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Random<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 快速排序 1：基本快速排序</span>    <span class="token comment" spellcheck="true">/**     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INSERTION_SORT_THRESHOLD <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Random RANDOM <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 小区间使用插入排序</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;=</span> INSERTION_SORT_THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">insertionSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> pIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> pIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> pIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 对数组 nums 的子区间 [left, right] 使用插入排序     *     * @param nums  给定数组     * @param left  左边界，能取到     * @param right 右边界，能取到     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> randomIndex <span class="token operator">=</span> RANDOM<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> left<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> randomIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 基准值</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> lt <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环不变量：</span>        <span class="token comment" spellcheck="true">// all in [left + 1, lt] &lt; pivot</span>        <span class="token comment" spellcheck="true">// all in [lt + 1, i) >= pivot</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>                lt<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> lt<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> lt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> lt<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 分治算法 </tag>
            
            <tag> partition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 5：「分治思想」经典例子</title>
      <link href="/leetcode-algo/2017/05/05/algorithms-and-data-structures/merge-sort-bottom-to-up/"/>
      <url>/leetcode-algo/2017/05/05/algorithms-and-data-structures/merge-sort-bottom-to-up/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-5：「分治思想」经典例子"><a href="#「排序算法」专题-5：「分治思想」经典例子" class="headerlink" title="「排序算法」专题 5：「分治思想」经典例子"></a>「排序算法」专题 5：「分治思想」经典例子</h2><p>这里给出的例题的解题思路如果对于初学者来说可能不是很容易想到，不过其实你只要熟悉归并排序，按照归并排序的套路，是不难写出下面的代码。反正不过我是写不出的，不过我会看别人写的代码，理解之后，自己写出来。如果觉得理解这些代码比较吃力的话，可以暂时跳过，我写出来还是费了很大力气，并且也是调试和一段时间才把代码写正确的。</p><p>本节介绍了 3 道例题，它们分别是：计算数组的逆序对、计算右侧小于当前元素的个数、最大子序和。</p><h3 id="例1：《剑指-Offer》（第-2-版）第-51-题：计算数组的逆序对"><a href="#例1：《剑指-Offer》（第-2-版）第-51-题：计算数组的逆序对" class="headerlink" title="例1：《剑指 Offer》（第 2 版）第 51 题：计算数组的逆序对"></a>例1：《剑指 Offer》（第 2 版）第 51 题：计算数组的逆序对</h3><ul><li>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">《剑指 Offer》（第 2 版）第 51 题：计算数组的逆序对</a>；</li><li>官方题解链接（有视频讲解）：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/" target="_blank" rel="noopener">数组中的逆序对</a>；</li><li>题解链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/bao-li-jie-fa-fen-zhi-si-xiang-shu-zhuang-shu-zu-b/" target="_blank" rel="noopener">暴力解法、分治思想、树状数组</a>。</li></ul><blockquote><p>在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</p><p>输入一个数组，求出这个数组中的逆序对的总数。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><pre><code>输入：[1,2,3,4,5,6,0]输出：6</code></pre></blockquote><h4 id="方法一：根据定义"><a href="#方法一：根据定义" class="headerlink" title="方法一：根据定义"></a>方法一：根据定义</h4><p>首先我们应该想到，使用定义计算逆序数，时间复杂度是：$O(n^2)$。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法二：分治算法（借助归并排序）"><a href="#方法二：分治算法（借助归并排序）" class="headerlink" title="方法二：分治算法（借助归并排序）"></a>方法二：分治算法（借助归并排序）</h4><p>这种思路虽然很直接，但编写出错的概率就很低了，在没有在线评测系统的时候，它可以作为一个「正确的」参考答案，用以检验我们自己编写的算法是否正确。</p><p>思路2：借助归并排序的分治思想，时间复杂度为 $O(n \log n)$。</p><p>分析：例如：前有序数组：$[2,3,5,8]$，后有序数组：$[4,6,7,12]$。</p><p>做归并的时候，步骤如下：</p><p>第 1 步，$2$ 先出列，$2$ 比“后有序数组”中所有的元素都小，构成“顺序对”；</p><p>第 2 步，$3$ 出列，$3$ 比“后有序数组”中所有的元素都小，构成“顺序对”；</p><p>第 3 步，$4$ 出列，关键的地方在这里，<strong>“前有序数组”中所有剩下的元素 $[5,8]$ 比 $4$  都大，构成 $2$ 个 “逆序对”</strong>；</p><p>第 4 步，$5$ 出列，$5$ 比“后有序数组”中所有剩下的元素都小，构成“顺序对”；</p><p>第 5 步，$6$ 出列，<strong>“前有序数组”中所有剩下的元素 $[8]$ 比 $6$ 都大，构成 $1$ 个“逆序对”</strong>；</p><p>第 6 步，$7$ 出列，<strong>“前有序数组”中所有剩下的元素 $[8]$ 比 $7$ 都大，构成 $1$ 个“逆序对”</strong>；</p><p>第 7 步，$8$ 出列，$8$ 比“后有序数组”中所有剩下的元素 $[8]$ 都小，构成 $1$ 个“顺序对”；</p><p>第 8 步，$12$ 出列，此时“前有序数组”为空。</p><p>因此，我们只需要在<strong>“前有序数组”非空，且“后有序数组”中有元素出列的时候，即上面的第 3、5、6 步计算“逆序对”就可以了</strong>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            copy<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span>copy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * nums[left..right] 计算逆序对个数并且排序     *     * @param nums     * @param left     * @param right     * @param temp     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> leftPairs <span class="token operator">=</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightPairs <span class="token operator">=</span> <span class="token function">reversePairs</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果整个数组已经有序，则无需合并，注意这里使用小于等于</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> leftPairs <span class="token operator">+</span> rightPairs<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> crossPairs <span class="token operator">=</span> <span class="token function">mergeAndCount</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> leftPairs <span class="token operator">+</span> rightPairs <span class="token operator">+</span> crossPairs<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * nums[left..mid] 有序，nums[mid + 1..right] 有序     *     * @param nums     * @param left     * @param mid     * @param right     * @param temp     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">mergeAndCount</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 有下标访问，得先判断是否越界</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 注意：这里是 &lt;= ，写成 &lt; 就不对，请思考原因</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 在 j 指向的元素归并回去的时候，计算逆序对的个数，只多了这一行代码</span>                count <span class="token operator">+=</span> <span class="token punctuation">(</span>mid <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inversePairs1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">inversePairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        l <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count_inversion_pairs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">count_inversion_pairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        在数组 nums 的区间 [l,r] 统计逆序对        :param nums:        :param l: 待统计数组的左边界，可以取到        :param r: 待统计数组的右边界，可以取到        :param temp:        :return:        """</span>        <span class="token comment" spellcheck="true"># 极端情况下，就是只有 1 个元素的时候</span>        <span class="token keyword">if</span> l <span class="token operator">==</span> r<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        left_pairs <span class="token operator">=</span> self<span class="token punctuation">.</span>count_inversion_pairs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        right_pairs <span class="token operator">=</span> self<span class="token punctuation">.</span>count_inversion_pairs<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        merge_pairs <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 代码走到这里的时候，</span>        <span class="token comment" spellcheck="true"># [l, mid] 已经完成了排序并且计算好逆序对</span>        <span class="token comment" spellcheck="true"># [mid + 1, r] 已经完成了排序并且计算好逆序对</span>        <span class="token comment" spellcheck="true"># 如果 nums[mid] &lt;= nums[mid + 1]，此时就不存在逆序对</span>        <span class="token comment" spellcheck="true"># 当 nums[mid] > nums[mid + 1] 的时候，就要继续计算逆序对</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 在归并的过程中计算逆序对</span>            merge_pairs <span class="token operator">=</span> self<span class="token punctuation">.</span>merge_and_count<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 走到这里有 nums[mid] &lt;= nums[mid + 1] 成立，已经是顺序结构</span>        <span class="token keyword">return</span> left_pairs <span class="token operator">+</span> right_pairs <span class="token operator">+</span> merge_pairs    <span class="token keyword">def</span> <span class="token function">merge_and_count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        前：[2,3,5,8]，后：[4,6,7,12]        我们只需要在后面数组元素出列的时候，数一数前面这个数组还剩下多少个数字，        因为"前"数组和"后"数组都有序，        因此，"前"数组剩下的元素个数 mid - i + 1 就是与"后"数组元素出列的这个元素构成的逆序对个数        """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        i <span class="token operator">=</span> l        j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">></span> mid<span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> j <span class="token operator">></span> r<span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 不统计逆序对，只做排序</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                i <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">assert</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment" spellcheck="true"># 快就快在这里，一次可以数出一个区间的个数的逆序对</span>                <span class="token comment" spellcheck="true"># 例：[7,8,9][4,6,9]，4 与 7 以及 7 前面所有的数都构成逆序对</span>                res <span class="token operator">+=</span> <span class="token punctuation">(</span>mid <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：归并两个有序数组的时候，我们要借助额外的辅助空间，为此可以全局使用一个和原始数组等长的辅助数组，否则每一次进入 <code>merge</code> 函数都要 new 新数组，开销很大。</p><p>上述解法的缺点是修改了原始数组，排序完成以后，逆序数就计算出来了。为此：1、我们可以引入一个索引数组；2、或者直接拷贝一个原始数组，这样就不用修改原始数组了。</p><h3 id="例2：「力扣」第-315-题：计算右侧小于当前元素的个数"><a href="#例2：「力扣」第-315-题：计算右侧小于当前元素的个数" class="headerlink" title="例2：「力扣」第 315 题：计算右侧小于当前元素的个数"></a>例2：「力扣」第 315 题：计算右侧小于当前元素的个数</h3><p>传送门：<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a>。</p><blockquote><p>给定一个整数数组 <em>nums<em>，按要求返回一个新数组 *counts</em>。数组 *counts</em> 有该性质： <code>counts[i]</code> 的值是  <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</p><p><strong>示例:</strong></p><pre><code>输入: [5,2,6,1]输出: [2,1,1,0] 解释:5 的右侧有 2 个更小的元素 (2 和 1).2 的右侧仅有 1 个更小的元素 (1).6 的右侧有 1 个更小的元素 (1).1 的右侧有 0 个更小的元素.</code></pre></blockquote><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countSmaller</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: List[int]        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        temp <span class="token operator">=</span> <span class="token punctuation">[</span>None <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">]</span>        indexes <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>__helper<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">,</span> indexes<span class="token punctuation">,</span> res<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">__helper</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> indexes<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> right<span class="token punctuation">:</span>            <span class="token keyword">return</span>        mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token comment" spellcheck="true"># 计算一下左边</span>        self<span class="token punctuation">.</span>__helper<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> indexes<span class="token punctuation">,</span> res<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 计算一下右边</span>        self<span class="token punctuation">.</span>__helper<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> indexes<span class="token punctuation">,</span> res<span class="token punctuation">)</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>__sort_and_count_smaller<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> indexes<span class="token punctuation">,</span> res<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__sort_and_count_smaller</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> indexes<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># [left,mid] 前有序数组</span>        <span class="token comment" spellcheck="true"># [mid+1,right] 后有序数组</span>        <span class="token comment" spellcheck="true"># 先拷贝，再合并</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> indexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        l <span class="token operator">=</span> left        r <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> l <span class="token operator">></span> mid<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># l 用完，就拼命使用 r</span>                <span class="token comment" spellcheck="true"># [1,2,3,4] [5,6,7,8]</span>                indexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                r <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> r <span class="token operator">></span> right<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># r 用完，就拼命使用 l</span>                <span class="token comment" spellcheck="true"># [6,7,8,9] [1,2,3,4]</span>                indexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment" spellcheck="true"># 注意：此时前面剩下的数，比后面所有的数都大</span>                res<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> mid<span class="token punctuation">)</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>temp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>temp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># [3,5,7,9] [4,6,8,10]</span>                indexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>l<span class="token punctuation">]</span>                l <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token comment" spellcheck="true"># 注意：</span>                res<span class="token punctuation">[</span>indexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">assert</span> nums<span class="token punctuation">[</span>temp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>temp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># 上面两种情况只在其中一种统计就可以了</span>                <span class="token comment" spellcheck="true"># [3,5,7,9] [4,6,8,10]</span>                indexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>r<span class="token punctuation">]</span>                r <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：这里用到了一个索引数组 <code>indeses</code>，是一个常见的技巧。比如我们交换数组的元素成本很大的时候，可以使用索引数组，交换索引成本很低。这一点，在我们以后介绍索引堆的时候还会用到。</p><h3 id="例3：「力扣」第-53-题：最大子序和"><a href="#例3：「力扣」第-53-题：最大子序和" class="headerlink" title="例3：「力扣」第 53 题：最大子序和"></a>例3：「力扣」第 53 题：最大子序和</h3><ul><li><p>中文网址：<a href="https://leetcode-cn.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">53. 最大子序和</a> ；</p></li><li><p>英文网址：<a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">53. Maximum Subarray</a> ；</p></li><li><p>题解链接：<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/" target="_blank" rel="noopener">动态规划、分治法</a>。</p></li></ul><blockquote><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p></blockquote><p>分析：这道题其实最先应该想到使用动态规划，使用分治有点“小题大作”，我们不妨把分治解法看做一个例题。</p><p>分治的时候，要注意一点，不重不漏。</p><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :type nums: List[int]        :rtype: int        """</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token number">0</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__max_sub_array<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__max_sub_array</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> left <span class="token operator">==</span> right<span class="token punctuation">:</span>            <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span>        mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>self<span class="token punctuation">.</span>__max_sub_array<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span>                   self<span class="token punctuation">.</span>__max_sub_array<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">,</span>                   self<span class="token punctuation">.</span>__max_cross_array<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__max_cross_array</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        一定包含 nums[mid] 元素的最大连续子数组的和        思路是看看左边扩散到底，得到一个最大数        右边扩散到底得到一个最大数        :param nums:        :param mid:        :param right:        :return:        """</span>        ls <span class="token operator">=</span> <span class="token number">0</span>        j <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        s1 <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> j <span class="token operator">>=</span> left<span class="token punctuation">:</span>            s1 <span class="token operator">+=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            ls <span class="token operator">=</span> max<span class="token punctuation">(</span>ls<span class="token punctuation">,</span> s1<span class="token punctuation">)</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        rs <span class="token operator">=</span> <span class="token number">0</span>        j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        s2 <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>            s2 <span class="token operator">+=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            rs <span class="token operator">=</span> max<span class="token punctuation">(</span>rs<span class="token punctuation">,</span> s2<span class="token punctuation">)</span>            j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ls <span class="token operator">+</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">+</span> rs<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>    result <span class="token operator">=</span> s<span class="token punctuation">.</span>maxSubArray<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「分治思想」的应用</title>
      <link href="/leetcode-algo/2017/05/04/algorithms-and-data-structures/merge-sort-optimize/"/>
      <url>/leetcode-algo/2017/05/04/algorithms-and-data-structures/merge-sort-optimize/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-4：归并排序的优化"><a href="#「排序算法」专题-4：归并排序的优化" class="headerlink" title="「排序算法」专题 4：归并排序的优化"></a>「排序算法」专题 4：归并排序的优化</h2><p>根据上一节的「归并排序」的 3 个优化，写出的代码。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 列表大小等于或小于该大小，将优先于 mergeSort 使用插入排序     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INSERTION_SORT_THRESHOLD <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 对数组 nums 的子区间 [left, right] 进行归并排序     *     * @param nums     * @param left     * @param right     * @param temp  用于合并两个有序数组的辅助数组，全局使用一份，避免多次创建和销毁     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 小区间使用插入排序</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">&lt;=</span> INSERTION_SORT_THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">insertionSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Java 里有更优的写法，在 left 和 right 都是大整数时，即使溢出，结论依然正确</span>        <span class="token comment" spellcheck="true">// int mid = (left + right) >>> 1;</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果数组的这个子区间本身有序，无需合并</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">mergeOfTwoSortedArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 对数组 arr 的子区间 [left, right] 使用插入排序     *     * @param arr   给定数组     * @param left  左边界，能取到     * @param right 右边界，能取到     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> left <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 合并两个有序数组：先把值复制到临时数组，再合并回去     *     * @param nums     * @param left     * @param mid   [left, mid] 有序，[mid + 1, right] 有序     * @param right     * @param temp  全局使用的临时数组     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">mergeOfTwoSortedArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 注意写成 &lt; 就丢失了稳定性（相同元素原来靠前的排序以后依然靠前）</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// temp[i] > temp[j]</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N \log N)$，这里 $N$ 是数组的长度；</li><li>空间复杂度：$O(N)$，辅助数组与输入数组规模相当。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 3：归并排序（重点）</title>
      <link href="/leetcode-algo/2017/05/03/algorithms-and-data-structures/merge-sort/"/>
      <url>/leetcode-algo/2017/05/03/algorithms-and-data-structures/merge-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-3：归并排序（重点）"><a href="#「排序算法」专题-3：归并排序（重点）" class="headerlink" title="「排序算法」专题 3：归并排序（重点）"></a>「排序算法」专题 3：归并排序（重点）</h2><p><strong>基本思路</strong>：借助额外空间，合并两个有序数组，得到更长的有序数组。例如：「力扣」第 88 题：<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a>。</p><p><strong>算法思想</strong>：分而治之（分治思想）。「分而治之」思想的形象理解是「曹冲称象」、MapReduce，在一定情况下可以并行化。</p><blockquote><p>个人建议：「归并排序」是理解「递归思想」的非常好的学习材料，大家可以通过理解：递归完成以后，合并两个有序数组的这一步骤，想清楚程序的执行流程。即「递归函数执行完成以后，我们还可以做点事情」。因此，「归并排序」我个人觉得非常重要，一定要掌握。</p></blockquote><h3 id="归并排序算法的基本实现（第-1-版）"><a href="#归并排序算法的基本实现（第-1-版）" class="headerlink" title="归并排序算法的基本实现（第 1 版）"></a>归并排序算法的基本实现（第 1 版）</h3><p>这是我们首次接触<strong>递归算法</strong>的实现。下面我将一步一步展示如何编写递归函数实现归并排序。</p><h4 id="第-1-步：先写出最顶层函数"><a href="#第-1-步：先写出最顶层函数" class="headerlink" title="第 1 步：先写出最顶层函数"></a>第 1 步：先写出最顶层函数</h4><p>我们对下标在 <code>[0, len - 1]​</code> ，左闭且右闭的这个区间里的元素使用递归的「归并排序」算法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 第 1 步：写出归并排序的外层框架 */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test05</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 我们对于归并排序的定义是左闭右闭的，所以第 3 个参数应该使用数组的长度 -1     */</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第-2-步：写出递归函数"><a href="#第-2-步：写出递归函数" class="headerlink" title="第 2 步：写出递归函数"></a>第 2 步：写出递归函数</h4><p>注意应该先考虑递归终止的条件。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 第 2 步：实现归并排序算法（内层框架）这是顶向下的归并排序实现 * 递归调用的函数的定义是：对 arr 在 [left, right] 这个区间范围内使用归并排序 * 即对 arr 数组在索引 [left, right] 这个区间内的元素进行归并排序 * 特别注意：区间的边界 left 和 right 都是可以取到的 * @param arr   待排序数组 * @param left  闭区间端点 * @param right 闭区间端点 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当带排序的部分只有 1 个元素甚至更少的时候，归并排序就终止了，这一步很关键</span>    <span class="token comment" spellcheck="true">// 使用递归进行代码实现的时候，递归到底的情况一定要考虑进来，否则递归就会无限进行下去，在逻辑上一定是错误的</span>    <span class="token comment" spellcheck="true">// 先处理递归到底的情况，即递归终止条件：</span>    <span class="token comment" spellcheck="true">// 1、不形成区间：left > right;</span>    <span class="token comment" spellcheck="true">// 2、形成的区间长度为 1 ：left = right，此时没有必要去"分"，也无法"分"</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 只有一个元素的时候，无需任何操作</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用一分为二的思路，一直递归下去</span>    <span class="token comment" spellcheck="true">// int mid = (left + right) / 2; 这种写法在 left 和 right 是大整数的时候，会发生溢出</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 下面这几行代码关于边界值的处理要特别小心，要紧扣自己定义的变量的含义进行逻辑的编写</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mergeTwoSortedArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意 1</strong>：首先处理递归到底的情况，这是很关键的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意 2</strong>：取中间值使用 <code>int mid = left + (right - left) / 2;</code> 这样可以避免使用 <code>int mid = (left + right) / 2;</code> 这种方式导致 <code>left + right</code> 越界的情况。</p><p><strong>注意 3</strong>：下面两段代码第 3 行与第 1、2 两行的关系。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mergeTwoSortedArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>还可以这样写：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mergeTwoSortedArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：应该准确理解 <code>mergeTwoSortedArray</code> 这个方法的含义，<strong>对于边界值的选择一定要紧扣我们设置的变量的含义</strong>。</p><h4 id="第-3-步：编写-mergeTwoSortedArray-方法"><a href="#第-3-步：编写-mergeTwoSortedArray-方法" class="headerlink" title="第 3 步：编写 mergeTwoSortedArray 方法"></a>第 3 步：编写 <code>mergeTwoSortedArray</code> 方法</h4><p>我们要维护归并排序的定义，注意边界值。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 把两个已经排好序的数组进行合并 * 第 1 个数组：arr[left, ..., mid]，是排好序的 * 第 2 个数组：arr[mid+1, ..., right]，是排好序的 * * @param arr   待排序数组 * @param left  arr[left,mid] 已经是排好序的 * @param mid * @param right arr[mid+1,right] 已经是排好序的 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">mergeTwoSortedArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先计算出这个数组的长度</span>    <span class="token comment" spellcheck="true">// 因为是左边闭区间，右边闭区间，所以元素的个数就是：右边界 - 左边界 + 1</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新建一个数组，赋值，用于比较</span>    <span class="token comment" spellcheck="true">// 这里每进行一次比较，都要 new 一个数组，开销很大</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为新数组赋值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 左边数组的起始位置</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右边数组的起始位置</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 循环遍历把 arr 在 [left, right] 这个区间重新赋值</span>    <span class="token comment" spellcheck="true">// temp 数组中的元素不动，只是拿来做比较，然后我们一直修改的是 arr 数组在 [left, right] 的值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 先考虑如果左边数组用完（越界）的情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> mid <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 此时 l 遍历完成，就去拼命遍历 r 就好了</span>            arr<span class="token punctuation">[</span>i <span class="token operator">+</span> left<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            r<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">></span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 此时 r 遍历完成，就去拼命遍历 l 就好了</span>            arr<span class="token punctuation">[</span>i <span class="token operator">+</span> left<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i <span class="token operator">+</span> left<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i <span class="token operator">+</span> left<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            r<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本的归并排序的思路其实并不难，可以使用规模较小的数组测试。</p><h3 id="优化的方向"><a href="#优化的方向" class="headerlink" title="优化的方向"></a>优化的方向</h3><ul><li>优化 1：在「小区间」里转向使用「插入排序」，Java 源码里面也有类似这种操作，「小区间」的长度是个超参数，需要测试决定，我这里参考了 JDK 源码；</li><li>优化 2： 在「两个数组」本身就是有序的情况下，无需合并；</li><li>优化 3：全程使用一份临时数组进行「合并两个有序数组」的操作，避免创建临时数组和销毁的消耗，避免计算下标偏移量。</li><li>注意：实现归并排序的时候，要特别注意，不要把这个算法实现成非稳定排序，区别就在 <code>&lt;=</code> 和 <code>&lt;</code> ，已在代码中注明。</li></ul><p>「归并排序」比「快速排序」好的一点是，它借助了额外空间，可以实现「稳定排序」，Java 里对于「对象数组」的排序任务，就是使用归并排序（的升级版 TimSort，在这里就不多做介绍）。</p><p>「归并排序」也有「原地归并排序」和「不使用递归」的归并排序，但是我个人觉得不常用，编码、调试都有一定难度。<strong>递归、分治处理问题的思想在基础算法领域是非常常见的，建议多练习编写「归并排序」学习递归思想，了解递归的细节，熟悉分治的思想</strong>。</p><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><ul><li>《剑指 Offer》第 51 题：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a>，照着归并排序的思路就能写出来；</li><li>「力扣」第 315 题：<a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">计算右侧小于当前元素的个数</a>，它们是一个问题。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 2：插入排序（熟悉）</title>
      <link href="/leetcode-algo/2017/05/02/algorithms-and-data-structures/insert-sort/"/>
      <url>/leetcode-algo/2017/05/02/algorithms-and-data-structures/insert-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-2：插入排序（熟悉）"><a href="#「排序算法」专题-2：插入排序（熟悉）" class="headerlink" title="「排序算法」专题 2：插入排序（熟悉）"></a>「排序算法」专题 2：插入排序（熟悉）</h2><p><strong>思路</strong>：每次将一个数字插入一个有序的数组里，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。</p><p><strong>结论</strong>：稳定排序，在接近有序的情况下，表现优异。</p><p><img src="http://liweiwei1419.gitee.io/visualgo/01-sorting/02-insertion-sort-01.png" alt="02-insertion-sort-01.png"></p><p>图片来自「力扣」第 147 题：<a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank" rel="noopener">对链表进行插入排序</a>。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 先暂存这个元素，然后之前元素逐个后移，留出空位</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 注意边界 j > 0</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sorting<span class="token punctuation">.</span>sorting_util <span class="token keyword">import</span> SortingUtil<span class="token keyword">from</span> sorting<span class="token punctuation">.</span>examples <span class="token keyword">import</span> GenerateRandomArrayStrategy<span class="token keyword">from</span> sorting<span class="token punctuation">.</span>examples <span class="token keyword">import</span> GenerateNearlySortedArrayStrategy<span class="token keyword">from</span> sorting<span class="token punctuation">.</span>selecting_sort <span class="token keyword">import</span> SelectionSort<span class="token keyword">class</span> <span class="token class-name">InsertionSort</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"插入排序"</span>    @SortingUtil<span class="token punctuation">.</span>cal_time    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        插入排序第 1 版：相比选择排序而言，插入排序的内层循环可以提前终止。        但是这个版本有个缺点，交换次数太多，每一次交换做了 3 次赋值。        """</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 只要前面的比后面的“严格”大，就要交换它们的位置</span>                <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">break</span><span class="token keyword">class</span> <span class="token class-name">InsertionSortOptimizer</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"插入排序（优化）"</span>    @SortingUtil<span class="token punctuation">.</span>cal_time    <span class="token keyword">def</span> <span class="token function">sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 每一轮先让这个元素去别的地方休息一下</span>            temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># 从 i 的前一个元素开始看</span>            j <span class="token operator">=</span> i            <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>                j <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 因为已经看到索引 j 的值小于等于 temp 了</span>            <span class="token comment" spellcheck="true"># 因此空出来的位置是 j，要把 temp 放在这里</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 测试插入排序算法的正确性</span>    <span class="token comment" spellcheck="true"># SortingUtil.test_sorting_algorithm(InsertionSort(), GenerateRandomArrayStrategy(5000))</span>    <span class="token comment" spellcheck="true"># 比较插入排序算法与选择排序</span>    <span class="token comment" spellcheck="true"># SortingUtil.compare_sorting_algorithms(GenerateRandomArrayStrategy(5000),</span>    <span class="token comment" spellcheck="true">#                                        SelectionSort(),</span>    <span class="token comment" spellcheck="true">#                                        InsertionSort())</span>    <span class="token comment" spellcheck="true"># 验证插入排序算法对于几乎有序的数组，越有序越好</span>    SortingUtil<span class="token punctuation">.</span>test_sorting_algorithm<span class="token punctuation">(</span>InsertionSortOptimizer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GenerateRandomArrayStrategy<span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    SortingUtil<span class="token punctuation">.</span>compare_sorting_algorithms<span class="token punctuation">(</span>GenerateRandomArrayStrategy<span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                           SelectionSort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                           InsertionSort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                           InsertionSortOptimizer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    SortingUtil<span class="token punctuation">.</span>compare_sorting_algorithms<span class="token punctuation">(</span>GenerateNearlySortedArrayStrategy<span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                           SelectionSort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                           InsertionSort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                           InsertionSortOptimizer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li><p>时间复杂度：$O(N^2)$，这里 $N$ 是数组的长度；</p></li><li><p>空间复杂度：$O(1)$，使用到常数个临时变量。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>优化：「将一个数字插入一个有序的数组」这一步，可以不使用逐步交换，使用先赋值给「临时变量」，然后「适当的元素」后移，空出一个位置，最后把「临时变量」赋值给这个空位的策略（就是上面那张图的意思）。<strong>编码的时候如果不小心，可能会把数组的值修改，建议多调试</strong>；</li><li>特点：「插入排序」可以提前终止内层循环（体现在 <code>nums[j - 1] &gt; temp</code> 不满足时），在数组「几乎有序」的前提下，「插入排序」的时间复杂度可以达到 $O(N)$；</li><li>由于「插入排序」在「几乎有序」的数组上表现良好，特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素离它最终排定的位置都不会太远。为此，<strong>在小区间内执行排序任务的时候，可以转向使用「插入排序」</strong>。</li></ul><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「排序算法」专题 1：选择排序（了解）</title>
      <link href="/leetcode-algo/2017/05/01/algorithms-and-data-structures/selection-sort/"/>
      <url>/leetcode-algo/2017/05/01/algorithms-and-data-structures/selection-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="「排序算法」专题-1：选择排序（了解）"><a href="#「排序算法」专题-1：选择排序（了解）" class="headerlink" title="「排序算法」专题 1：选择排序（了解）"></a>「排序算法」专题 1：选择排序（了解）</h2><blockquote><p>这里和大家分享一下我学习的「基础排序算法」的知识点。</p></blockquote><p>我从零基础到真正入门算法，就是从学习排序算法开始的，所以「排序算法」是我的初恋，差不多 3 年了。<strong>排序算法作为一项需求，它足够简单，是学习基础算法思想（例如：分治算法、减治思想、递归写法）的很好的学习材料</strong>。 如果觉得算法难，无法入手，不妨从写好一个排序算法开始。</p><p>如果是面试遇到写排序算法，一般还是<strong>先问清楚数据的特点，有的时候可能还会给具体的业务场景</strong>，在面试官肯定采用的算法之后再编码，不要一上来就手撕快排。</p><p>先说干货：</p><p>1、学习算法的可视化网站：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><p>大家点到 Sorting 这一章节，会看到我这篇题解介绍到的 10 大排序算法，而且还是交互式的，<strong>强烈推荐大家去点一下</strong>。 </p><p>建议：先了解算法的思路，再去理解代码是怎么写的。如果看书，看我后面总结的不太清楚的地方，大家自己点一下这个网站，就会非常清楚了，还挺好玩的。</p><p><img src="http://liweiwei1419.gitee.io/visualgo/01-sorting/01-selection-sort-01.png" alt="01-selection-sort-01"></p><p>2、《算法 4》、《算法导论》、《阿里巴巴 Java 开发手册》下载</p><ul><li>链接：<a href="https://pan.baidu.com/s/1hIQM4y_OTlbZnJLYpmLoiw" target="_blank" rel="noopener">https://pan.baidu.com/s/1hIQM4y_OTlbZnJLYpmLoiw</a>  </li><li>密码：91fj</li></ul><p>以下介绍的内容来自《算法 4》和《算法导论》，它们介绍的算法思想足够经典，但不是最新研究结果，也并非最快。如果想研究最新排序算法的结论，可以参考最新的学术论文，或者是在互联网上搜索相关资料，或者是查看您当前所使用语言关于排序部分的源代码。</p><p>（依然是啰嗦两句：《算法 4》和《算法导论》不是面向笔试和面试的书籍，对于新接触算法的朋友，可以把它们作为在「力扣」刷题的参考书，遇到什么知识点不会了，再去查，除非是专业的研究人员，看这两本书的时候建议忽略其中的数学证明和公式，只挑对自己有用的部分来看）。</p><hr><p>「算法」的入门，我们从「排序算法」开始。</p><p>希望通过「排序算法」这一部分的学习，能够让我们认识到「算法」的魅力。「算法」不仅仅只存在与我们的面试中（那时只是因为我不知道「算法」而已），「算法」无处不在，「算法」很有用。</p><h3 id="选择排序的思路"><a href="#选择排序的思路" class="headerlink" title="选择排序的思路"></a>选择排序的思路</h3><p><strong>思路</strong>：每一轮选取未排定的部分中<strong>最小</strong>的那个元素交换到未排定部分的最开头，经过若干个步骤，就能排定整个数组。即：先选出最小的，再选出第二小的，以此类推。</p><p>Java 代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环不变量：[0, i) 有序，且该区间里所有元素就是最终排定的样子</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 选择区间 [i, len - 1] 里最小的元素的索引，交换到下标 i</span>            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index1<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>index2<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        Solution solution <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> solution<span class="token punctuation">.</span><span class="token function">sortArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N^2)$，这里 $N$ 是数组的长度；</li><li>空间复杂度：$O(1)$，使用到常数个临时变量。</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>1、使用「选择排序」完成「力扣」第 912 题：<a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener">排序数组</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>算法思想 1：贪心算法</li></ul><p>每一次决策只看当前，当前最优，则全局最优。注意：这种思想不是任何时候都适用。</p><ul><li>算法思想 2：减治思想</li></ul><p>外层循环每一次都能排定一个元素，问题的规模逐渐减少，直到全部解决，即「大而化小，小而化了」。运用「减治思想」很典型的算法就是大名鼎鼎的「二分查找」。</p><ul><li>优点：<strong>交换次数最少</strong>。</li></ul><p>「选择排序」看起来好像最没有用，但是如果在交换成本较高的排序任务中，就可以使用「选择排序」（《算法 4》相关章节课后练习题）。</p><p>依然是建议大家不要对算法带有个人色彩，在面试回答问题的时候和看待一个人和事物的时候，可以参考的回答模式是「具体问题具体分析，在什么什么情况下，用什么什么算法」。</p><p>（本节完）</p>]]></content>
      
      
      <categories>
          
          <category> 专题 1：排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
